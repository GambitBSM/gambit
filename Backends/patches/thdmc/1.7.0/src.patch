diff -ruN src/CalcLH.cpp src_patched/CalcLH.cpp
--- src/CalcLH.cpp	2015-08-26 22:52:52.000000000 +0930
+++ src_patched/CalcLH.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,6 +1,6 @@
 #include "THDM.h"
 #include "Constraints.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include <iostream>
 
 using namespace std;
@@ -17,16 +17,16 @@
 
   char* in_file = argv[1];
   char* out_file = argv[2];
-  
+
   THDM model;
-  
+
   bool pset = model.read_LesHouches(in_file);
 
   if (!pset) {
     cerr << "Parameters have not been set from the LesHouches file\n";
     return -1;
   }
-  
+
   // Reference SM Higgs mass for EW precision observables
   double mh_ref = 125.;
 
@@ -35,7 +35,7 @@
   model.print_param_gen();
   model.print_param_higgs();
   model.print_param_phys();
-  
+
   check.print_all(mh_ref);
 
   complex <double> cs,cp;
@@ -47,7 +47,7 @@
   pc("A-tautau",cs,cp);
   model.write_LesHouches(out_file,true,true,true,false);
 
-  DecayTable table(model);
+  DecayTableTHDM table(model);
   table.print_decays(1);
   table.print_decays(2);
   table.print_decays(3);
diff -ruN src/CalcMSSM.cpp src_patched/CalcMSSM.cpp
--- src/CalcMSSM.cpp	2015-08-26 22:51:12.000000000 +0930
+++ src_patched/CalcMSSM.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,7 +1,7 @@
 #include "THDM.h"
 #include "Constraints.h"
 #include <iostream>
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 
 using namespace std;
 
@@ -11,16 +11,16 @@
     cout << "Usage: CalcMSSM.x mA tan_beta output_filename\n";
     return -1;
   }
-  
+
   double mA_in = (double)atof(argv[1]);
   double tb_in = (double)atof(argv[2]);
   char* file = argv[3];
-  
+
   THDM model;
-  SM sm;  
-  
+  SM sm;
+
   bool pset = model.set_MSSM(mA_in,tb_in);
-  
+
   if (!pset) {
     cerr << "The values given for one or more parameters were invalid\n";
     return -1;
@@ -29,13 +29,13 @@
   model.print_param_phys();
   model.print_param_gen();
   model.print_param_hybrid();
-  
+
   // Reference SM Higgs mass for EW precision observables
   double mh_ref = 125.;
   Constraints check(model);
   check.print_all(mh_ref);
 
   model.write_LesHouches(file,true,true,true,false);
-  
-  
+
+
 }
diff -ruN src/CalcPhys.cpp src_patched/CalcPhys.cpp
--- src/CalcPhys.cpp	2015-08-26 22:59:27.000000000 +0930
+++ src_patched/CalcPhys.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,6 +1,6 @@
 #include "THDM.h"
 #include "Constraints.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include "HBHS.h"
 #include <iostream>
 
@@ -20,15 +20,15 @@
   double sba_in = (double)atof(argv[5]);
   double l6_in = (double)atof(argv[6]);
   double l7_in = (double)atof(argv[7]);
-  double m12_2_in = (double)atof(argv[8]); 
+  double m12_2_in = (double)atof(argv[8]);
   double tb_in = (double)atof(argv[9]);
   int yt_in = (int)atof(argv[10]);
   char* file = argv[11];
-  
+
 
   THDM model;
 
-  SM sm; 
+  SM sm;
   model.set_SM(sm);
 
   bool pset = model.set_param_phys(mh_in,mH_in,mA_in,mHp_in,sba_in,l6_in,l7_in,m12_2_in,tb_in);
@@ -47,11 +47,11 @@
   model.set_yukawas_type(yt_in);
 
   // Reference SM Higgs mass for EW precision observables
-  double mh_ref = 125.;  
+  double mh_ref = 125.;
 
   // Write model information to the screen
   model.print_param_phys();
-  model.print_param_gen();	  
+  model.print_param_gen();
 
   Constraints check(model);
   check.print_all(mh_ref);
@@ -67,14 +67,14 @@
 
 // Share couplings of 2HDM model with HiggsBounds/HiggsSignals
   HB_set_input_effC(model);
-  
-  // Arrays hold the HiggsBounds results 
+
+  // Arrays hold the HiggsBounds results
   int hbres[6];
   double hbobs[6];
   int hbchan[6];
-  int hbcomb[6];  
+  int hbcomb[6];
 
-// Run HiggsBounds 'full', i.e. with each Higgs result separately  
+// Run HiggsBounds 'full', i.e. with each Higgs result separately
   HB_run_full(hbres, hbchan, hbobs, hbcomb);
   printf("\nHiggsBounds results (full):\n");
   printf("  Higgs  res  chan       ratio        ncomb\n");
@@ -83,16 +83,16 @@
   }
   printf("------------------------------------------------------------\n");
   printf("  TOT %5d %6d %16.8E %5d   %s\n", hbres[0],hbchan[0],hbobs[0],hbcomb[0],hbobs[0]<1 ? "ALLOWED" : "EXCLUDED");
-  
+
   double csqmu;
   double csqmh;
   double csqtot;
   int nobs;
   double pval;
-  
+
   double dMh[3]={0., 0., 0.,};
   HS_set_mass_uncertainties(dMh);
- 
+
   HS_run(&csqmu, &csqmh, &csqtot, &nobs, &pval);
 
   printf("\nHiggsSignals results:\n");
@@ -100,13 +100,13 @@
   printf("  Chi^2 from mass: %16.8E\n", csqmh);
   printf("      Total chi^2: %16.8E\n", csqtot);
   printf("    # observables: %16d\n\n", nobs);
-#endif 
+#endif
 
   // Write LesHouches-style output
   model.write_LesHouches(file,true,true,true,true);
 
   // Print Higgs decays to the screen
-  DecayTable table(model);
+  DecayTableTHDM table(model);
   table.print_decays(1);
   table.print_decays(2);
   table.print_decays(3);
diff -ruN src/Constraints.cpp src_patched/Constraints.cpp
--- src/Constraints.cpp	2015-08-26 23:04:56.000000000 +0930
+++ src_patched/Constraints.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,5 +1,5 @@
 #include "Constraints.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include "THDM.h"
 #include "Util.h"
 #include <fstream>
@@ -27,7 +27,7 @@
 void Constraints::set_THDM(THDM mod) {
   model = mod;
   sm    = mod.get_SM();
-  
+
 //  table.set_model(mod);
 
 }
@@ -36,17 +36,17 @@
 
 // This is deprecated. Use methods defined in HBHS.h instead.
 	return;
-	
+
 #if defined NMSSMTools
   initialize_();
 #endif
 #if defined HiggsBounds
   int nH0=3;
   int nHp=1;
-  int hbflag=3;	
+  int hbflag=3;
   printf("\nInitializing HiggsBounds... ");
 
-   
+
    // Third argument is HB analysis setting: 1='onlyL', 2='onlyH' 3='LandH'
     initialize_higgsbounds_int_(&nH0, &nHp, &hbflag);
 //  initialize_higgsbounds_(&nH0,&nHp,whichexpt);
@@ -98,8 +98,8 @@
   } else {
     cerr << "Error: Cannot open \"" << Hpf_cs << "\" for reading LEP data\n";
   }
-  
-  
+
+
 }
 
 void Constraints::oblique_param(double mh, double &S, double &T, double &U, double &V, double &W, double &X) {
@@ -116,7 +116,7 @@
 
   double m2[3];
   double mu2[5];
-  
+
   complex <double> q11 = model.get_qki(1,1);
   complex <double> q12 = model.get_qki(1,2);
   complex <double> q21 = model.get_qki(2,1);
@@ -124,7 +124,7 @@
 
   m2[1] = 0.;
   m2[2] = pow(model.get_hmass(4),2);
-  
+
   mu2[1] = 0.;
   mu2[2] = pow(model.get_hmass(3),2);
   mu2[3] = pow(model.get_hmass(1),2);
@@ -181,10 +181,10 @@
   V = 0.;
   W = 0.;
   X = 0.;
-    
+
 // Oblique parameter S
   S1 += CS*pow((2.*pow(stw,2)-UdU[2][2]),2)*G_fcn(m2[2],m2[2],mz2);
-  
+
   for (int b=2;b<=3;b++) {
     for (int bp=b+1;bp<=4;bp++) {
       S2 += CS*pow(ImVdV[b][bp],2)*G_fcn(mu2[b],mu2[bp],mz2);
@@ -192,16 +192,16 @@
   }
 
   S3 += -2.*CS*UdU[2][2]*log(m2[2]/mw2);
-  
+
   for (int b=2;b<=4;b++) {
     S4 += CS*real(VdV[b][b])*log(mu2[b]/mw2);
     S5 += CS*pow(ImVdV[1][b],2)*Ghat_fcn(mu2[b],mz2);
   }
-  
+
      S6 += -CS*Ghat_fcn(mh2,mz2);
      S7 += -CS*log(mh2/mw2);
 
- 
+
   S=S1+S2+S3+S4+S5+S6+S7;
 
   // Oblique parameter T
@@ -220,15 +220,15 @@
   }
 
   T4 += -CT*3.*(Fdrho(mz2,mh2)-Fdrho(mw2,mh2));
-  T = T1+T2+T3+T4; 
+  T = T1+T2+T3+T4;
 
   // Oblique parameter U
   for (int b=2;b<=4;b++) {
     U1 += CU*pow(abs(UdV[2][b]),2)*G_fcn(m2[2],mu2[b],mw2);
-  }  
+  }
 
   U2 = -CU*pow((2.*pow(stw,2)-UdU[2][2]),2)*G_fcn(m2[2],m2[2],mz2);
-  
+
   for (int b=2;b<=3;b++) {
     for (int bp=b+1;bp<=4;bp++) {
       U3 += -CU*pow(ImVdV[b][bp],2)*G_fcn(mu2[b],mu2[bp],mz2);
@@ -247,7 +247,7 @@
 
   // Oblique parameter V
   V1+=CV*pow((2.*pow(stw,2)-UdU[2][2]),2)*H_fcn(m2[2],m2[2],mz2);
-  
+
   for (int b=2;b<=3;b++) {
     for (int bp=b+1;bp<=4;bp++) {
       V2+=CV*pow(ImVdV[b][bp],2)*H_fcn(mu2[b],mu2[bp],mz2);
@@ -265,7 +265,7 @@
   // Oblique parameter W
   for (int b=2;b<=4;b++) {
     W+=CW*pow(abs(UdV[2][b]),2)*H_fcn(m2[2],mu2[b],mw2);
-  }  
+  }
 
   for (int b=2;b<=4;b++) {
     W+=CW*pow(ImVdV[1][b],2)*Hhat_fcn(mu2[b],mw2);
@@ -275,8 +275,8 @@
 
   // Oblique parameter X
   X = CX*(2.*pow(stw,2)-UdU[2][2])*G_fcn(m2[2],m2[2],mz2);
-  
-  // Rescaling  
+
+  // Rescaling
   S = S*4.*pow(stw,2)*pow(ctw,2)/alpha;
   T = T/alpha;
   U = U*4.*pow(stw,2)/alpha;
@@ -303,7 +303,7 @@
 
 
 double Constraints::Gtilde_fcn(double x, double y, double q) {
-  
+
   double t = x+y-q;
   double r = q*q-2.*q*(x+y)+pow(x-y,2);
 
@@ -355,7 +355,7 @@
 
 
 double Constraints::Htilde_fcn(double x, double y, double q) {
-  
+
   double t = x+y-q;
   double r = q*q-2.*q*(x+y)+pow(x-y,2);
   double H=0.;
@@ -383,7 +383,7 @@
   double Qd = -1./3.;
   double Qu =  2./3.;
   double Ql = -1.;
-  int 	 Nc =  3;  
+  int 	 Nc =  3;
 
   double m_mu = sm.get_lmass_pole(2);
   double mt = sm.get_qmass_pole(6);
@@ -409,7 +409,7 @@
 
     // CP conservation => Either S or P coupling for each Higgs boson
     double C = max(abs(CS_mu),abs(CP_mu));
-   
+
     damu_1loop += pow(C,2)/(8.*pow(M_PI,2))*dmu_L(pow(mh/m_mu,2),h);
   }
 
@@ -426,7 +426,7 @@
       complex <double> gS(0.,0.), gP(0.,0.);
       model.get_coupling_hdd(h,i,i,gS,gP);
       double m = sm.get_dmass_MSbar(i);
-    
+
       if (m > 1E-3) {
 	double mrun = sm.run_qmass_MSbar(m,m,mh,mt,mb);
 	double x = pow(mrun/mh,2);
@@ -436,13 +436,13 @@
 	damu_2loop += damu;
       }
     }
-		
+
     // Up-type quarks
     for (int i=1;i<=3;i++) {
       complex <double> gS(0.,0.), gP(0.,0.);
       model.get_coupling_huu(h,i,i,gS,gP);
       double m = sm.get_umass_MSbar(i);
-    
+
       if (m > 1E-3) {
 	double mrun = sm.run_qmass_MSbar(m,m,mh,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
 	double x = pow(mrun/mh,2);
@@ -458,7 +458,7 @@
       complex <double> gS(0.,0.), gP(0.,0.);
       model.get_coupling_hll(h,i,i,gS,gP);
       double m = sm.get_lmass_pole(i);
-    
+
       if (m > 1E-3) {
 	double x = pow(m/mh,2);
 
@@ -468,8 +468,8 @@
       }
     }
 
-  }	 
-		 
+  }
+
   damutot = damu_1loop+damu_2loop;
 
   return damutot;
@@ -478,9 +478,9 @@
 
 double Constraints::dmu_L(double z, int h) {
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-       
+
   double result, error;
- 
+
   gsl_function F;
 
   if (h==1) F.function = Lint_s;
@@ -488,11 +488,11 @@
   if (h==3) F.function = Lint_p;
   if (h==4) F.function = Lint_c;
   F.params = &z;
-     
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F, 0, 1, 0, 1e-10, 1000,
-			w, &result, &error); 
-  if (status) 
+			w, &result, &error);
+  if (status)
     if (status!=GSL_EROUND) {
       printf ("gsl error: %s\n", gsl_strerror (status));
       exit(-1);
@@ -507,17 +507,17 @@
 
 double Constraints::dmu_f(double z) {
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-       
+
   double result, error;
- 
+
   gsl_function F;
   F.function = fint;
   F.params = &z;
-     
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F, 0, 1, 0, 1e-10, 1000,
-			w, &result, &error); 
-  if (status) 
+			w, &result, &error);
+  if (status)
     if (status!=GSL_EROUND) {
       printf ("gsl error: %s\n", gsl_strerror (status));
       exit(-1);
@@ -533,17 +533,17 @@
 
 double Constraints::dmu_g(double z) {
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-       
+
   double result, error;
- 
+
   gsl_function F;
   F.function = gint;
   F.params = &z;
-     
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F, 0, 1, 0, 1e-10, 1000,
-			w, &result, &error); 
-  if (status) 
+			w, &result, &error);
+  if (status)
     if (status!=GSL_EROUND) {
       printf ("gsl error: %s\n", gsl_strerror (status));
       exit(-1);
@@ -558,21 +558,21 @@
 
 bool Constraints::check_unitarity(double unitarity_limit) {
   return model.check_unitarity(unitarity_limit);
-}  
+}
 
 bool Constraints::check_perturbativity(double perturbativity_limit) {
   return model.check_perturbativity(perturbativity_limit);
-}  
+}
 
 
 bool Constraints::check_positivity() {
   return model.check_stability();
-}  
+}
 
 
 bool Constraints::check_stability() {
   return model.check_stability();
-}  
+}
 
 
 bool Constraints::check_lep() {
@@ -584,7 +584,7 @@
 	cout << "Constraings::check_masses() has been obsoleted" << endl;
 	cout << "Please use new HBHS interface" << endl;
 	return true;
-  
+
 //  bool HpHp,HpHptau,HpHpcs;
 //   bool test_charged = check_charged(HpHp,HpHptau,HpHpcs);
   bool test_charged = true;
@@ -604,7 +604,7 @@
   test_HiggsBounds = check_HiggsBounds(HBresult, chan, obsratio, ncombined);
 #endif
   bool test_masses=test_charged&&test_NMSSMTools&&test_HiggsBounds;
-  
+
   return test_masses;
 }
 
@@ -612,96 +612,97 @@
 
   // Limit from Z width on charged Higgs mass, hep-ex/0404012
   const double Z_LIMIT_MCH = 39.6;
-  
+
   double mcH = model.get_hmass(4);
-  
+
   HpHp = (mcH > Z_LIMIT_MCH);
-  
+
   double GF = sm.get_GF();
   double mw = sm.get_MW();
   double mz = sm.get_MZ();
   double sw = sm.get_sintw();
   double cw = sm.get_costw();
-  
+
   // sqrt(s) for LEP-II run
   double E_LEP = 209.;
   double s = pow(E_LEP,2);
-  
+
   double ae = -1./(4.*cw*sw);
   double ve = (-1.+4.*pow(sw,2))/(4.*cw*sw);
   double vH = (-1.+2.*pow(sw,2))/(2.*cw*sw);
-  
+
   double beta = sqrt(1.-4.*pow(mcH,2)/s);
-  
+
   // Convert (GeV)^-2 to picobarns
   double C = 0.3894*1E9;
-  
+
   // e+e- --> H+H- cross-section in picobarn
   double s_eeHH = 2.*pow(GF,2)*pow(mw,4)*pow(sw,4)/(3.*M_PI*s)*(1.+2*ve*vH/(1.-pow(mz,2)/s)+(pow(ae,2)+pow(ve,2))*pow(vH,2)/pow(1-pow(mz,2)/s,2))*pow(beta,3)*C;
-  
+
    double wHp_tot = table.get_gammatot_h(4);
    double wHp_tau = table.get_gamma_hln(4,3,3);
    double wHp_cs  = table.get_gamma_hdu(4,2,2);
- 
+
   double lim_brHp_tau = 1E+6;
   double lim_brHp_cs  = 1E+6;
-  
+
   HpHptau = true;
   HpHpcs = true;
-  
+
   if (wHp_tot>0) {
     double brHp_tau = wHp_tau/wHp_tot;
     double brHp_cs  = wHp_cs/wHp_tot;
-    
+
     int n = -1;
     for (int i=0;(i<nHp1);i++) {
-      if (mHp1[i]>mcH) {		
+      if (mHp1[i]>mcH) {
         n=i;
         break;
       }
     }
-    
+
     if (n>0) {
       double valmin = valHp1[n-1];
       double valmax = valHp1[n];
       double mmin = mHp1[n-1];
       double mmax = mHp1[n];
-      
+
       double myval = valmin + (mcH-mmin)/(mmax-mmin)*(valmax-valmin);
       lim_brHp_tau = myval;
     }
-    
+
     n = -1;
     for (int i=0;(i<nHp2);i++) {
-      if (mHp2[i]>mcH) {		
+      if (mHp2[i]>mcH) {
       n = i;
       break;
       }
     }
-    
+
     if (n>0) {
       double valmin = valHp2[n-1];
       double valmax = valHp2[n];
       double mmin = mHp2[n-1];
       double mmax = mHp2[n];
-      
+
       double myval = valmin + (mcH-mmin)/(mmax-mmin)*(valmax-valmin);
       lim_brHp_cs = myval;
     }
-    
+
     if (s_eeHH*brHp_tau>lim_brHp_tau) HpHptau = false;
     if (s_eeHH*brHp_cs>lim_brHp_cs) HpHpcs = false;
   }
-  
+
   return HpHp&&HpHptau&&HpHpcs;
 }
 
-#if defined NMSSMTools
 bool Constraints::check_NMSSMTools(bool &hZ, bool &hZ2b, bool &hZ2tau, bool &hZinv, bool &hZ2j,
 				   bool &hZ2gamma, bool &hZ4b, bool &hZ4tau, bool &hZ2b2tau,
-				   bool &hA, bool &hA4b, bool &hA4tau, bool &hA2b2tau, 
+				   bool &hA, bool &hA4b, bool &hA4tau, bool &hA2b2tau,
 				   bool &hA6b, bool &hA6tau, bool &ZhZjj) {
 
+#if defined NMSSMTools
+
   // The constraints on the neutral Higgses are collected from NMSSMTools,
   // if available
   int i;
@@ -734,7 +735,7 @@
   for (i=0;i<5;i++)
     susyspec_.mneu[i]=0.;
   for (i=0;i<5;i++)
-    for (j=0;j<5;j++) 
+    for (j=0;j<5;j++)
       susyspec_.neu[i][j]=0.;
 
   sfspec_.mur=0.;
@@ -790,7 +791,7 @@
   brn_.width[2]=0.;
   brn_.width[4]=0.;
   // h1,h2,h3,a1,a2 -> gluon gluon
-  for (i=0;i<5;i++) 
+  for (i=0;i<5;i++)
     brn_.brjj[i]=0.;
   // h1,h2,h3,a1,a2 -> mu mu
   brn_.brmm[0]=table.get_gamma_hll(1,2,2)/brn_.width[0];
@@ -878,7 +879,7 @@
   brn_.brhaz[0][2]=0.;
   brn_.brhaz[1][2]=0.;
   // a2 -> a1hi (i=1..3)
-  for (i=0;i<3;i++) 
+  for (i=0;i<3;i++)
     brn_.braha[i]=0.;
   // ai -> Zhj  (i=1,2, j=1..3)
   brn_.brahz[0][0]=table.get_gamma_hvh(3,2,1)/brn_.width[3];
@@ -894,7 +895,7 @@
   brn_.brhcw[2]=0.;
   brn_.brhcw[4]=0.;
   // h1,h2,h3,a1,a2 -> other Higgses
-  for (i=0;i<5;i++) 
+  for (i=0;i<5;i++)
     brn_.brhiggs[i]=0.;
   brn_.brhiggs[1]+=brn_.brhhh[0];
   for (i=0;i<2;i++) {
@@ -959,16 +960,21 @@
 
   return hZ&&hZ2b&&hZ2tau&&hZinv&&hZ2j&&hZ2gamma&&hZ4b&&hZ4tau&&hZ2b2tau&&
     hA&&hA4b&&hA4tau&&hA2b2tau&&hA6b&&hA6tau&&ZhZjj;
+  #else
+  return false;
+  #endif
+
+
 }
-#endif
 
-#if defined HiggsBounds
 bool Constraints::check_HiggsBounds(int &HBresult, int &chan, double &obsratio,
 				    int &ncombined) {
-  
-	double Mh[3]; 
+
+  #if defined HiggsBounds
+
+	double Mh[3];
   int CP[3];
-  double CS_lep_hjZ_ratio[3]; 
+  double CS_lep_hjZ_ratio[3];
   double CS_lep_bbhj_ratio[3];
   double CS_lep_tautauhj_ratio[3];
   double CS_lep_hjhi_ratio[3][3];
@@ -1053,7 +1059,7 @@
     BR_hjinvisible[j]= 0.;
       for (i=0;i<3;i++) {
       BR_hjhihi[i][j]= 0.;
-      
+
       if ((GammaTotal[j]>0)&&(GammaTotal[i]>0)) BR_hjhihi[i][j]=table.get_gamma_hhh(j+1,i+1,i+1)/GammaTotal[j];
       if ((GammaTotal[j]>0)&&(GammaTotal[i]==0)) BR_hjinvisible[j]=table.get_gamma_hhh(j+1,i+1,i+1)/GammaTotal[j];
       model.get_coupling_vhh(2,j+1,i+1,c);
@@ -1061,7 +1067,7 @@
     }
   }
 
-  MHplusGammaTot[0]=table.get_gammatot_h(4);	
+  MHplusGammaTot[0]=table.get_gammatot_h(4);
 
   model.get_coupling_vvh(2,2,1,c);
   CS_lep_hjZ_ratio[0]=pow(abs(c)/(g/costw*MZ),2);
@@ -1114,9 +1120,9 @@
   CS_tev_pp_vbf_ratio[2]=RWW*CS_tev_ud_hjWp_ratio[2]+RZZ*CS_tev_dd_hjZ_ratio[2];
 
 
-  
+
   THDM sm_like;
-  DecayTable sm_table(sm_like);
+  DecayTableTHDM sm_table(sm_like);
 
   // Higgs 1
   sm_like.set_param_phys(Mh[0],Mh[0]*1e2,Mh[0]*1e2,Mh[0]*1e2,1.0,0.,0.,0.,1.);
@@ -1133,7 +1139,7 @@
   model.get_coupling_huu(1,3,3,cst,cpt);
   sm_like.get_coupling_huu(1,3,3,cst_sm,cpt_sm);
   CS_tev_pp_tthj_ratio[0] = pow(abs(cst/cst_sm),2)+pow(abs(cpt/cst_sm),2);
-  
+
   // Higgs 2
   sm_like.set_param_phys(Mh[1],Mh[1]*1e2,Mh[1]*1e2,Mh[1]*1e2,1.0,0.,0.,0.,1.);
   sm_like.set_yukawas_type(1);
@@ -1184,24 +1190,24 @@
 		CS_lep_hjZ_ratio,
 	        CS_lep_bbhj_ratio, CS_lep_tautauhj_ratio,
 		CS_lep_hjhi_ratio,
-                CS_tev_gg_hj_ratio, CS_tev_bb_hj_ratio, 
+                CS_tev_gg_hj_ratio, CS_tev_bb_hj_ratio,
 		CS_tev_bg_hjb_ratio,
-                CS_tev_ud_hjWp_ratio,CS_tev_cs_hjWp_ratio, 
+                CS_tev_ud_hjWp_ratio,CS_tev_cs_hjWp_ratio,
 		CS_tev_ud_hjWm_ratio,CS_tev_cs_hjWm_ratio,
 		CS_tev_gg_hjZ_ratio,
                 CS_tev_dd_hjZ_ratio, CS_tev_uu_hjZ_ratio,
-                CS_tev_ss_hjZ_ratio,CS_tev_cc_hjZ_ratio, 
+                CS_tev_ss_hjZ_ratio,CS_tev_cc_hjZ_ratio,
 		CS_tev_bb_hjZ_ratio,
         CS_tev_pp_vbf_ratio,CS_tev_pp_tthj_ratio,
-		CS_tev_pp_vbf_ratio,CS_tev_pp_tthj_ratio, 
-		CS_tev_pp_vbf_ratio,CS_tev_pp_tthj_ratio, 
+		CS_tev_pp_vbf_ratio,CS_tev_pp_tthj_ratio,
+		CS_tev_pp_vbf_ratio,CS_tev_pp_tthj_ratio,
 		BR_hjss,BR_hjcc,
-		BR_hjbb,BR_hjmumu,BR_hjtautau, 
-                BR_hjWW, BR_hjZZ, BR_hjZga,BR_hjgaga,BR_hjgg, 
+		BR_hjbb,BR_hjmumu,BR_hjtautau,
+                BR_hjWW, BR_hjZZ, BR_hjZga,BR_hjgaga,BR_hjgg,
                 BR_hjinvisible, BR_hjhihi);
 
 //	printf("Input HB charged\n");
-	
+
 	higgsbounds_charged_input_(MHplus,
 		MHplusGammaTot,
 		CS_lep_HpjHmi_ratio,
@@ -1218,11 +1224,13 @@
 //	printf("HB done\n");
 
   return HBresult==1;
+  #else
+  return false;
+  #endif
 }
-#endif
 
 double Constraints::delta_rho(double mh) {
-  
+
   double S,T,U,V,W,X;
   double alpha = sm.get_alpha();
   oblique_param(mh, S, T, U, V, W, X);
@@ -1234,7 +1242,7 @@
 double Constraints::Fdrho(double x, double y) {
 
   double F = 0.0;
-  
+
   if ((x>0)&&(y>0)&&(abs(x-y)>delta*x)) {
     F = 0.5*(x+y)-x*y/(x-y)*log(x/y);
   } else {
@@ -1246,10 +1254,10 @@
 }
 
 void Constraints::print_all(double mh_ref) {
-  double S,T,U,V,W,X;   
+  double S,T,U,V,W,X;
   oblique_param(mh_ref,S,T,U,V,W,X);
-  
-/*  
+
+/*
   bool HpHp,HpHptau,HpHpcs;
   bool test_charged = check_charged(HpHp,HpHptau,HpHpcs);
   bool test_NMSSMTools = true;
@@ -1269,7 +1277,7 @@
 #endif
 */
 //  bool test_masses=test_charged&&test_NMSSMTools&&test_HiggsBounds;
-  
+
   printf("\n");
 	printf("Constraints:\n");
   printf(" Tree-level unitarity: %u\n", model.check_unitarity());
@@ -1281,7 +1289,7 @@
 //#if defined NMSSMTools
 //  printf("  NMSSMTools           %u (hZ:%u hZ2b:%u hZ2tau:%u hZinv:%u hZ2j:%u hZ2gamma:%u hZ4b:%u hZ4tau:%u\n                        hZ2b2tau:%u hA:%u hA4b:%u hA4tau:%u hA2b2tau:%u hA6b:%u hA6tau:%u ZhZjj:%u)\n",test_NMSSMTools,hZ,hZ2b,hZ2tau,hZinv,hZ2j,hZ2gamma,hZ4b,hZ4tau,hZ2b2tau,hA,hA4b,hA4tau,hA2b2tau,hA6b,hA6tau,ZhZjj);
 //#endif
-//  printf("  HiggsBounds          %u (Process %i, see Key.dat, has theory/limit %8.2e combining %i Higgs)\n",test_HiggsBounds,chan,obsratio,ncombined); 
+//  printf("  HiggsBounds          %u (Process %i, see Key.dat, has theory/limit %8.2e combining %i Higgs)\n",test_HiggsBounds,chan,obsratio,ncombined);
 //#endif
   printf("\nOblique parameters:\n");
   printf(" S            %12.5e\n", S);
@@ -1292,4 +1300,4 @@
   printf(" X            %12.5e\n", X);
   printf(" Delta_rho    %12.5e\n", delta_rho(91));
   printf(" Delta_amu    %12.5e\n\n", delta_amu());
-}
\ No newline at end of file
+}
diff -ruN src/Constraints.h src_patched/Constraints.h
--- src/Constraints.h	2015-08-21 21:00:21.000000000 +0930
+++ src_patched/Constraints.h	2018-10-15 12:56:13.000000000 +1030
@@ -3,26 +3,26 @@
 
 #include "SM.h"
 #include "THDM.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 
 using namespace std;
 
 /** @brief Calculates observables useful for constraining the 2HDM.
 *
-*   This class implements various physical observables that can be used to 
-*   constrain the underlying Two-Higgs doublet model. The 2HDM is specified by a 
+*   This class implements various physical observables that can be used to
+*   constrain the underlying Two-Higgs doublet model. The 2HDM is specified by a
 *   THDM object. Methods are provided to access the NMSSMTools library of search
 *   channels for Higgs bosons at LEP (option).
 */
 class Constraints {
-  
- public: 
+
+ public:
 
   /**
   * @brief Default constructor without model specification
-  * 
+  *
   * The default constructor initializes the Constraints object, but the model
-  * on which to operate has to be specified at a later stage through the 
+  * on which to operate has to be specified at a later stage through the
   * set_model method.
   *
   */
@@ -31,68 +31,68 @@
 
   /**
   * @brief Constructor with model specification
-  * 
+  *
   * This constructor initializes the Constraints object to calculate constraints
   * on a general 2HDM. The model on which to operate is specified as an
   * argument to the constructor.
-  * 
+  *
   * @param  mod THDM object for which the constraints should be calculated
   */
   Constraints(THDM mod);
-  
-  
+
+
   /**
   * @brief Sets the model for which to perform the calculations
-  * 
+  *
   * This method sets the underlying THDM object on which the other methods
   * defined in this class operate when performing calculations.
-  * 
+  *
   * @param  mod THDM object to use for the underlying model
   */
   void set_THDM(THDM mod);
 
 
-  /** 
+  /**
   * @brief Checks tree-level unitarity constraints
-  * 
+  *
   * This method checks whether the parameters of the Higgs potential results
   * in an S-matrix for Higgs-Higgs scattering that fullfills tree-level unitarity,
   * as discussed in <a href="http://xxx.lanl.gov/abs/hep-ph/0508020">hep-ph/0508020</a>.
-  * 
+  *
   * @param unitarity_limit optional value to be used for unitarity limit (default = \f$ 16\pi \f$)
-  * 
+  *
   * @returns Boolean \a true if the unitarity constraint is satisfied, \a false otherwise
   */
   bool check_unitarity(double unitarity_limit = 16*M_PI);
 
-  /** 
+  /**
   * @brief Checks perturbativity
-  * 
-  * This method checks wether the couplings of the Higgs and Gauge bosons fullfills perturbativity 
-  * 
+  *
+  * This method checks wether the couplings of the Higgs and Gauge bosons fullfills perturbativity
+  *
   * @param  perturbativity_limit optional value to be used for perturbativity limit (default = \f$ 4\pi \f$)
-  * 
+  *
   * @returns Boolean \a true if the perturbativity constraint is satisfied, \a false otherwise
   */
   bool check_perturbativity(double perturbativity_limit = 4*M_PI);
 
-  /** 
+  /**
   * @brief Checks the stability of the Higgs potential
-  * 
+  *
   * This method checks whether the Higgs potential is stable, i.e. if no
   * directions exist in field space for which \f$ V\to -\infty \f$ for large
   * values of the fields. This is done through a combination of analytical and numerical
   * algorithms, depending on the generality of the specified potential.
-  * 
+  *
   * @returns Boolean \a true if the potential is deemed stable, \a false otherwise
   */
   bool check_stability();
 
-  /** 
+  /**
   * @brief Checks the stability of the Higgs potential
-  * 
+  *
   * This method does the exact same this as check_stability()
-  * 
+  *
 	* @see check_stability
 	*
   * @returns Boolean \a true if the potential is deemed stable, \a false otherwise
@@ -101,28 +101,28 @@
 
   /**
   * @brief Checks the 2HDM against the combined mass constraints from LEP and Tevatron
-  * 
-  * This method checks the charged Higgs mass of the 2HDM against the built in 
-  * implementation routine and also checks the neutral Higgs masses of the 
-  * 2HDM against the existing constraints from LEP run II using the NMSSMTools 
-  * library and/or against the existing constraints from LEP run II and 
+  *
+  * This method checks the charged Higgs mass of the 2HDM against the built in
+  * implementation routine and also checks the neutral Higgs masses of the
+  * 2HDM against the existing constraints from LEP run II using the NMSSMTools
+  * library and/or against the existing constraints from LEP run II and
   * Tevatron using the HiggsBounds library.
-  * To use one of these library requires linking with NMSSMTools and/or 
+  * To use one of these library requires linking with NMSSMTools and/or
   * HiggsBounds, see the full <a href="http://arxiv.org/abs/0902.0851">manual</a> for details
   * on how to do this.
-  * 
+  *
   * @returns  Boolean \a true if the 2HDM is compliant with ALL CHECKED mass limits from
-  *           LEP and Tevatron, \a false otherwise. In case neither NMSSMTools 
-  *           nor HiggsBounds is linked to 2HMDC, the method only checks the 
+  *           LEP and Tevatron, \a false otherwise. In case neither NMSSMTools
+  *           nor HiggsBounds is linked to 2HMDC, the method only checks the
   *           internal charged Higgs limits.
-  *           
+  *
   * @see      check_charged, check_NMSSMTools, check_HiggsBounds
   */
   bool check_masses();
 
   /**
   * @brief Checks the 2HDM against the combined mass constraints from LEP and Tevatron
-  * 
+  *
   * @deprecated   Use check_masses().
   */
   bool check_lep();
@@ -130,13 +130,13 @@
 
   /**
   * @brief Checks the 2HDM against the charged Higgs mass constraints from LEP
-  * 
+  *
   * This method checks the charged Higgs mass of the 2HDM against the existing
   * constraints from DELPHI.
   *
   * The result is given as a series of boolean variables, one for each search
-  * channel, with value \a true if the model is consistent with the DELPHI 
-  * results, and \a false otherwise. The logical AND operation applied to 
+  * channel, with value \a true if the model is consistent with the DELPHI
+  * results, and \a false otherwise. The logical AND operation applied to
   * these variables is returned as output from the method.
   *
   * @param    HpHp     Channel \f$ Z \to H^+ H^- \f$, model independent
@@ -152,18 +152,18 @@
 
   /**
   * @brief Checks the 2HDM against mass constraints from LEP using NMSSMTools
-  * 
+  *
   * This method checks the neutral Higgs masses of the 2HDM against the
-  * existing constraints from LEP run II, channel by channel, using the 
+  * existing constraints from LEP run II, channel by channel, using the
   * NMSSMTools library.
   * To use this library requires linking with NMSSMTools, see the full
   * <a href="http://arxiv.org/abs/0902.0851">manual</a> for details on how to do this.
-  * 
+  *
   * The result is given as a series of boolean variables, one for each search
   * channel, with value \a true if the model is consistent with the LEP results,
-  *  and \a false otherwise. The logical AND operation applied to these variables 
+  *  and \a false otherwise. The logical AND operation applied to these variables
   * is returned as output from the method.
-  * 
+  *
   * @param    hZ  Channel \f$ Z \to Zh \f$, independent of decay mode for h
   *
   * @returns  Boolean \a true if the model is compliant with the constraints
@@ -174,22 +174,22 @@
   bool check_NMSSMTools(bool &hZ, bool &hZ2b, bool &hZ2tau, bool &hZinv, bool &hZ2j,
 		 bool &hZ2gamma, bool &hZ4b, bool &hZ4tau, bool &hZ2b2tau,
 		 bool &hA, bool &hA4b, bool &hA4tau, bool &hA2b2tau,
-		 bool &hA6b, bool &hA6tau, bool &ZhZjj); 
+		 bool &hA6b, bool &hA6tau, bool &ZhZjj);
 
   /**
   * @brief Checks the 2HDM against mass constraints from LEP using HiggsBounds
-  * 
+  *
   * This method checks the neutral Higgs masses of the 2HDM against the
-  * existing constraints from LEP run II and Tevatron using the 
+  * existing constraints from LEP run II and Tevatron using the
   * HiggsBounds library.
   * To use this library requires linking with HiggsBounds, see the full
   * <a href="http://arxiv.org/abs/0902.0851">manual</a> for details on how to do this.
-  * 
-  * 
-  * @param    HBresult   \a 0 if the model is excluded, \a 1 if the model is 
+  *
+  *
+  * @param    HBresult   \a 0 if the model is excluded, \a 1 if the model is
   *                      not excluded, \a -1 invalid model
   * @param    chan       Channel with highest statistical sensitivity, see Key.dat
-  * @param    obsratio   Ratio of the model rate to the observed limit for 
+  * @param    obsratio   Ratio of the model rate to the observed limit for
   *                      this process
   * @param    ncombined  Number of Higgs bosons which contributed to the model
   *                      rate
@@ -204,8 +204,8 @@
 
   /**
   * @brief Calculates the anomalous magnetic moment of the muon
-  * 
-  * This method calculates the anomalous magnetic moment of the muon, 
+  *
+  * This method calculates the anomalous magnetic moment of the muon,
   * \f$ \delta a_\mu=(g-2)_\mu \f$, in the 2HDM. The calculation includes both
   * the one-loop contributions and the (often dominant) two-loop contributions
   * from Barr-Zee type diagrams with a neutral Higgs and a photon.
@@ -213,19 +213,19 @@
   * @returns Value for \f$ \delta a_\mu \f$
   */
   double delta_amu();
-  
+
 
   /**
   * @brief Calculates \f$ \Delta\rho \f$
   *
   * This method calculates the \f$ \Delta\rho \f$ relation in the 2HDM. It is
-  * related through the oblique parameter T through \f$ \Delta\rho = \alpha T 
+  * related through the oblique parameter T through \f$ \Delta\rho = \alpha T
   * \f$, where \f$ \alpha \f$ is the EM coupling.
   *
-  * @param    mh Mass of the %SM Higgs, for which the contribution to the 
+  * @param    mh Mass of the %SM Higgs, for which the contribution to the
   *              oblique parameters is subtracted.
-  * @returns  Value for \f$ \Delta\rho \f$        
-  *           
+  * @returns  Value for \f$ \Delta\rho \f$
+  *
   * @see   oblique_param
   */
   double delta_rho(double mh);
@@ -235,17 +235,17 @@
   * @brief Calculates oblique EW parameters S,T,U,V,W,X
   *
   * This method calculates the oblique EW parameters (S,T,U,V,W,X) in the 2HDM.
-  * The %SM contribution is subtracted. Conventions from <a 
+  * The %SM contribution is subtracted. Conventions from <a
   * href="http://xxx.lanl.gov/abs/0802.4353">arXiv:0802.4353</a>.
   *
   * @param mh Mass of the %SM Higgs, for which the contribution to the oblique
   *           parameters is subtracted.
-  *           
-  * @param S  Result for S parameter (set by the method)          
+  *
+  * @param S  Result for S parameter (set by the method)
   * @param T  Result for T parameter (set by the method)
-  * @param U  Result for U parameter (set by the method)          
+  * @param U  Result for U parameter (set by the method)
   * @param V  Result for V parameter (set by the method)
-  * @param W  Result for W parameter (set by the method)          
+  * @param W  Result for W parameter (set by the method)
   * @param X  Result for X parameter (set by the method)
   */
   void oblique_param(double mh,double &S, double &T, double &U, double &V, double &W, double &X);
@@ -261,11 +261,11 @@
   */
   void print_all(double mh_ref);
 
- private: 
+ private:
   THDM model;
   SM sm;
-  DecayTable table;
-  
+  DecayTableTHDM table;
+
   double dmu_f(double z);
   double dmu_g(double z);
   double dmu_L(double z, int h);
@@ -280,7 +280,7 @@
   double Hhat_fcn(double x, double q);
 
   void init_Hp();
-	void init_externals(); 
+	void init_externals();
 
 
   double *mHp1, *mHp2;
@@ -289,7 +289,7 @@
 
   double delta;
 
-  const static double Z_LIMIT_MCH = 39.6;
+  const static double Z_LIMIT_MCH;
 
 };
 
@@ -298,7 +298,7 @@
 {
   extern void initialize_();
   extern void subexp_(double par[24], double prob[37]);
-    
+
   extern struct {
     double alsmz;
     double alemz;
@@ -329,7 +329,7 @@
     double mneu[5];
     double neu[5][5];
   } susyspec_;
-  
+
   extern struct {
     double smass[3];
     double scomp[3][3];
@@ -391,7 +391,7 @@
     double brsusy[5];
     double width[5];
   } brn_;
-    
+
 }
 
 // Structs used by HiggsBounds Fortran subroutines and common blocks
@@ -403,31 +403,31 @@
   extern void initialize_higgsbounds_(int *nH0, int *nHp, char whichexpt[6]);
 
 	extern void higgsbounds_neutral_input_part_(
-		double Mh[3], 
+		double Mh[3],
 		double MhGammaTot[3],
 		int 	 CP[3],
-		double CS_lep_hjZ_ratio[3], 
+		double CS_lep_hjZ_ratio[3],
 		double CS_lep_bbhj_ratio[3],
 		double CS_lep_tautauhj_ratio[3],
-		double CS_lep_hjhi_ratio[3][3], 
+		double CS_lep_hjhi_ratio[3][3],
 		double CS_tev_gg_hj_ratio[3],
-		double CS_tev_bb_hj_ratio[3], 
-		double CS_tev_bg_hjb_ratio[3], 
+		double CS_tev_bb_hj_ratio[3],
+		double CS_tev_bg_hjb_ratio[3],
 		double CS_tev_ud_hjWp_ratio[3],
-		double CS_tev_cs_hjWp_ratio[3], 
+		double CS_tev_cs_hjWp_ratio[3],
 		double CS_tev_ud_hjWm_ratio[3],
-		double CS_tev_cs_hjWm_ratio[3], 
+		double CS_tev_cs_hjWm_ratio[3],
 		double CS_tev_gg_hjZ_ratio[3],
 		double CS_tev_dd_hjZ_ratio[3],
-		double CS_tev_uu_hjZ_ratio[3], 
+		double CS_tev_uu_hjZ_ratio[3],
 		double CS_tev_ss_hjZ_ratio[3],
-		double CS_tev_cc_hjZ_ratio[3], 
-		double CS_tev_bb_hjZ_ratio[3], 
-		double CS_tev_pp_vbf_ratio[3], 
+		double CS_tev_cc_hjZ_ratio[3],
+		double CS_tev_bb_hjZ_ratio[3],
+		double CS_tev_pp_vbf_ratio[3],
 		double CS_tev_pp_tthj_ratio[3],
-		double CS_lhc7_pp_vbf_ratio[3], 
+		double CS_lhc7_pp_vbf_ratio[3],
 		double CS_lhc7_pp_tthj_ratio[3],
-		double CS_lhc8_pp_vbf_ratio[3], 
+		double CS_lhc8_pp_vbf_ratio[3],
 		double CS_lhc8_pp_tthj_ratio[3],
 		double BR_hjss[3],
 		double BR_hjcc[3],
@@ -451,8 +451,8 @@
 		double BR_Hpjcs[1],
 		double BR_Hpjcb[1],
 		double BR_Hptaunu[1]);
-		 
-	extern void run_higgsbounds_(int *HBresult, int *chan, 
+
+	extern void run_higgsbounds_(int *HBresult, int *chan,
 				    double *obsratio, int *ncombined);
 
 
diff -ruN src/DecayTable.cpp src_patched/DecayTable.cpp
--- src/DecayTable.cpp	2015-08-28 22:39:23.000000000 +0930
+++ src_patched/DecayTable.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,4 +1,4 @@
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include "Util.h"
 #include <iostream>
 #include <gsl/gsl_integration.h>
@@ -25,14 +25,14 @@
 const static double dmtb = 10.;
 
 
-DecayTable::DecayTable(THDM mod) {
+DecayTableTHDM::DecayTableTHDM(THDM mod) {
   set_model(mod);
   qcd_on=true;
-  
+
 
 }
 
-void DecayTable::set_model(THDM mod) {
+void DecayTableTHDM::set_model(THDM mod) {
   model = mod;
   sm = mod.get_SM();
   int i,j,k;
@@ -56,17 +56,17 @@
       }
     }
   }
-  
- 
+
+
 }
 
 
-THDM DecayTable::get_model() {
+THDM DecayTableTHDM::get_model() {
   return model;
 }
 
 
-double DecayTable::get_gamma_uhd(int u, int h, int d) {
+double DecayTableTHDM::get_gamma_uhd(int u, int h, int d) {
 
   if ((u<1)||(u>3)) return 0.;
   if (h!=4) return 0.;
@@ -77,7 +77,7 @@
   double M =  sm.get_umass_pole(u);
   double m1 = model.get_hmass(h);
   double m2 = sm.get_dmass_pole(d);
-  
+
   if (M<(m1+m2)) {
     gamma_uhd[u][h][d]=0.;
     return gamma_uhd[u][h][d];
@@ -88,25 +88,25 @@
   cp = -cp;
 
   gamma_uhd[u][h][d] =  1./(16.*M_PI)*M*pow(1.-m1*m1/(M*M),2)*(pow(abs(cs),2)+pow(abs(cp),2));
-  
+
   if (qcd_on) {
     double mt = sm.get_qmass_pole(6);
     double mb = sm.get_qmass_pole(5);
     double as = sm.run_alphas_MSbar(mt,mt,mb);
 
     double qH = pow(m1/M,2);
-    
+
     double K = 1.+as/M_PI*(7.-8.*pow(M_PI,2)/9.-2.*log(1.-qH)+2.*(1.-qH)+(4./9.+2./3.*log(1.-qH))*pow(1.-qH,2));
-    
+
     gamma_uhd[u][h][d] = gamma_uhd[u][h][d]*K;
   }
-  
+
 
   return gamma_uhd[u][h][d];
 }
 
 
-double DecayTable::get_gamma_hdd(int h, int d1, int d2) {
+double DecayTableTHDM::get_gamma_hdd(int h, int d1, int d2) {
 
   if ((h<1)||(h>3)) return 0.;
   if ((d1<1)||(d1>3)) return 0.;
@@ -117,7 +117,7 @@
   double M = model.get_hmass(h);
   double m1p = sm.get_dmass_pole(d1);
   double m2p = sm.get_dmass_pole(d2);
-  
+
   double m1 = sm.get_dmass_MSbar(d1);
   double m2 = sm.get_dmass_MSbar(d2);
   double m1run = sm.get_dmass_MSbar(d1);
@@ -154,7 +154,7 @@
 }
 
 
-double DecayTable::get_gamma_huu(int h, int u1, int u2) {
+double DecayTableTHDM::get_gamma_huu(int h, int u1, int u2) {
 
   if ((h<1)||(h>3)) return 0.;
   if ((u1<1)||(u1>3)) return 0.;
@@ -170,7 +170,7 @@
   double m2m2 = sm.get_umass_MSbar(u2);
   double m1run = sm.get_umass_MSbar(u1);
   double m2run = sm.get_umass_MSbar(u2);
-  
+
   if (m1m1 > 0) {
       double Qinit = m1m1;
       if(sm.b_HD) Qinit = SM::Q_HD;
@@ -190,30 +190,30 @@
 
   complex <double> cs,cp;
   model.get_coupling_huu(h,u1,u2,cs,cp);
- 
- 
- 
+
+
+
   if ((u1 < 3)||(u2<3)) {
-    if (M>(m1+m2)) { 
+    if (M>(m1+m2)) {
 	    gamma_huu[h][u1][u2] = hff_onshell(M,m1,m1run,m2,m2run,cs,cp,3,h,false);
   	} else {
 		gamma_huu[h][u1][u2] = 0.;
 	}
     return gamma_huu[h][u1][u2];
-  
+
   } else  {
 
       double mt_mt = sm.get_qmass_MSbar(6);
       double mb_mb = sm.get_qmass_MSbar(5);
-      
+
       double mb = sm.get_qmass_pole(5);
       double gtop = sm.get_gamma_top();
-      
+
       double mtr = sm.run_qmass_MSbar(mt_mt,mt_mt,M,mt_mt,mb_mb);
-      double mW = sm.get_MW(); 
+      double mW = sm.get_MW();
 
       int dl = 3;
-      int du = 3; 
+      int du = 3;
 
       if (M < m1+mb+mW+dmtt) {
         gamma_huu[h][u1][u2] = 0.;
@@ -222,28 +222,28 @@
       	gamma_huu[h][u1][u2] = htt;
       } else if (M < m1+m2+du*gtop) {
         double x[4], y[4];
-      
+
         x[0] = m1+m2-(dl+1)*gtop;
         x[1] = m1+m2-dl*gtop;
         x[2] = m1+m2+du*gtop;
         x[3] = m1+m2+(du+1)*gtop;
-      
-        y[0] = htt_offshell(x[0],m1,m2,3,h);    
-        y[1] = htt_offshell(x[1],m1,m2,3,h);    
-        y[2] = htt_onshell(x[2],m1,m2,3,h);    
-        y[3] = htt_onshell(x[3],m1,m2,3,h);    
- 
+
+        y[0] = htt_offshell(x[0],m1,m2,3,h);
+        y[1] = htt_offshell(x[1],m1,m2,3,h);
+        y[2] = htt_onshell(x[2],m1,m2,3,h);
+        y[3] = htt_onshell(x[3],m1,m2,3,h);
+
         double hinter = cubic(M,x,y);
       	gamma_huu[h][u1][u2] = hinter;
-      
-      
+
+
       } else {
         double htt = htt_onshell(M,m1,m2,3,h);
         double hff = hff_onshell(M,mtr,mtr,mtr,mtr,cs,cp,3,h,true);
-      
+
         double R = 2.*m1/M;
         double hinter = interp(R, htt, hff, 0.5);
-  
+
     	gamma_huu[h][u1][u2] = hinter;
       }
   }
@@ -252,7 +252,7 @@
 }
 
 
-double DecayTable::get_gamma_hdu(int h, int d, int u) {
+double DecayTableTHDM::get_gamma_hdu(int h, int d, int u) {
 
   if ((h<4)||(h>4)) return 0.;
   if ((d<1)||(d>3)) return 0.;
@@ -263,14 +263,14 @@
   double M = model.get_hmass(h);
   double m1p = sm.get_dmass_pole(d);
   double m2p = sm.get_umass_pole(u);
-  
+
   double m1 = sm.get_dmass_MSbar(d);
   double m2 = sm.get_umass_MSbar(u);
   double m1run = sm.get_dmass_MSbar(d);
   double m2run = sm.get_umass_MSbar(u);
-  
+
   double mW = sm.get_MW();
-  
+
   if (m1 > 0) {
       double Qinit = m1;
       if (d==2) {
@@ -288,7 +288,7 @@
 
   complex <double> cs,cp;
   model.get_coupling_hdu(h,d,u,cs,cp);
-  
+
   if (h<4) {
 	gamma_hdu[h][d][u] = hff_onshell(M,m1p,m1run,m2p,m2run,cs,cp,3,h,false);
 	return gamma_hdu[h][d][u];
@@ -298,23 +298,23 @@
 	gamma_hdu[h][d][u] = hff_onshell(M,m1p,m1run,m2p,m2run,cs,cp,3,h,false);
 	return gamma_hdu[h][d][u];
   }
- 
+
 	double mb = sm.get_qmass_pole(5);
 	double gtop = sm.get_gamma_top();
 
 	int dl = 0;
-	int du = 1; 
+	int du = 1;
 
 	if (M < m1p+mb+mW+dmtb) {
 		gamma_hdu[h][d][u] = 0.;
 		return gamma_hdu[h][d][u];
 	}
-	
+
 	if (M < m1p+m2p-dl*gtop) {
 		gamma_hdu[h][d][u] = htb_offshell(M,m1p,m1run,m2p,m2run,cs,cp,3);
 		return gamma_hdu[h][d][u];
 	}
-	
+
 	if (M < m1p+m2p+du*gtop) {
 		double x[4], y[4];
 
@@ -323,10 +323,10 @@
 		x[2] = m1p+m2p+du*gtop;
 		x[3] = m1p+m2p+(du+1)*gtop;
 
-		y[0] = htb_offshell(x[0],m1p,m1run,m2p,m2run,cs,cp,3);    
-		y[1] = htb_offshell(x[1],m1p,m1run,m2p,m2run,cs,cp,3);    
-		y[2] = hpff_onshell(x[2],m1p,m1run,m2p,m2run,cs,cp,3,h);    
-		y[3] = hpff_onshell(x[3],m1p,m1run,m2p,m2run,cs,cp,3,h);    
+		y[0] = htb_offshell(x[0],m1p,m1run,m2p,m2run,cs,cp,3);
+		y[1] = htb_offshell(x[1],m1p,m1run,m2p,m2run,cs,cp,3);
+		y[2] = hpff_onshell(x[2],m1p,m1run,m2p,m2run,cs,cp,3,h);
+		y[3] = hpff_onshell(x[3],m1p,m1run,m2p,m2run,cs,cp,3,h);
 
 		double hinter = cubic(M,x,y);
 		gamma_hdu[h][d][u] = hinter;
@@ -339,15 +339,15 @@
 	double hinter = htd1;
 
 	double R = (m1p+m2p)/M;
-	hinter = interp(R, htd1, htd2, 2.);  	
+	hinter = interp(R, htd1, htd2, 2.);
 	gamma_hdu[h][d][u]=hinter;
-	    
+
 	return gamma_hdu[h][d][u];
-	
+
 }
 
 
-double DecayTable::get_gamma_hll(int h, int l1, int l2) {
+double DecayTableTHDM::get_gamma_hll(int h, int l1, int l2) {
 
   if ((h<1)||(h>3)) return 0.;
   if ((l1<1)||(l1>3)) return 0.;
@@ -373,7 +373,7 @@
 }
 
 
-double DecayTable::get_gamma_hln(int h, int l, int n) {
+double DecayTableTHDM::get_gamma_hln(int h, int l, int n) {
 
   if ((h<1)||(h>4)) return 0.;
   if ((l<1)||(l>3)) return 0.;
@@ -393,50 +393,50 @@
   complex <double> cs,cp;
   model.get_coupling_hln(h,l,n,cs,cp);
 
-  
+
   gamma_hln[h][l][n] = hff_onshell(M,m1,m1,m2,m2,cs,cp,1,h,false);
   return gamma_hln[h][l][n];
 }
 
 
-double DecayTable::get_gamma_hgg(int h) {
+double DecayTableTHDM::get_gamma_hgg(int h) {
 
   if (!qcd_on) return 0.;
 
   if ((h<1)||(h>3)) return 0.;
 
   if (gamma_hgg[h]>=0) return gamma_hgg[h];
-  
+
   gamma_hgg[h] = hgg(h);
   return gamma_hgg[h];
 }
 
 
-double DecayTable::get_gamma_hgaga(int h) {
+double DecayTableTHDM::get_gamma_hgaga(int h) {
 
   if (!qcd_on) return 0.;
 
   if ((h<1)||(h>3)) return 0.;
 
   if (gamma_hgaga[h]>=0) return gamma_hgaga[h];
-  
+
   gamma_hgaga[h] = hgaga(h);
   return gamma_hgaga[h];
 }
 
 
-double DecayTable::get_gamma_hZga(int h) {
+double DecayTableTHDM::get_gamma_hZga(int h) {
 
   if ((h<1)||(h>3)) return 0.;
 
   if (gamma_hZga[h]>=0) return gamma_hZga[h];
-  
+
   gamma_hZga[h] = hZga(h);
   return gamma_hZga[h];
 }
 
 
-double DecayTable::get_gamma_hvv(int h, int V) {
+double DecayTableTHDM::get_gamma_hvv(int h, int V) {
 
   if ((h<1)||(h>=4)) return 0.;
   if ((V<1)||(V>3)) return 0.;
@@ -446,24 +446,24 @@
   }
 
   if (gamma_hvv[h][V]>=0) return gamma_hvv[h][V];
-  
+
   double M = model.get_hmass(h);
-  
+
   gamma_hvv[h][V] = hvv_all(h,V,M);
   return gamma_hvv[h][V];
 
 }
 
 
-double DecayTable::get_gamma_hvh(int H, int V, int h) {
+double DecayTableTHDM::get_gamma_hvh(int H, int V, int h) {
 
   if ((H<1)||(H>4)||(h==H)) return 0.;
   if ((V<1)||(V>3)) return 0.;
   if ((h<1)||(h>4)) return 0.;
-  
+
   if ((H==4)&&(V!=3)) return 0;
   if ((H!=4)&&(h==4)&&(V!=3)) return 0;
-  
+
   if (V==1) return 0;
 
   if (gamma_hvh[H][V][h]>=0) return gamma_hvh[H][V][h];
@@ -471,10 +471,10 @@
   double M  = model.get_hmass(H);
   double m1  = model.get_hmass(h);
   double m2 = sm.get_vmass(V);
-  
+
   double GV = sm.get_gamma_V(V);
   gamma_hvh[H][V][h] = 0.;
-  
+
   if (M<=m1) {
     gamma_hvh[H][V][h] = 0.;
     return gamma_hvh[H][V][h];
@@ -483,31 +483,31 @@
   if (M>(m1+m2+5*GV)) {
     gamma_hvh[H][V][h] = hvh_onshell(H,V,h,M);
     return gamma_hvh[H][V][h];
-  } 
-    
+  }
+
   if (M>m1+2*GV) {
     gsl_integration_workspace * w = gsl_integration_workspace_alloc(1000);
-        
+
     double result, error;
-    
+
     integration_params ip;
     ip.M = M;
     ip.m1 = m1;
     ip.m2 = m2;
     ip.gamma = GV;
-  
+
     gsl_function F;
     F.function = &hvh_fcn;
     F.params = &ip;
-      
+
     double k = pow(m1/M,2);
     double imin = 0.;
     double imax = 1.-k;
-  
+
     gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
     int status = gsl_integration_qags (&F,imin,imax,0,1e-5,1000,
-			  w, &result, &error); 
-    if (status) 
+			  w, &result, &error);
+    if (status)
       if (status!=GSL_EROUND) {
         printf("GSL integration warning in H%1d -> VH%1d (off-shell). Please check result.\n", H, h);
         if (EXIT_ON_GSL_ERROR) exit(-1);
@@ -516,10 +516,10 @@
     old_handler = NULL;
     gsl_integration_workspace_free (w);
     w = NULL;
-  
+
     complex <double> c;
     model.get_coupling_vhh(V,H,h,c);
-  
+
     double dV = 0.;
     double stw = sm.get_sintw();
     double ctw = sm.get_costw();
@@ -540,13 +540,13 @@
 
     double KHHV = 3.*GF/(16.*sqrt(2)*pow(M_PI,3))*pow(MW,2)*pow(abs(c),2)*M*dV;
     gamma_hvh[H][V][h] = KHHV*result;
-    
+
     // Count both H+W- and H-W+ final states in partial width to charged states
     // also done in hvh_onshell
     if ((h==4)&&(V==3)) gamma_hvh[H][V][h] = 2*gamma_hvh[H][V][h];
 
     if (M>(m1+m2)) {
-      double G2 = hvh_onshell(H,V,h,M); 
+      double G2 = hvh_onshell(H,V,h,M);
       gamma_hvh[H][V][h] = max(gamma_hvh[H][V][h],G2);
     }
 
@@ -558,7 +558,7 @@
 }
 
 
-double DecayTable::get_gamma_hhh(int h, int h1, int h2) {
+double DecayTableTHDM::get_gamma_hhh(int h, int h1, int h2) {
 
   if ((h<1)||(h>4)) return 0.;
   if ((h1<1)||(h1>4)) return 0.;
@@ -574,7 +574,7 @@
 
   complex <double> c;
   model.get_coupling_hhh(h,h1,h2,c);
-  
+
   gamma_hhh[h][h1][h2] = 0.;
 
   if (M>(m1+m2)) {
@@ -587,12 +587,12 @@
 }
 
 
-double DecayTable::get_gammatot_top() {
+double DecayTableTHDM::get_gammatot_top() {
 
   double gtot = 0.;
-  
+
   gtot += sm.get_gamma_top();
-  
+
   gtot += get_gamma_uhd(3,4,1);
   gtot += get_gamma_uhd(3,4,2);
   gtot += get_gamma_uhd(3,4,3);
@@ -609,14 +609,14 @@
 }
 
 
-double DecayTable::get_gammatot_h(int h) {
+double DecayTableTHDM::get_gammatot_h(int h) {
 
   if (h>4) return 0.;
 
   if (gammatot_h[h]>=0) return gammatot_h[h];
 
   gammatot_h[h] = 0.;
-  
+
   // Fermionic modes
   for (int i=1;i<4;i++) {
     for (int j=1;j<4;j++) {
@@ -627,7 +627,7 @@
        gammatot_h[h]+=get_gamma_hln(h,i,j);
     }
   }
-  
+
   // Vector bosons
   for (int i=1;i<4;i++) {
      gammatot_h[h]+=get_gamma_hvv(h,i);
@@ -657,25 +657,25 @@
 }
 
 
-double  DecayTable::get_gammatot_v(int v) {
+double  DecayTableTHDM::get_gammatot_v(int v) {
   return sm.get_gamma_V(v);
 }
 
 
 
-void DecayTable::print_decay_LesHouches(FILE* output, double br, int id1, int id2) {
-  if (br>0) 
+void DecayTableTHDM::print_decay_LesHouches(FILE* output, double br, int id1, int id2) {
+  if (br>0)
     fprintf(output,"     % 16.8e     %1i     %3i   %3i\n",br,2,id1,id2);
 }
 
 
-void DecayTable::print_decay(const char *h, const char *id1, const char *id2, double g, double br) { 
+void DecayTableTHDM::print_decay(const char *h, const char *id1, const char *id2, double g, double br) {
   if (br>THDM::EPS)
     printf("%2s -> %2s %2s %12.3e   %12.3e\n",h,id1,id2,g,br);
 }
 
 
-void DecayTable::print_top_decays() {
+void DecayTableTHDM::print_top_decays() {
   double gtot = get_gammatot_top();
   double gt[12],br[12];
 
@@ -715,7 +715,7 @@
 }
 
 
-void DecayTable::print_top_decays_LesHouches(FILE* output, bool full) {
+void DecayTableTHDM::print_top_decays_LesHouches(FILE* output, bool full) {
   double gtot = get_gammatot_top();
   double gt[12],br[12];
 
@@ -755,22 +755,22 @@
 }
 
 
-void DecayTable::print_decays(int h) {
+void DecayTableTHDM::print_decays(int h) {
   print_decays(0,h,true,false);
 }
 
 
-void DecayTable::print_width(int h) {
+void DecayTableTHDM::print_width(int h) {
   printf(" Total width for %s: %10.3e GeV\n", hnames[h], get_gammatot_h(h));
 }
 
 
-void DecayTable::print_decays_LesHouches(FILE* output, int h, bool full) {
+void DecayTableTHDM::print_decays_LesHouches(FILE* output, int h, bool full) {
   print_decays(output,h,full,true);
 }
 
 
-double DecayTable::br(double dG, double G) {
+double DecayTableTHDM::br(double dG, double G) {
 
   double BR = 0.;
 
@@ -778,19 +778,19 @@
     BR = dG/G;
     if (BR<THDM::EPS) BR = 0.;
   }
-  
+
   return BR;
 }
 
 
-void DecayTable::print_decays(FILE* output,int h, bool full, bool les) {
+void DecayTableTHDM::print_decays(FILE* output,int h, bool full, bool les) {
 
   if ((h<1)||(h>4)) return;
 
   double gtot = get_gammatot_h(h);
 
   if (les) {
-    if (h==1) 
+    if (h==1)
       fprintf(output,"DECAY  25   % 16.8e   # h1 decays, lightest CP-even Higgs\n",gtot);
     else if (h==2)
       fprintf(output,"DECAY  35   % 16.8e   # h2 decays, heaviest CP-even Higgs\n",gtot);
@@ -826,7 +826,7 @@
   double brhh[5];
   double brhZga = 0.;
   double brhgg = 0.;
-  
+
   // Fermion decay modes
   for (int i=1;i<4;i++) {
     for (int j=1;j<4;j++) {
@@ -871,7 +871,7 @@
       for (int i=1;i<4;i++) {
         if (les)
 	  print_decay_LesHouches(output,brdu[i][j],uPDG[j],-dPDG[i]);
-	else 
+	else
 	  print_decay(hnames[h],unames[j],dnames[i],gdu[i][j],brdu[i][j]);
       }
     }
@@ -879,7 +879,7 @@
       for (int j=1;j<4;j++) {
         if (les)
 	  print_decay_LesHouches(output,brln[i][j],-lPDG[i],nPDG[j]);
-	else 
+	else
 	  print_decay(hnames[h],lnames[i],nnames[j],gln[i][j],brln[i][j]);
       }
     }
@@ -889,7 +889,7 @@
         if ((i==3)&&(h!=4)) sgn = -1;
         if (les)
 	  print_decay_LesHouches(output,brvh[i][j],vPDG[i],sgn*hPDG[j]);
-	else 
+	else
 	  print_decay(hnames[h],vnames[i],hnames[j],gvh[i][j],brvh[i][j]);
       }
     }
@@ -898,11 +898,11 @@
       for (int j=1;j<4;j++) {
 	if (les)
 	  print_decay_LesHouches(output,brdd[i][j],dPDG[i],-dPDG[j]);
-	else 
+	else
 	  print_decay(hnames[h],dnames[i],dnames[j],gdd[i][j],brdd[i][j]);
 	if (les)
 	  print_decay_LesHouches(output,bruu[i][j],uPDG[i],-uPDG[j]);
-	else 
+	else
 	  print_decay(hnames[h],unames[i],unames[j],guu[i][j],bruu[i][j]);
       }
     }
@@ -910,9 +910,9 @@
       for (int j=1;j<4;j++) {
 	if (les)
 	  print_decay_LesHouches(output,brll[i][j],lPDG[i],-lPDG[j]);
-	else 
+	else
 	  print_decay(hnames[h],lnames[i],lnames[j],gll[i][j],brll[i][j]);
-      }    
+      }
     }
     for (int i=1;i<4;i++) {
       int sgn = 1;
@@ -924,12 +924,12 @@
       }
     }
 
-    if (les) 
+    if (les)
       print_decay_LesHouches(output,brhZga,23,22);
     else
       print_decay(hnames[h],"Z ","ga",ghZga,brhZga);
 
-    if (les) 
+    if (les)
       print_decay_LesHouches(output,brhgg,21,21);
     else
       print_decay(hnames[h],"g ","g ",ghgg,brhgg);
@@ -947,7 +947,7 @@
       for (int j=1;j<=3;j++) {
         if (les) {
 	  print_decay_LesHouches(output,brvh[i][j],vPDG[i],hPDG[j]);
-        } else 
+        } else
 	  print_decay(hnames[h],vnames[i],hnames[j],gvh[i][j],brvh[i][j]);
       }
     }
@@ -962,44 +962,44 @@
     }
 
   }
-  
+
   if (!les) printf("---------------------------------------\n");
 }
 
-void DecayTable::set_qcd(bool set) {
+void DecayTableTHDM::set_qcd(bool set) {
   qcd_on=set;
 }
 
-double DecayTable::hvv_offshell(int h, int V,double M) {
+double DecayTableTHDM::hvv_offshell(int h, int V,double M) {
 
   double m = sm.get_vmass(V);
 
   double GV = sm.get_gamma_V(V);
   double G = 0.;
- 
+
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-        
+
   double result, error;
-    
+
   integration_params ip;
   ip.M = M;
   ip.m1 = m;
   ip.m2 = m;
   ip.gamma = GV;
-  
+
   gsl_function F;
   F.function = &hvv_fcn;
   F.params = &ip;
-      
+
   double k = pow(m/M,2);
   double imin = 0.;
   double imax = 1.-k;
-  
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F,imin,imax,0,1e-5,1000,
-			w, &result, &error); 
-    
-  if (status) 
+			w, &result, &error);
+
+  if (status)
     if (status!=GSL_EROUND) {
       printf("GSL integration warning in H%1d -> VV (off-shell). Please check result.\n", h);
       if (EXIT_ON_GSL_ERROR) exit(-1);
@@ -1011,7 +1011,7 @@
 
   complex <double> c;
   model.get_coupling_vvh(V,V,h,c);
-  
+
   double dV = 0.;
   double stw = sm.get_sintw();
   double GF = sm.get_GF();
@@ -1033,34 +1033,34 @@
 
 }
 
-double DecayTable::hvv_all(int h, int V,double M) {
+double DecayTableTHDM::hvv_all(int h, int V,double M) {
 
   double m = sm.get_vmass(V);
 
   double GV = sm.get_gamma_V(V);
   double G = 0.;
- 
+
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-        
+
   double result, error;
-    
+
   integration_params2 ip;
   ip.M = M;
   ip.m = m;
   ip.gamma = GV;
-  
+
   gsl_function F;
   F.function = &hvv_fcn1;
   F.params = &ip;
-      
+
   double imin = 0.;
   double imax = 1.;
-  
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F,imin,imax,0,1e-5,1000,
-			w, &result, &error); 
-    
-  if (status) 
+			w, &result, &error);
+
+  if (status)
     if (status!=GSL_EROUND) {
       printf("GSL integration warning in H%1d -> VV (off-shell). Please check the result.\n", h);
       if (EXIT_ON_GSL_ERROR) exit(-1);
@@ -1072,7 +1072,7 @@
 
   complex <double> c;
   model.get_coupling_vvh(V,V,h,c);
-  
+
   double dV = 0.;
 
   if (V==1) {
@@ -1091,7 +1091,7 @@
 }
 
 
-double DecayTable::hvv_onshell(int h, int V, double M) {
+double DecayTableTHDM::hvv_onshell(int h, int V, double M) {
   double m = sm.get_vmass(V);
   double Sf = 0.;
 
@@ -1102,14 +1102,14 @@
   } else if(V==3) {
     Sf = 1.;
   } else return 0.;
-  
+
   if (M<2.*m) return 0.0;
 
   complex <double> c;
   model.get_coupling_vvh(V,V,h,c);
 
   double M2 = 0.;
-  
+
   if (m>0) {
     double x = pow(M/m,2);
     M2    = 4.*pow(abs(c),2)*(3.-x+x*x/4.);
@@ -1123,7 +1123,7 @@
 }
 
 
-double DecayTable::hvh_onshell(int H, int V, int h, double M) {
+double DecayTableTHDM::hvh_onshell(int H, int V, int h, double M) {
   double m1 = sm.get_vmass(V);
   double m2  = model.get_hmass(h);
 
@@ -1131,16 +1131,16 @@
 
   complex <double> c;
   model.get_coupling_vhh(V,H,h,c);
-  
+
   int dV = 1;
 
   if (V==1) {
     return 0.;
-  } 
+  }
   if ((V==3) && (h==4)) {
     dV = 2;
   }
-  
+
 
   double G = pow(abs(c),2)/(16.*M_PI)*pow(m1,2)/M*sqrt(L(pow(m2,2),pow(m1,2),pow(M,2)))*L(pow(m2,2),pow(M,2),pow(m1,2))*dV;
 
@@ -1148,7 +1148,7 @@
 }
 
 
-double DecayTable::PS2(double M, double m1, double m2) {
+double DecayTableTHDM::PS2(double M, double m1, double m2) {
   double absp1 = sqrt((pow(M,2)-pow(m1+m2,2))*(pow(M,2)-pow(m1-m2,2)))/(2.*M);
   double PS = absp1/pow(M,2);
 
@@ -1157,30 +1157,30 @@
 
 
 
-double DecayTable::hpff_onshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc, int h) {
+double DecayTableTHDM::hpff_onshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc, int h) {
 
   double as = sm.run_alphas_MSbar(M,sm.get_qmass_pole(6),sm.get_qmass_pole(5))/M_PI;
 
   complex <double> cd = cs+cp;
   complex <double> cu = cs-cp;
-  
+
   double cdcu = real(cd*cu);
   double cd2 = pow(abs(cd),2);
   double cu2 = pow(abs(cu),2);
-  
+
   if (m1run > 0) {
   	cd2 = cd2*pow(m1/m1run,2);
   }
-  
+
   if (m2run > 0) {
   	cu2 = cu2*pow(m2/m2run,2);
-  	
+
   }
-  
+
   if ((m1run>0)&&(m2run>0)) {
 	cdcu=cdcu*m1*m2/(m1run*m2run);
   }
-  
+
   double qd = pow(m1/M,2);
   double qu = pow(m2/M,2);
   double Q = 1.-qu-qd;
@@ -1191,19 +1191,19 @@
   double D_udp = 0.;
   double D_dup = 0.;
   double D_udm = 0.;
-  
+
   if ((Nc==3)&&qcd_on) {
 
-     double xd = 2.*qd/(Q+sqL);       
+     double xd = 2.*qd/(Q+sqL);
      double xu = 2.*qu/(Q+sqL);
 
      if(m1 > 0) {
-       D_dup = DHp(qd,qu,xd,xu,sqL);      
+       D_dup = DHp(qd,qu,xd,xu,sqL);
      }
-     
+
      if(m2 > 0) {
-       D_udp = DHp(qu,qd,xu,xd,sqL);           
-     }   
+       D_udp = DHp(qu,qd,xu,xd,sqL);
+     }
 
      if(q > 0) {
         D_udm = DHm(qu,qd,xu,xd,sqL);
@@ -1217,7 +1217,7 @@
 }
 
 
-double DecayTable::hff_onshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc, int h, bool tt=false) {
+double DecayTableTHDM::hff_onshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc, int h, bool tt=false) {
 
   if (M<(m1+m2)) return 0.;
 
@@ -1232,23 +1232,23 @@
   double Qinit = mt;
   if(sm.b_HD) Qinit = SM::Q_HD;
   double mtrun = sm.run_qmass_MSbar(mt,Qinit,M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
+
   // Apply QCD corrections for decay to quarks
   if ((Nc==3)&&qcd_on) {
     if (h<3) {
       int Nf = sm.get_Nactivef(M);
       double as = sm.run_alphas_MSbar(M,sm.get_qmass_pole(6),sm.get_qmass_pole(5))/M_PI;
-      double K = 1.+5.67*as+(35.94-1.36*Nf)*pow(as,2);      
+      double K = 1.+5.67*as+(35.94-1.36*Nf)*pow(as,2);
       if(abs(cs)>0.) K=K+sqrt(m1run*m2run)/mtrun*real(cst*conj(cs))/real(cs*conj(cs))*(1.57-2./3.*log(pow(M,2)/pow(sm.get_qmass_pole(6),2)))*pow(as,2);
       if((abs(cs)>0.)&&(m1run>0.)&&(m2run>0.)&&(!tt)) K=K+sqrt(m1run*m2run)/mtrun*real(cst*conj(cs))/real(cs*conj(cs))*(1./9.*pow(log(m1run*m2run/pow(M,2)),2))*pow(as,2);
       if (K<0) K=0;
-      G = G*K;   
+      G = G*K;
     } else if (h==3) {
       int Nf = sm.get_Nactivef(M);
       double as = sm.run_alphas_MSbar(M,sm.get_qmass_pole(6),sm.get_qmass_pole(5))/M_PI;
-      double K = 1.+5.67*as+(35.94-1.36*Nf)*pow(as,2);      
+      double K = 1.+5.67*as+(35.94-1.36*Nf)*pow(as,2);
       if(abs(cp)>0.) K=K+sqrt(m1run*m2run)/mtrun*real(cpt*conj(cp))/real(cp*conj(cp))*(3.83-log(pow(M,2)/pow(sm.get_qmass_pole(6),2)))*pow(as,2);
-      if((abs(cp)>0.)&&(m1run>0.)&&(m2run>0)&&(!tt)) K=K+sqrt(m1run*m2run)/mtrun*real(cpt*conj(cp))/real(cp*conj(cp))*(1./6.*pow(log(m1run*m2run/pow(M,2)),2))*pow(as,2);     
+      if((abs(cp)>0.)&&(m1run>0.)&&(m2run>0)&&(!tt)) K=K+sqrt(m1run*m2run)/mtrun*real(cpt*conj(cp))/real(cp*conj(cp))*(1./6.*pow(log(m1run*m2run/pow(M,2)),2))*pow(as,2);
       if (K<0) K=0;
       G = G*K;
     } else if (h==4) {
@@ -1263,7 +1263,7 @@
 }
 
 
-double DecayTable::get_gamma_uhu(int u1, int h, int u2) {
+double DecayTableTHDM::get_gamma_uhu(int u1, int h, int u2) {
 
   if (u1!=3) return 0.;
   if ((h<1)||(h>3)) return 0.;
@@ -1274,7 +1274,7 @@
   double M =  sm.get_umass_pole(u1);
   double m1 = model.get_hmass(h);
   double m2 = sm.get_umass_pole(u2);
-  
+
   if (M<(m1+m2)) {
     gamma_uhu[u1][h][u2]=0.;
     return gamma_uhu[u1][h][u2];
@@ -1282,9 +1282,9 @@
 
   complex <double> cs,cp;
   model.get_coupling_huu(h,u1,u2,cs,cp);
- 
+
   double x1 = m1/M;
-  double x2 = m2/M; 	
+  double x2 = m2/M;
 
 
   gamma_uhu[u1][h][u2] = 0;
@@ -1294,14 +1294,14 @@
   } else if (h==3) {
  	gamma_uhu[u1][h][u2] = real(cp*conj(cp))*M/(16*M_PI)*((1-x2)*(1-x2)-x1*x1)*sqrt(1-(x1+x2)*(x1+x2))*sqrt(1-(x1-x2)*(x1-x2));
   }
-  
+
 //  printf("uhu %d %d %d %16.8E %16.8E %16.8E %16.8E %16.8E\n", u1, h, u2, gamma_uhu[u1][h][u2], pow(1-x2,2), pow(1+x2,2),pow(1+x2,2)/(pow(1-x2,2)),x2);
-         
+
   return gamma_uhu[u1][h][u2];
 }
 
 
-double DecayTable::htt_onshell(double M, double m1, double m2,  int Nc, int h) {
+double DecayTableTHDM::htt_onshell(double M, double m1, double m2,  int Nc, int h) {
 
   complex <double> cs, cp;
   complex <double> cs_mtp, cp_mtp;
@@ -1314,18 +1314,18 @@
 
   cs_mtp = cs*mtp/mtr;
   cp_mtp = cp*mtp/mtr;
-  
+
   double M2    = 2.*(pow(M,2)-pow(m1+m2,2))*pow(abs(cs_mtp),2)+
     2.*(pow(M,2)-pow(m1-m2,2))*pow(abs(cp_mtp),2);
 
   double G = Nc*1./(8.*M_PI)*M2*PS2(M,m1,m2);
-  
+
   // Threshold QCD corrections for tt decay, with full mass dependence
   if (Nc==3&&qcd_on) {
     double K = 1;
     if (h!=4) {
       double as = sm.run_alphas_MSbar(M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-      
+
       double mf = m1;
       double b = sqrt(1.-4.*pow(mf/M,2));
       double L = log((1.+b)/(1.-b));
@@ -1334,22 +1334,22 @@
       double dL2 =  gsl_sf_dilog(-x);
 
       double b2 = pow(b, 2);
-      
+
       // Threshold corrections for tt decay [hep-ph/0503172]
       double A = (1.+b2)*(4.*dL1+2.*dL2-3.*L*log(2./(1.+b))-2.*L*log(b))-3.*b*log(4./(1.-b2))-4.*b*log(b);
-            
+
       double DH = 0;
       if (h<3) {
-      	DH = A/b + 1./(16.*pow(b,3))*(3.+34.*pow(b,2)-13.*pow(b,4))*L+3./(8.*pow(b,2))*(7.*pow(b,2)-1);      
+      	DH = A/b + 1./(16.*pow(b,3))*(3.+34.*pow(b,2)-13.*pow(b,4))*L+3./(8.*pow(b,2))*(7.*pow(b,2)-1);
       } else if (h==3) {
       	DH = A/b + 1./(16.*b)*(19.+2*b2+3*pow(b,4))*L+3./8.*(7.-b2);
       }
-      
+
       K = 1.+4./3.*as/M_PI*DH;
     } else if (h==4) {
       K = 1.;
     }
-    
+
     G = G*K;
   }
 
@@ -1357,7 +1357,7 @@
 }
 
 
-double DecayTable::htt_offshell(double M, double m1, double m2, int Nc, int h) {
+double DecayTableTHDM::htt_offshell(double M, double m1, double m2, int Nc, int h) {
 
   complex <double> cs, cp;
   complex <double> cs_mtp, cp_mtp;
@@ -1372,9 +1372,9 @@
   cp_mtp = cp*mtp/mtr;
 
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-        
+
   double result, error;
-    
+
   integration_params_tt ip;
   ip.M = M;
   ip.mt = m1;
@@ -1385,14 +1385,14 @@
   gsl_function F;
   F.function = &htt_fcn1;
   F.params = &ip;
-      
+
   double imin = 2.*m1/M;
   double imax = 2.;
-    
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F,imin,imax,0,1e-3,1000,
-			w, &result, &error); 
-    
+			w, &result, &error);
+
   if (status) {
     if (status!=GSL_EROUND) {
       printf("GSL integration warning in H%1d -> tt (offshell). Please check result.\n", h);
@@ -1412,7 +1412,7 @@
 }
 
 
-double DecayTable::htb_offshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc) {
+double DecayTableTHDM::htb_offshell(double M, double m1, double m1run, double m2, double m2run, complex<double> cs, complex<double> cp, int Nc) {
 
   complex <double> I(0.0,1.0);
 
@@ -1420,31 +1420,31 @@
   double mb  = sm.get_dmass_pole(3);
 
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-		
+
   double result, error;
-  
+
   integration_params_tb ip;
   ip.M = M;
   ip.mt = m2;
   ip.md = md;
   ip.mb = mb;
   ip.mW = sm.get_MW();
-  ip.gtop = sm.get_gamma_top();  
-  
+  ip.gtop = sm.get_gamma_top();
+
   ip.Z_u = real(I*(-cs+cp))*sm.get_v()/(sqrt(2)*m2run);
   ip.Z_d = real(I*( cs+cp))*sm.get_v()/(sqrt(2)*m1run);
-  
+
   gsl_function F;
   F.function = &htb_fcn1;
   F.params = &ip;
-	
+
   double imin = pow((md+mb),2);
   double imax = pow((M - ip.mW),2);
-  
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F,imin,imax,0.,1e-3,1000,
 			w, &result, &error);
-	
+
   if (status) {
     if (status!=GSL_EROUND) {
       printf("GSL integration warning in H+ -> tb (offshell). Please check the result.\n");
@@ -1455,17 +1455,17 @@
   gsl_integration_workspace_free (w);
   old_handler = NULL;
   w = NULL;
-  
+
   double GF = sm.get_GF();
-  
+
   double KHtb = 3*pow(GF,2)/(16*pow(M*M_PI,3));
 
   double G = KHtb*result;
- 
+
   return G;
 }
 
-double DecayTable::hgaga(int h) {
+double DecayTableTHDM::hgaga(int h) {
 
   complex <double> I(0.,1);
 
@@ -1473,9 +1473,9 @@
   double v  		= sm.get_v();
   double v2 		= sm.get_v2();
   double mW 		= sm.get_MW();
-  
+
   double M 		= model.get_hmass(h);
-  double M2 		= M*M;  
+  double M2 		= M*M;
 
   double mHp 		= model.get_hmass(4);
 
@@ -1491,13 +1491,13 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_hdd(h,i,i,gS,gP);
     double m = sm.get_dmass_MSbar(i);
-    double mp = sm.get_dmass_pole(i);    
+    double mp = sm.get_dmass_pole(i);
 
     if (m > 0) {
       double Qinit = m;
       if(sm.b_HD) Qinit = SM::Q_HD;
 
-      double m_HD = sm.run_qmass_MSbar(m,Qinit,M/2.,sm.get_qmass_pole(6),sm.get_qmass_pole(5))*mp/sm.run_qmass_MSbar(m,Qinit,mp,sm.get_qmass_pole(6),sm.get_qmass_pole(5));      
+      double m_HD = sm.run_qmass_MSbar(m,Qinit,M/2.,sm.get_qmass_pole(6),sm.get_qmass_pole(5))*mp/sm.run_qmass_MSbar(m,Qinit,mp,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
       double tau = M2/(4.*m_HD*m_HD);
       double mrun = sm.run_qmass_MSbar(m,Qinit,M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
       complex <double> Sd = 2.*Nc*pow(-1./3,2)*gS*v/mrun*F_sf(tau);
@@ -1506,17 +1506,17 @@
       P_sum = P_sum + Pd;
     }
   }
-  
+
   // Up-type quarks
   for (int i=1;i<=3;i++) {
     model.get_coupling_huu(h,i,i,gS,gP);
     double m = sm.get_umass_MSbar(i);
-    double mp = sm.get_umass_pole(i);    
+    double mp = sm.get_umass_pole(i);
 
     if (m > 0) {
       double Qinit = m;
       if(sm.b_HD) Qinit = SM::Q_HD;
-      double m_HD = sm.run_qmass_MSbar(m,Qinit,M/2.,sm.get_qmass_pole(6),sm.get_qmass_pole(5))*mp/sm.run_qmass_MSbar(m,Qinit,mp,sm.get_qmass_pole(6),sm.get_qmass_pole(5));      
+      double m_HD = sm.run_qmass_MSbar(m,Qinit,M/2.,sm.get_qmass_pole(6),sm.get_qmass_pole(5))*mp/sm.run_qmass_MSbar(m,Qinit,mp,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
       double tau = M2/(4.*m_HD*m_HD);
       double mrun = sm.run_qmass_MSbar(m,Qinit,M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
       complex <double> Sd = 2.*Nc*pow(2./3,2)*gS*v/mrun*F_sf(tau);
@@ -1536,7 +1536,7 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_hll(h,i,i,gS,gP);
     double m = sm.get_lmass_pole(i);
-    
+
     if (m > 0) {
       double tau = M2/(4.*m*m);
       complex <double> Sd = 2.*pow(-1.,2)*gS*v/m*F_sf(tau);
@@ -1552,9 +1552,9 @@
   model.get_coupling_hhh(h,4,4,g_hhchc);
 
   g_hww = g_hww*v/(2.*pow(mW,2));
-  
+
   S_sum = S_sum + g_hww*F_1(tau_W) + g_hhchc/v*v2/(2.*pow(mHp,2))*F_0(tau_Hp);
-    
+
   double G = pow(M,3)*pow(alpha,2)/(256.*pow(M_PI,3)*v2)*(pow(abs(S_sum),2)+pow(abs(P_sum),2));
 
   return G;
@@ -1562,7 +1562,7 @@
 
 
 
-double DecayTable::hZga(int h) {
+double DecayTableTHDM::hZga(int h) {
 
   complex <double> I(0.,1);
 
@@ -1576,9 +1576,9 @@
   double mZ2 		= mZ*mZ;
   double stw            = sm.get_sintw();
   double ctw            = sm.get_costw();
-  
+
   double M 		= model.get_hmass(h);
-  double M2 		= M*M;  
+  double M2 		= M*M;
 
   double mHp 		= model.get_hmass(4);
 
@@ -1599,7 +1599,7 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_hdd(h,i,i,gS,gP);
     double m = sm.get_dmass_MSbar(i);
-    double mp = sm.get_dmass_pole(i);    
+    double mp = sm.get_dmass_pole(i);
 
     if (m > 0) {
       double Qinit = m;
@@ -1620,7 +1620,7 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_huu(h,i,i,gS,gP);
     double m = sm.get_umass_MSbar(i);
-    double mp = sm.get_umass_pole(i);        
+    double mp = sm.get_umass_pole(i);
 
     if (m > 0) {
       double Qinit = m;
@@ -1635,7 +1635,7 @@
 
       // QCD corrections in heavy top quark limit
       if ((!sm.b_HD)&&(qcd_on)&&(i==3)) {
-//        QCD corrections disabled (as in HDECAY)  
+//        QCD corrections disabled (as in HDECAY)
 //        double as = sm.run_alphas_MSbar(M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
 //        Sd=Sd*(1.-as/M_PI);
       }
@@ -1648,7 +1648,7 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_hll(h,i,i,gS,gP);
     double m = sm.get_lmass_pole(i);
-    
+
     if (m > 0) {
       double tau = (4.*m*m)/M2;
       double lambda = (4.*m*m)/mZ2;
@@ -1670,7 +1670,7 @@
 
 //  S_sum = S_sum - g_hww*FW(tau_W,lambda_W) - (2.*ctw*ctw-1.)*g_hhchc/v*v2/(2.*pow(mHp,2))*FHp(tau_Hp,lambda_Hp);
 
-// Charged Higgs contribution above differs with a factor ctw compared to HDECAY. 
+// Charged Higgs contribution above differs with a factor ctw compared to HDECAY.
 // The normalisation below gives same result but is not consistent with formulas 2.23 and 2.33 in Anatomy II
   S_sum = S_sum - g_hww*FW(tau_W,lambda_W) - (2.*ctw-1./ctw)*g_hhchc/v*v2/(2.*pow(mHp,2))*FHp(tau_Hp,lambda_Hp);
 
@@ -1680,13 +1680,13 @@
 }
 
 
-double DecayTable::hgg(int h) {
+double DecayTableTHDM::hgg(int h) {
 
   double v  = sm.get_v();
   double v2 = sm.get_v2();
-  
+
   double M = model.get_hmass(h);
-  double M2 = M*M;  
+  double M2 = M*M;
 
   double mt   = sm.get_qmass_MSbar(6);
 
@@ -1698,7 +1698,7 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_hdd(h,i,i,gS,gP);
     double m = sm.get_dmass_MSbar(i);
-    double mp = sm.get_dmass_pole(i);    
+    double mp = sm.get_dmass_pole(i);
 
     if (m > 0) {
       double Qinit = m;
@@ -1717,12 +1717,12 @@
   for (int i=1;i<=3;i++) {
     model.get_coupling_huu(h,i,i,gS,gP);
     double m = sm.get_umass_MSbar(i);
-    
+
     if (m > 0) {
       double Qinit = m;
       if(sm.b_HD) Qinit = SM::Q_HD;
       double mrun = sm.run_qmass_MSbar(m,Qinit,M,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-      double mp = sm.get_umass_pole(i);    
+      double mp = sm.get_umass_pole(i);
       double tau = M2/(4.*mp*mp);
 
       complex <double> Sd = gS*v/mrun*F_sf(tau);
@@ -1744,14 +1744,14 @@
     KS = 1.+as/M_PI*(95./4.-7./6.*Nf)+pow(as/M_PI,2)*(156.808-5.708*log(mt*mt/M2));
     KP = 1.+as/M_PI*(97./4.-7./6.*Nf)+pow(as/M_PI,2)*(171.544-5.*log(mt*mt/M2));
   }
-  
+
   double G = pow(M,3)*pow(as,2)/(32.*pow(M_PI,3)*v2)*(KS*pow(abs(S_sum),2)+KP*pow(abs(P_sum),2));
 
   return G;
 }
 
 
-complex <double> DecayTable::F_sf(double t) {
+complex <double> DecayTableTHDM::F_sf(double t) {
   double ti = 1./t;
   complex <double> c;
   c = ti*(1.+(1.-ti)*ftau(t));
@@ -1759,7 +1759,7 @@
 }
 
 
-complex <double> DecayTable::F_pf(double t) {
+complex <double> DecayTableTHDM::F_pf(double t) {
   double ti = 1./t;
   complex <double> c;
   c = ti*ftau(t);
@@ -1767,7 +1767,7 @@
 }
 
 
-complex <double> DecayTable::F_0(double t) {
+complex <double> DecayTableTHDM::F_0(double t) {
   double ti = 1./t;
   complex <double> c;
   c = ti*(-1.+ti*ftau(t));
@@ -1776,7 +1776,7 @@
 }
 
 
-complex <double> DecayTable::F_1(double t) {
+complex <double> DecayTableTHDM::F_1(double t) {
   double ti = 1./t;
   complex <double> c;
   c = 2.+3.*ti+3.*ti*(2.-ti)*ftau(t);
@@ -1785,7 +1785,7 @@
 }
 
 
-complex <double> DecayTable::ftau(double t) {
+complex <double> DecayTableTHDM::ftau(double t) {
 
   complex <double> c;
   complex <double> I(0.,1.);
@@ -1804,7 +1804,7 @@
 }
 
 
-complex <double> DecayTable::gtau(double t) {
+complex <double> DecayTableTHDM::gtau(double t) {
 
   complex <double> c;
   complex <double> I(0.,1.);
@@ -1824,32 +1824,32 @@
 
 
 
-complex <double> DecayTable::I_2(double tau, double lambda) {
+complex <double> DecayTableTHDM::I_2(double tau, double lambda) {
   complex <double> c;
   c = -tau*lambda/2./(tau-lambda)*(ftau(1./tau)-ftau(1./lambda));
   return c;
 }
 
-complex <double> DecayTable::I_1(double tau, double lambda) {
+complex <double> DecayTableTHDM::I_1(double tau, double lambda) {
   complex <double> c;
-  c = tau*lambda/2./(tau-lambda) + tau*tau*lambda*lambda/2./(tau-lambda)/(tau-lambda)*(ftau(1./tau)-ftau(1./lambda)) + 
+  c = tau*lambda/2./(tau-lambda) + tau*tau*lambda*lambda/2./(tau-lambda)/(tau-lambda)*(ftau(1./tau)-ftau(1./lambda)) +
                                    tau*tau*lambda/(tau-lambda)/(tau-lambda)*(gtau(1./tau)-gtau(1./lambda));
   return c;
 }
 
-complex <double> DecayTable::FF_s(double tau, double lambda) {
+complex <double> DecayTableTHDM::FF_s(double tau, double lambda) {
   complex <double> c;
   c = I_1(tau,lambda) - I_2(tau,lambda);
   return c;
 }
 
-complex <double> DecayTable::FF_p(double tau, double lambda) {
+complex <double> DecayTableTHDM::FF_p(double tau, double lambda) {
   complex <double> c;
   c = I_2(tau,lambda);
   return c;
 }
 
-complex <double> DecayTable::FW(double tau, double lambda) {
+complex <double> DecayTableTHDM::FW(double tau, double lambda) {
   complex <double> c;
   double ctw            = sm.get_costw();
   double stw            = sm.get_sintw();
@@ -1857,50 +1857,50 @@
   return c;
 }
 
-complex <double> DecayTable::FHp(double tau, double lambda) {
+complex <double> DecayTableTHDM::FHp(double tau, double lambda) {
   complex <double> c;
   c = I_1(tau,lambda);
   return c;
 }
 
 // Interpolation with power c
-double DecayTable::interp(double R, double x, double y, double c) {
+double DecayTableTHDM::interp(double R, double x, double y, double c) {
 
   double ival = pow(R,c)*x + (1.-pow(R,c))*y;
    return ival;
 }
 
-double DecayTable::DHp(double ui, double uj, double xi, double xj, double sqL) {
- 
+double DecayTableTHDM::DHp(double ui, double uj, double xi, double xj, double sqL) {
+
  double eps = 1.E-12;
- 
+
  if (ui < eps) ui = eps;
  if (uj < eps) uj = eps;
  if (xi < eps) xi = eps;
  if (xj < eps) xj = eps;
- 
+
  double D = 9./4. + (3.-2*ui+2.*uj)/4.*log(ui/uj) + ((3./2.-ui-uj)*pow(sqL,2)+5.*ui*uj)/(2.*sqL*(1.-ui-uj))*log(xi*xj)+BHp(ui,uj,xi,xj,sqL);
 
  return D;
- 
-}      
 
-double DecayTable::DHm(double ui, double uj, double xi, double xj, double sqL) {
- 
+}
+
+double DecayTableTHDM::DHm(double ui, double uj, double xi, double xj, double sqL) {
+
  double eps = 1.E-12;
- 
+
  if (ui < eps) ui = eps;
  if (uj < eps) uj = eps;
  if (xi < eps) xi = eps;
  if (xj < eps) xj = eps;
- 
+
  double D = 3. + (uj-ui)/2.*log(ui/uj)+(pow(sqL,2)+2.*(1.-ui-uj))/(2.*sqL)*log(xi*xj)+BHp(ui,uj,xi,xj,sqL);
 
  return D;
- 
-}     
 
-double DecayTable::BHp(double ui, double uj, double xi, double xj, double sqL) {
+}
+
+double DecayTableTHDM::BHp(double ui, double uj, double xi, double xj, double sqL) {
 
 	double B=(1.-ui-uj)/sqL*(4.*gsl_sf_dilog(xi*xj)-2.*gsl_sf_dilog(-xi)-2.*gsl_sf_dilog(-xj)+2.*log(xi*xj)*log(1.-xi*xj)-log(xi)*log(1.+xi)-log(xj)*log(1.+xj));
     B = B-4.*(log(1.-xi*xj)+xi*xj/(1.-xi*xj)*log(xi*xj));
@@ -1908,4 +1908,3 @@
 
 	return B;
 }
-
diff -ruN src/DecayTable.h src_patched/DecayTable.h
--- src/DecayTable.h	2015-08-28 22:13:27.000000000 +0930
+++ src_patched/DecayTable.h	2018-10-15 12:56:13.000000000 +1030
@@ -11,33 +11,33 @@
 
 /**
 * @brief Calculates the decay modes of 2HDM Higgs bosons
-* 
-* Given a THDM object, a DecayTable can be generated. From this table, the
+*
+* Given a THDM object, a DecayTableTHDM can be generated. From this table, the
 * Higgs boson decay widths and branching ratios are obtained. For the complete
 * list of available decay modes, we refer to the complete documentation, or
 * the list of member methods below.
 */
-class DecayTable {
+class DecayTableTHDM {
+
+ public:
 
- public: 
-    
   /**
   * @brief Default constructor
-  * 
-  * This default constructor takes a THDM object as argument for which 
+  *
+  * This default constructor takes a THDM object as argument for which
   * the decays are to be calculated. %SM properties are taken from the SM
   * object in the THDM.
-  * 
+  *
   * @param mod Two-Higgs doublet model for which to calculate decay modes
   */
-  DecayTable(THDM mod);
+  DecayTableTHDM(THDM mod);
 
 
   /**
   * @brief Sets underlying 2HDM
-  * 
-  * This method sets the THDM underlying the DecayTable.
-  * 
+  *
+  * This method sets the THDM underlying the DecayTableTHDM.
+  *
   * @param model Two-Higgs doublet model for which to calculate decay modes
   */
 	void set_model(THDM model);
@@ -45,24 +45,24 @@
 
   /**
   * @brief Underlying 2HDM
-  * 
+  *
   * Use to obtain the underlying THDM object
-  * 
-  * @returns The THDM object on which this DecayTable operates
+  *
+  * @returns The THDM object on which this DecayTableTHDM operates
   */
-	THDM get_model();  
+	THDM get_model();
 
 
   /**
   * @brief Decay width \f$\Gamma(h\to u_1\overline{u}_2) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to a pair of up-type quarks. QCD corrections have been included.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3 = h,H,A)
   * @param u1 Index of up-type quark (1,2,3 = \f$ u,c,t \f$)
   * @param u2 Index of up-type antiquark (1,2,3 = \f$ \bar{u},\bar{c},\bar{t} \f$)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_huu(int h, int u1, int u2);
@@ -70,28 +70,28 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to d_1\overline{d}_2) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to a pair of down-type quarks. QCD corrections have been included.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3 = h,H,A)
   * @param d1 Index of down-type quark (1,2,3 = \f$ d,s,b \f$)
   * @param d2 Index of down-type antiquark (1,2,3 = \f$ \bar{d},\bar{s},\bar{b} \f$)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_hdd(int h, int d1, int d2);
 
   /**
   * @brief Decay width \f$ \Gamma(h\to l_1\overline{l}_2) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to a pair of charged leptons.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3 = h,H,A)
   * @param l1 Index of lepton (1,2,3 = \f$ e,\mu,\tau \f$)
   * @param l2 Index of antilepton (1,2,3 = \f$ \bar{e},\bar{\mu},\bar{\tau} \f$)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_hll(int h, int l1, int l2);
@@ -99,14 +99,14 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to u\overline{d}) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to a pair of quarks. QCD corrections have been included.
-  * 
+  *
   * @param h  Index of Higgs boson (4 = H+)
   * @param d  Index of down-type antiquark (1,2,3 = \f$ \bar{d},\bar{s},\bar{b} \f$)
   * @param u  Index of up-type quark (1,2,3 = \f$ u,c,t \f$)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_hdu(int h, int d, int u);
@@ -114,29 +114,29 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to l\overline{\nu}_{l'}) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to lepton-neutrino.
-  * 
+  *
   * @param h  Index of Higgs boson (4 = H+)
   * @param l  Index of charged lepton (1,2,3 = \f$ e^+,\mu^+,\tau^+ \f$)
   * @param n  Index of neutrino (1,2,3 = \f$ \nu_e,\nu_\mu,\nu_\tau \f$)
-  * 
+  *
   * @returns The decay width in GeV
   */
-  double  get_gamma_hln(int h, int l, int n);  
-  
+  double  get_gamma_hln(int h, int l, int n);
+
 
   /**
   * @brief Decay width \f$ \Gamma(h\to H_1 H_2) \f$
-  * 
+  *
   * This method calculates the on-shell decay width for the decay of Higgs
   * boson \a h to a pair of Higgs bosons
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h1 Index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h2 Index of second Higgs boson (1,2,3,4 = h,H,A,H+)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_hhh(int h, int h1, int h2);
@@ -144,25 +144,25 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to VV) \f$
-  * 
-  * This method calculates the decay width for the Higgs boson \a h 
+  *
+  * This method calculates the decay width for the Higgs boson \a h
   * to a pair of vector bosons. The decay mode with one vector
   * boson off-shell is included.
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param v  Index of vector bosons (1,2,3 = \f$\gamma \f$,Z,W)
-  * 
+  *
   * @returns The decay width in GeV
   */
   double  get_gamma_hvv(int h, int v);
 
   /**
   * @brief Decay width \f$ \Gamma(h\to VH) \f$
-  * 
-  * This method calculates the decay width for the Higgs boson \a h 
+  *
+  * This method calculates the decay width for the Higgs boson \a h
   * to one massive vector and one Higgs boson. Decay with the vector
   * boson off-shell is included.
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param V  Index of vector boson (2,3 = \f$\gamma \f$,Z,W)
   * @param H  Index of final-state Higgs boson (1,2,3,4 = h,H,A,H+)
@@ -173,10 +173,10 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to gg) \f$
-  * 
-  * This method calculates the decay width for the Higgs boson \a h 
+  *
+  * This method calculates the decay width for the Higgs boson \a h
   * to a pair of gluons. LO QCD corrections are included.
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3,4 = h,H,A,H+)
 	*
   * @returns The decay width in GeV
@@ -186,10 +186,10 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to \gamma\gamma) \f$
-  * 
+  *
   * This method calculates the decay width for the neutral
   * Higgs boson \a h to a pair of photons.
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3 = h,H,A)
 	*
   * @returns The decay width in GeV
@@ -198,10 +198,10 @@
 
   /**
   * @brief Decay width \f$ \Gamma(h\to Z\gamma) \f$
-  * 
+  *
   * This method calculates the decay width for the neutral
   * Higgs boson \a h to a Z and a photon.
-  * 
+  *
   * @param h  Index of decaying Higgs boson (1,2,3 = h,H,A)
 	*
   * @returns The decay width in GeV
@@ -210,9 +210,9 @@
 
   /**
   * @brief Total width \f$ \Gamma_h \f$
-  * 
-  * Calculates the total decay width of Higgs boson \a h 
-  * 
+  *
+  * Calculates the total decay width of Higgs boson \a h
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
 	*
   * @returns Total width in GeV
@@ -221,9 +221,9 @@
 
   /**
   * @brief Total width \f$ \Gamma_V \f$
-  * 
-  * Returns the total decay width of vector boson \a v 
-  * 
+  *
+  * Returns the total decay width of vector boson \a v
+  *
   * @param v  Index of vector boson (2,3 = Z,W)
 	*
   * @returns Total width in GeV
@@ -232,9 +232,9 @@
 
   /**
   * @brief Total width \f$ \Gamma_t \f$
-  * 
-  * Returns the total decay width of the top quark 
-  * 
+  *
+  * Returns the total decay width of the top quark
+  *
   * @returns Total width in GeV
   */
   double  get_gammatot_top();
@@ -242,11 +242,11 @@
 
   /**
   * @brief Decay width for \f$ t \to H^+X \f$
-  * 
+  *
   * Returns the decay width of the top quark in the charged Higgs mode
-  * 
+  *
   * @returns Decay width in GeV
-  * 
+  *
   * @param u Index of decaying quark (1,2,3 = \f$ u,c,t \f$)
   * @param h Index of Higgs boson (4 = H+)
 	* @param d Index of down-type quark (1,2,3 = \f$ d,s,b \f$)
@@ -256,12 +256,12 @@
 
   double  get_gamma_uhu(int u1, int h, int u2);
 
-  
+
   /**
   *	@brief Prints the decay modes of a Higgs boson
   *
   * The decay modes of Higgs boson \a h are printed to stdout
-  * 
+  *
   * @param h Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   */
   void    print_decays(int h);
@@ -270,7 +270,7 @@
   *	@brief Prints the total width of a Higgs boson
   *
   * The total decay width of Higgs boson \a h are printed to stdout
-  * 
+  *
   * @param h Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   */
   void    print_width(int h);
@@ -308,24 +308,24 @@
   /**
   *     @brief Turns QCD corrections on or off
   *
-  * This method is used to turn QCD corrections on or off. If the output is 
-  * meant to be used with the MadGraph/MadEvent 2HDMC model 
-  * QCD corrections should be turned off to get a consistent result. 
+  * This method is used to turn QCD corrections on or off. If the output is
+  * meant to be used with the MadGraph/MadEvent 2HDMC model
+  * QCD corrections should be turned off to get a consistent result.
   *
-  * @param set  If \a true QCD corrections are turned on, 
+  * @param set  If \a true QCD corrections are turned on,
   *             if \a false QCD corrections are turned off
   */
   void    set_qcd(bool set);
 
-  static double  DHp(double ui, double uj, double xi, double xj, double sqL);
-  static double  DHm(double ui, double uj, double xi, double xj, double sqL);
-  static double  BHp(double ui, double uj, double xi, double xj, double sqL);
+  double  DHp(double ui, double uj, double xi, double xj, double sqL);
+  double  DHm(double ui, double uj, double xi, double xj, double sqL);
+  double  BHp(double ui, double uj, double xi, double xj, double sqL);
 
 
  private:
   THDM model;
   SM sm;
-  
+
   complex <double> F_sf(double t);
   complex <double> F_pf(double t);
   complex <double> F_0(double t);
@@ -372,7 +372,7 @@
   double  hZga(int h);
   double  hgg(int h);
   double  PS2(double M, double m1, double m2);
-  
+
   double  interp(double R, double x, double y, double c);
 
   bool    qcd_on;
diff -ruN src/Demo.cpp src_patched/Demo.cpp
--- src/Demo.cpp	2015-08-28 22:17:09.000000000 +0930
+++ src_patched/Demo.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,14 +1,14 @@
 /*******************************************************************************
  2HDMC - two-Higgs-doublet model calculator
  Demo program
- 
+
  http://2hdmc.hepforge.org
 *******************************************************************************/
 #include "THDM.h"
 #include "SM.h"
 #include "HBHS.h"
 #include "Constraints.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include <iostream>
 
 using namespace std;
@@ -20,10 +20,10 @@
 
   // Create SM and set parameters
   SM sm;
-  sm.set_qmass_pole(6, 172.5);		
-  sm.set_qmass_pole(5, 4.75);		
-  sm.set_qmass_pole(4, 1.42);	
-  sm.set_lmass_pole(3, 1.77684);	
+  sm.set_qmass_pole(6, 172.5);
+  sm.set_qmass_pole(5, 4.75);
+  sm.set_qmass_pole(4, 1.42);
+  sm.set_lmass_pole(3, 1.77684);
   sm.set_alpha(1./127.934);
   sm.set_alpha0(1./137.0359997);
   sm.set_alpha_s(0.119);
@@ -45,11 +45,11 @@
   double sba      = 0.999;
   double lambda_6 = 0.;
   double lambda_7 = 0.;
-  double m12_2    = 15800.; 
+  double m12_2    = 15800.;
   double tb       = 10.;
-  
+
   bool pset = model.set_param_phys(mh,mH,mA,mC,sba,lambda_6,lambda_7,m12_2,tb);
-  
+
   if (!pset) {
     cerr << "The specified parameters are not valid\n";
     return -1;
@@ -62,7 +62,7 @@
 
   // Set Yukawa couplings to type II
   model.set_yukawas_type(2);
-  
+
   // Print the parameters in different parametrizations
   model.print_param_phys();
   model.print_param_gen();
@@ -72,24 +72,24 @@
   // Prepare to calculate observables
   Constraints constr(model);
 
-  double S,T,U,V,W,X;   
+  double S,T,U,V,W,X;
 
   constr.oblique_param(mh_ref,S,T,U,V,W,X);
-  
+
   printf("\nConstraints:\n");
-  printf("  Potential stability: %s\n", 
+  printf("  Potential stability: %s\n",
 	 (constr.check_stability() ? "OK" : "Not OK"));
-  printf(" Tree-level unitarity: %s\n", 
+  printf(" Tree-level unitarity: %s\n",
 	 (constr.check_unitarity() ? "OK" : "Not OK"));
-  printf("       Perturbativity: %s\n", 
+  printf("       Perturbativity: %s\n",
 	 (constr.check_perturbativity() ? "OK" : "Not OK"));
 
   printf("\n");
-  printf(" Oblique S: %12.5e\n", S);  
+  printf(" Oblique S: %12.5e\n", S);
   printf(" Oblique T: %12.5e\n", T);
-  printf(" Oblique U: %12.5e\n", U);  
+  printf(" Oblique U: %12.5e\n", U);
   printf(" Oblique V: %12.5e\n", V);
-  printf(" Oblique W: %12.5e\n", W);  
+  printf(" Oblique W: %12.5e\n", W);
   printf(" Oblique X: %12.5e\n", X);
   printf(" Delta_rho: %12.5e\n", constr.delta_rho(mh_ref));
   printf("\n");
@@ -105,14 +105,14 @@
 
 // Share couplings of 2HDM model with HiggsBounds/HiggsSignals
   HB_set_input_effC(model);
-  
-  // Arrays hold the HiggsBounds results 
+
+  // Arrays hold the HiggsBounds results
   int hbres[6];
   double hbobs[6];
   int hbchan[6];
-  int hbcomb[6];  
+  int hbcomb[6];
 
-// Run HiggsBounds 'full', i.e. with each Higgs result separately  
+// Run HiggsBounds 'full', i.e. with each Higgs result separately
   HB_run_full(hbres, hbchan, hbobs, hbcomb);
   printf("\nHiggsBounds results (full):\n");
   printf("  Higgs  res  chan       ratio        ncomb\n");
@@ -121,16 +121,16 @@
   }
   printf("------------------------------------------------------------\n");
   printf("  TOT %5d %6d %16.8E %5d   %s\n", hbres[0],hbchan[0],hbobs[0],hbcomb[0],hbobs[0]<1 ? "ALLOWED" : "EXCLUDED");
-  
+
   double csqmu;
   double csqmh;
   double csqtot;
   int nobs;
   double pval;
-  
+
   double dMh[3]={0., 0., 0.,};
   HS_set_mass_uncertainties(dMh);
- 
+
   HS_run(&csqmu, &csqmh, &csqtot, &nobs, &pval);
 
   printf("\nHiggsSignals results:\n");
@@ -139,16 +139,16 @@
   printf("      Total chi^2: %16.8E\n", csqtot);
   printf("    # observables: %16d\n\n", nobs);
 
-#endif  
+#endif
 
   // Prepare to calculate decay widths
-  DecayTable table(model);
+  DecayTableTHDM table(model);
 
   // Print total widths of Higgs bosons
   table.print_width(1);
   table.print_width(2);
   table.print_width(3);
-  table.print_width(4);	
+  table.print_width(4);
 
   table.print_decays(1);
   table.print_decays(2);
@@ -163,4 +163,3 @@
   HS_finish();
 #endif
 }
-
diff -ruN src/HBHS.cpp src_patched/HBHS.cpp
--- src/HBHS.cpp	2015-08-26 22:47:27.000000000 +0930
+++ src_patched/HBHS.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -1,6 +1,6 @@
 #include "HBHS.h"
 #include "THDM.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include <iostream>
 
 static bool HB_initialized = false;
@@ -12,12 +12,12 @@
 void HB_init() {
   int nH0=3;
   int nHp=1;
-  int hbflag=3;	
-  
+  int hbflag=3;
+
   if (HB_initialized) return;
-  
+
   printf("\nInitializing HiggsBounds... ");
-   
+
    // Third argument is HB analysis setting: 1='onlyL', 2='onlyH' 3='LandH'
     initialize_higgsbounds_int_(&nH0, &nHp, &hbflag);
 //  initialize_higgsbounds_(&nH0,&nHp,whichexpt);
@@ -46,29 +46,29 @@
     bool debug =false;
 
     double Mh[3];
-    double GammaTotal[3]; 
+    double GammaTotal[3];
     double g2hjss_s[3];
     double g2hjss_p[3];
     double g2hjcc_s[3];
     double g2hjcc_p[3];
     double g2hjbb_s[3];
-    double g2hjbb_p[3]; 
+    double g2hjbb_p[3];
     double g2hjtt_s[3];
     double g2hjtt_p[3];
     double g2hjmumu_s[3];
     double g2hjmumu_p[3];
     double g2hjtautau_s[3];
-    double g2hjtautau_p[3]; 
+    double g2hjtautau_p[3];
     double g2hjWW[3];
     double g2hjZZ[3];
     double g2hjZga[3];
     double g2hjgaga[3];
     double g2hjgg[3];
-    double g2hjggZ[3]; 
-    double g2hjhiZ[3][3]; 
+    double g2hjggZ[3];
+    double g2hjhiZ[3][3];
     double BR_hjinvisible[3];
     double BR_hjhihi[3][3];
-    
+
     double MHp[1];
 	double MHplusGammaTot[1];
 	double CS_lep_HpjHmi_ratio[1];
@@ -77,34 +77,34 @@
 	double BR_Hpjcs[1];
 	double BR_Hpjcb[1];
 	double BR_Hptaunu[1];
-    
+
     double sba, tanb, lam6, lam7, m122;
-    model.get_param_phys(Mh[0], Mh[1], Mh[2], MHp[0], sba, lam6, lam7, m122, tanb); 
-    
+    model.get_param_phys(Mh[0], Mh[1], Mh[2], MHp[0], sba, lam6, lam7, m122, tanb);
+
 #if defined debug
     printf("Masses for HB/HS: %16.8E %16.8E %16.8E\n", Mh[0], Mh[1], Mh[2]);
 #endif
 
     THDM sm_like;
-    DecayTable table(model), sm_table(sm_like);
- 
+    DecayTableTHDM table(model), sm_table(sm_like);
+
     SM sm = model.get_SM();
 
   	double g=sm.get_g();
   	double costw=sm.get_costw();
   	double mt = sm.get_umass_pole(3);
- 
+
     complex <double> c,cs,cp,c_sm,cs_sm,cp_sm;
-    
+
     for (int h=1;h<=3;h++) {
       double mh = Mh[h-1];
 //      sm_like.set_param_phys(Mh[h-1], Mh[h-1]*10., Mh[h-1]*10., Mh[h-1]*10., 1.0, 0., 0., 0., 1.0);
       sm_like.set_param_sm(Mh[h-1]);
       sm_like.set_yukawas_type(1);
-      
+
       table.set_model(model);
       sm_table.set_model(sm_like);
-    
+
       model.get_coupling_hdd(h,2,2,cs,cp);
 	  sm_like.get_coupling_hdd(1,2,2,cs_sm,cp_sm);
       g2hjss_s[h-1] = pow(abs(cs/cs_sm),2);
@@ -150,7 +150,7 @@
       sm_like.get_coupling_vvh(3, 3, 1, c_sm);
       g2hjWW[h-1] = pow(abs(c/c_sm),2);
       if (debug) printf("%2d %5s %16.8E\n", h, "WW", g2hjWW[h-1]);
-    
+
       double hgaga = table.get_gamma_hgaga(h);
       double hgaga_sm = sm_table.get_gamma_hgaga(1);
       g2hjgaga[h-1] = hgaga/hgaga_sm;
@@ -160,14 +160,14 @@
       double hZga_sm = sm_table.get_gamma_hZga(1);
       g2hjZga[h-1] = hZga/hZga_sm;
       if (debug) printf("%2d %5s %16.8E\n", h, "Zga", g2hjZga[h-1]);
-    
+
       double hgg = table.get_gamma_hgg(h);
       double hgg_sm = sm_table.get_gamma_hgg(1);
       g2hjgg[h-1] = hgg/hgg_sm;
       g2hjggZ[h-1] = 0.;
-      if (debug) printf("%2d %5s %16.8E\n", h, "gg", g2hjgg[h-1]);    
+      if (debug) printf("%2d %5s %16.8E\n", h, "gg", g2hjgg[h-1]);
 
-      if ((h<=2)&&(mh>=90.)) {    
+      if ((h<=2)&&(mh>=90.)) {
 		  GammaTotal[h-1] =  smgamma_h_(&mh);
 		  GammaTotal[h-1] += smgamma_h_(&mh)*(g2hjWW[h-1] - 1.)*smbr_hww_(&mh);
 		  GammaTotal[h-1] += smgamma_h_(&mh)*(g2hjZZ[h-1] - 1.)*smbr_hzz_(&mh);
@@ -180,7 +180,7 @@
 		  GammaTotal[h-1] += smgamma_h_(&mh)*(g2hjcc_s[h-1] + g2hjcc_p[h-1] - 1.)*smbr_hcc_(&mh);
 		  GammaTotal[h-1] += smgamma_h_(&mh)*(g2hjZga[h-1]-1)*smbr_hzgam_(&mh);
 		  GammaTotal[h-1] += smgamma_h_(&mh)*(g2hjgaga[h-1]-1)*smbr_hgamgam_(&mh);
-	  
+
 		  for (int i=1; i<=4; i++) {
 			  GammaTotal[h-1] += table.get_gamma_hhh(h,i,i);
 		  }
@@ -190,26 +190,26 @@
 			  GammaTotal[h-1] += table.get_gamma_hvh(h,j,i);
 			}
 		  }
-	  
+
 	  } else {
-	  
+
 	    GammaTotal[h-1] = table.get_gammatot_h(h);
 	  }
 
-      
+
       if (debug) printf("gtot %16.8E %16.8E %16.8E %16.8E\n",  GammaTotal[h-1], table.get_gammatot_h(h), HB_get_gammah(Mh[h-1]), sm_table.get_gammatot_h(1));
 
 
     }
-    
-    
-    
+
+
+
 
 //      GammaTotal[h-1] = GammaTotal[h-1]*HB_get_gammah(Mh[h-1])/sm_table.get_gammatot_h(1);
 //      	printf("gtot %16.8E %16.8E %16.8E\n",  GammaTotal[h-1], sm_table.get_gammatot_h(1), HB_get_gammah(Mh[h-1]));
-  	 
-  	 
-  	 for (int j=1;j<=3;j++) {  	 
+
+
+  	 for (int j=1;j<=3;j++) {
       for (int i=1;i<=3;i++) {
        BR_hjhihi[i-1][j-1]=table.get_gamma_hhh(j,i,i)/GammaTotal[j-1];
        model.get_coupling_vhh(2,j,i,c);
@@ -222,15 +222,15 @@
     higgsbounds_neutral_input_effc_(Mh,GammaTotal,
     g2hjss_s, g2hjss_p,
     g2hjcc_s, g2hjcc_p,
-    g2hjbb_s, g2hjbb_p, 
+    g2hjbb_s, g2hjbb_p,
     g2hjtt_s, g2hjtt_p,
     g2hjmumu_s,g2hjmumu_p,
-    g2hjtautau_s, g2hjtautau_p, 
+    g2hjtautau_s, g2hjtautau_p,
     g2hjWW, g2hjZZ, g2hjZga, g2hjgaga,
-    g2hjgg, g2hjggZ,g2hjhiZ, 
+    g2hjgg, g2hjggZ,g2hjhiZ,
     BR_hjinvisible,
     BR_hjhihi);
-    
+
     CS_lep_HpjHmi_ratio[0] = 1.;
 	BR_tWpb[0] = sm.get_gamma_top()/table.get_gammatot_top();
 	BR_tHpjb[0]=table.get_gamma_uhd(3,4,3)/table.get_gammatot_top();
@@ -252,7 +252,7 @@
 
 
 double HB_get_gammah(double m) {
- 
+
    return smgamma_h_(&m);
 }
 
@@ -272,11 +272,11 @@
 
  int nH0 = 3;
  int nHp = 1;
- 
+
  printf("\nInitializing HiggsSignals... ");
 
  initialize_higgssignals_latestresults_(&nH0,&nHp);
- HS_initialized = true;  
+ HS_initialized = true;
 }
 
 void HS_finish() {
@@ -338,4 +338,3 @@
 }
 
 #endif
-
diff -ruN src/HBHS.h src_patched/HBHS.h
--- src/HBHS.h	2015-08-26 22:43:01.000000000 +0930
+++ src_patched/HBHS.h	2018-10-15 12:56:13.000000000 +1030
@@ -3,7 +3,7 @@
 
 #include "SM.h"
 #include "THDM.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 
 using namespace std;
 
@@ -44,58 +44,58 @@
 {
 
 	extern void initialize_higgsbounds_int_(int *nH0, int *nHp, int *flag);
-    
+
     extern void higgsbounds_neutral_input_effc_(
     double Mh[3],
-    double GammaTotal[3], 
+    double GammaTotal[3],
     double g2hjss_s[3],
     double g2hjss_p[3],
     double g2hjcc_s[3],
     double g2hjcc_p[3],
     double g2hjbb_s[3],
-    double g2hjbb_p[3], 
+    double g2hjbb_p[3],
     double g2hjtt_s[3],
     double g2hjtt_p[3],
     double g2hjmumu_s[3],
     double g2hjmumu_p[3],
     double g2hjtautau_s[3],
-    double g2hjtautau_p[3], 
+    double g2hjtautau_p[3],
     double g2hjWW[3],
     double g2hjZZ[3],
     double g2hjZga[3],
     double g2hjgaga[3],
     double g2hjgg[3],
-    double g2hjggZ[3], 
-    double g2hjhiZ[3][3], 
+    double g2hjggZ[3],
+    double g2hjhiZ[3][3],
     double BR_hjinvisible[3],
     double BR_hjhihi[3][3]);
-    
+
    extern void higgsbounds_neutral_input_part_(
-		double Mh[3], 
+		double Mh[3],
 		double MhGammaTot[3],
 		int 	 CP[3],
-		double CS_lep_hjZ_ratio[3], 
+		double CS_lep_hjZ_ratio[3],
 		double CS_lep_bbhj_ratio[3],
 		double CS_lep_tautauhj_ratio[3],
-		double CS_lep_hjhi_ratio[3][3], 
+		double CS_lep_hjhi_ratio[3][3],
 		double CS_tev_gg_hj_ratio[3],
-		double CS_tev_bb_hj_ratio[3], 
-		double CS_tev_bg_hjb_ratio[3], 
+		double CS_tev_bb_hj_ratio[3],
+		double CS_tev_bg_hjb_ratio[3],
 		double CS_tev_ud_hjWp_ratio[3],
-		double CS_tev_cs_hjWp_ratio[3], 
+		double CS_tev_cs_hjWp_ratio[3],
 		double CS_tev_ud_hjWm_ratio[3],
-		double CS_tev_cs_hjWm_ratio[3], 
+		double CS_tev_cs_hjWm_ratio[3],
 		double CS_tev_gg_hjZ_ratio[3],
 		double CS_tev_dd_hjZ_ratio[3],
-		double CS_tev_uu_hjZ_ratio[3], 
+		double CS_tev_uu_hjZ_ratio[3],
 		double CS_tev_ss_hjZ_ratio[3],
-		double CS_tev_cc_hjZ_ratio[3], 
-		double CS_tev_bb_hjZ_ratio[3], 
-		double CS_tev_pp_vbf_ratio[3], 
+		double CS_tev_cc_hjZ_ratio[3],
+		double CS_tev_bb_hjZ_ratio[3],
+		double CS_tev_pp_vbf_ratio[3],
 		double CS_tev_pp_tthj_ratio[3],
-		double CS_lhc7_pp_vbf_ratio[3], 
+		double CS_lhc7_pp_vbf_ratio[3],
 		double CS_lhc7_pp_tthj_ratio[3],
-		double CS_lhc8_pp_vbf_ratio[3], 
+		double CS_lhc8_pp_vbf_ratio[3],
 		double CS_lhc8_pp_tthj_ratio[3],
 		double BR_hjss[3],
 		double BR_hjcc[3],
@@ -119,11 +119,11 @@
 		double BR_Hpjcs[1],
 		double BR_Hpjcb[1],
 		double BR_Hptaunu[1]);
-		 
-	extern void run_higgsbounds_(int *HBresult, int *chan, 
+
+	extern void run_higgsbounds_(int *HBresult, int *chan,
 				    double *obsratio, int *ncombined);
 
-	extern void run_higgsbounds_full_(int HBresult[6], int chan[6], 
+	extern void run_higgsbounds_full_(int HBresult[6], int chan[6],
 				    double obsratio[6], int ncombined[6]);
 
 	extern double smgamma_h_(double *Mh);
@@ -139,28 +139,28 @@
 	extern double smbr_hzgam_(double *Mh);
 	extern double smbr_hgamgam_(double *Mh);
 
-	extern void finish_higgsbounds_();        
+	extern void finish_higgsbounds_();
 
-    extern void initialize_higgssignals_latestresults_(int *nHzero, int *nHplus);	
+    extern void initialize_higgssignals_latestresults_(int *nHzero, int *nHplus);
 
     extern void setup_pdf_(int *pdf);
-    
+
     extern void setup_output_level_(int *level);
-    
+
     extern void setup_nparam_(int *npara);
 
     extern void higgssignals_neutral_input_massuncertainty_(double dMh[3]);
     extern void setup_rate_uncertainties_(double dCS[5], double dBR[5]);
-     
+
     extern void setup_assignmentrange_(double *range);
 	extern void setup_assignmentrange_massobservables_(double *range);
-	
+
     extern void run_higgssignals_(int *mode, double *csqmu, double *csqmh, double *csqtot, int *nobs, double *pval);
-	
-	extern void finish_higgssignals_();        
+
+	extern void finish_higgssignals_();
 
     extern void get_rvalues_(int *i, int *collider, double *R_H_WW, double *R_H_ZZ, double *R_H_gaga, double *R_H_tautau, double *R_H_bb, double *R_VH_bb);
-	
+
 }
 
 #endif
diff -ruN src/SM.cpp src_patched/SM.cpp
--- src/SM.cpp	2015-08-28 01:23:39.000000000 +0930
+++ src_patched/SM.cpp	2018-10-31 18:38:58.000000000 +1030
@@ -1,7 +1,7 @@
 /*******************************************************************************
  2HDMC - two-Higgs-doublet model calculator
  SM class
- 
+
  http://2hdmc.hepforge.org
 *******************************************************************************/
 
@@ -12,15 +12,49 @@
 using namespace std;
 
 
+  const double SM::alpha   = 1./127.934;
+  const double SM::alpha0  = 1./137.0359997;
+  const double SM::alpha_s = 0.119;
+  const double SM::GF      = 1.16637E-5;
+  const double SM::MZ      = 91.15349;
+  const double SM::MW      = 80.36951;
+  const double SM::GammaZ  = 2.49581;
+  const double SM::GammaW  = 2.08856;
+  const double SM::md_p    = 0.0;
+  const double SM::mu_p    = 0.0;
+  const double SM::ms_p    = 0.1;
+  const double SM::Q_ms    = 2.0;
+  const double SM::mc_p    = 1.42;
+  const double SM::mb_p    = 4.75;
+  const double SM::mt_p    = 172.5;
+  const double SM::me_p    = 0.510998918E-3;
+  const double SM::mmu_p   = 0.105658367;
+  const double SM::mtau_p  = 1.77684;
+  const double SM::Vud     = 0.97427;
+  const double SM::Vus     = 0.22534;
+  const double SM::Vub     = 0.00351;
+  const double SM::Vcd     = 0.22520;
+  const double SM::Vcs     = 0.97334;
+  const double SM::Vcb     = 0.0412;
+  const double SM::Vtd     = 0.00867;
+  const double SM::Vts     = 0.0404;
+  const double SM::Vtb     = 0.999146;
+  const double SM::Q_HD    = 5.0;
+  const bool SM::b_HD;
+  const double SM::ms_5    = 0.08160951656;
+  const double SM::mc_5    = 0.8960809463;
+  const double SM::mb_5    = 4.310679848;
+  const double SM::mt_5    = 246.5552058;
+
 SM::SM() {
-  m_alpha_s = SM::alpha_s; 
+  m_alpha_s = SM::alpha_s;
 
   m_alpha   = SM::alpha;
   m_alpha0  = SM::alpha0;
   m_GF      = SM::GF;
   m_MZ      = SM::MZ;
   m_MW      = SM::MW;
-  
+
   m_GammaW  = SM::GammaW;
   m_GammaZ  = SM::GammaZ;
 
@@ -29,7 +63,7 @@
   m_md_p[2] = SM::mb_p;
   m_mu_p[0] = SM::mu_p;
   m_mu_p[1] = SM::mc_p;
-  m_mu_p[2] = SM::mt_p;  
+  m_mu_p[2] = SM::mt_p;
   m_ml_p[0] = SM::me_p;
   m_ml_p[1] = SM::mmu_p;
   m_ml_p[2] = SM::mtau_p;
@@ -43,7 +77,7 @@
   m_CKM[2][0]     = SM::Vtd;
   m_CKM[2][1]     = SM::Vts;
   m_CKM[2][2]     = SM::Vtb;
-  
+
   clear_lookup();
 }
 
@@ -147,7 +181,7 @@
   return m_MW;
 }
 
-  
+
 double SM::get_MZ() {
   return m_MZ;
 }
@@ -156,7 +190,7 @@
 double SM::get_GF() {
   return m_GF;
 }
-  
+
 
 double SM::get_gamma_W() {
   return m_GammaW;
@@ -171,20 +205,20 @@
 double SM::get_gamma_V(int v) {
   if (v==2) return m_GammaZ;
   if (v==3) return m_GammaW;
-  return 0.;  
+  return 0.;
 }
 
 
 double SM::get_gamma_top() {
-  
+
   double tWb = get_gamma_tWd(3);
   double tWs = get_gamma_tWd(2);
   double tWd = get_gamma_tWd(1);
-  
+
   double gtot = tWb+tWs+tWd;
-  
-/*  
-  
+
+/*
+
   double Vtb = get_CKM_element(3,3);
   double GF = get_GF();
   double mt = get_umass_pole(3);
@@ -370,8 +404,8 @@
 
   if ((flav>6)||(flav<1)) return 0;
 
-  if ((!b_HD)&&(flav<=3)) return get_qmass_pole(flav);  
-  if ((b_HD) &&(flav<=2)) return get_qmass_pole(flav);  
+  if ((!b_HD)&&(flav<=3)) return get_qmass_pole(flav);
+  if ((b_HD) &&(flav<=2)) return get_qmass_pole(flav);
   // Lookup table
   if (m_qmass_ms[flav]>=0.) return m_qmass_ms[flav];
 
@@ -389,14 +423,14 @@
 
   // 1-loop conversion
   double mq_msbar = mq_p/(1.+4./3.*as);
-  
+
    // Change to higher loops
    if (loops==2) {
      mq_msbar = mq_p/(1.+4./3.*as+Kq2*pow(as,2));
    } else if(loops==3) {
      mq_msbar = mq_p/(1.+4./3.*as+Kq2*pow(as,2)+Kq3*pow(as,3));
    }
- 
+
   // Run to mq(mq)
   mq_msbar=run_qmass_MSbar(mq_msbar,mq_p,mq_msbar,mt,mb);
 
@@ -408,25 +442,25 @@
   if ((b_HD)&&(flav==6)) {mq_msbar = mt_5;}
 
   m_qmass_ms[flav] = mq_msbar;
-  
+
   return mq_msbar;
 }
 
 void SM::set_qmass_msbar(int flav, double qmass_in) {
- 
+
     double mbar = get_qmass_MSbar(flav);
     double mpole = get_qmass_pole(flav);
- 
-    while (abs(qmass_in-mbar)/qmass_in > 1E-5) {    
+
+    while (abs(qmass_in-mbar)/qmass_in > 1E-5) {
       set_qmass_pole(flav,mpole+(qmass_in-mbar));
       mbar = get_qmass_MSbar(flav);
       mpole = get_qmass_pole(flav);
-    }    
+    }
 }
 
 
 void SM::set_alpha(double alpha_in) {
-  
+
   if (alpha_in>=0) {
     m_alpha=alpha_in;
     clear_lookup();
@@ -435,7 +469,7 @@
 
 
 void SM::set_alpha0(double alpha_in) {
-  
+
   if (alpha_in>=0) {
     m_alpha0=alpha_in;
     clear_lookup();
@@ -456,7 +490,7 @@
     m_GF=GF_in;
     clear_lookup();
   }
-    
+
 }
 
 
@@ -535,7 +569,7 @@
   const double zeta3=1.202056903;
   const double zeta4=1.082323234;
   const double zeta5=1.036927755;
-  
+
   double beta[4] = {0.,0.,0.,0.};
   double gamma[4] = {0.,0.,0.,0.};
 
@@ -552,7 +586,7 @@
   if (nloops>=3) {
     beta[2] = 1./64.*(2857./2.-5033./18.*nf+325./54.*nf*nf);
     gamma[2] = 1./64.*(1249.-(2216./27.+160./3.*zeta3)*nf-140./81.*nf*nf);
-  } 
+  }
   if (nloops>=4) {
     beta[3] = 1./256.*(149753./6.+3564.*zeta3-(1078361./162.+6508./27.*zeta3)*nf+(50065./162.+6472./81.*zeta3)*nf*nf+1093./729.*nf*nf*nf);
     gamma[3]=1./256.*(4603055./162.+135680./27.*zeta3-8800.*zeta5-(91723./27.+34192./9.-880.*zeta4-18400./9.*zeta5)*nf+(5242./243.+800./9.*zeta3-160./3.*zeta4)*nf*nf-(332./243.-64./27.*zeta3)*nf*nf);
@@ -562,7 +596,7 @@
 
   double C1 = gamma[1]/beta[0]-beta[1]*gamma[0]/pow(beta[0],2);
   double C2 = gamma[2]/beta[0]-beta[1]*gamma[1]/pow(beta[0],2)-beta[2]*gamma[0]/pow(beta[0],2)+pow(beta[1],2)*gamma[0]/pow(beta[0],3);
-//  double C3 = gamma[3]/beta[0]-beta[1]*gamma[2]/pow(beta[0],2)+pow(beta[1],2)*gamma[1]/pow(beta[0],3)-beta[2]*gamma[1]/pow(beta[0],2)-pow(beta[1],3)*gamma[0]/pow(beta[0],4)+2.*beta[1]*beta[2]*gamma[0]/pow(beta[0],3)-beta[3]*gamma[0]/pow(beta[0],2);   
+//  double C3 = gamma[3]/beta[0]-beta[1]*gamma[2]/pow(beta[0],2)+pow(beta[1],2)*gamma[1]/pow(beta[0],3)-beta[2]*gamma[1]/pow(beta[0],2)-pow(beta[1],3)*gamma[0]/pow(beta[0],4)+2.*beta[1]*beta[2]*gamma[0]/pow(beta[0],3)-beta[3]*gamma[0]/pow(beta[0],2);
 
 
   double R = pow(ras,gamma[0]/beta[0])*(1.+ras*C1+0.5*pow(ras,2)*(pow(C1,2)+C2));
@@ -572,13 +606,13 @@
 }
 
 // Matching function for the quark mass evolution valid at threshold,
-// i.e. when the matching scale for the mass evolution coincides with the 
+// i.e. when the matching scale for the mass evolution coincides with the
 // scale at which the number of flavors change in the effective theory.
 // Adopted from arXiv:0712.1419
 double SM::m_threshold(double as) {
   //  const double zeta3  = 1.202056903;
   //  const double zeta4  = 1.082323234;
-  //  const double B4     = -1.762800; 
+  //  const double B4     = -1.762800;
 
   double MR = 1.;
 
@@ -586,7 +620,7 @@
 //    double ras = as/M_PI;
 //    MR = 1.+1./12.*pow(ras,2)*89./36.;
 //  }
-  
+
   return MR;
 
 }
@@ -600,14 +634,14 @@
   double alphas_Qinit=run_alphas_MSbar(Qinit,mtop,mbot);
   double alphas_Qfin =run_alphas_MSbar(Qfin,mtop,mbot);
   double mcharm = get_qmass_pole(4);
-  
+
   // Are we asking for the impossible?
   if ((alphas_Qinit!=alphas_Qinit)||(alphas_Qfin!=alphas_Qfin)) return quark_mass;
 
   int nf = 0;
 
   if (Qinit < mcharm) {
-    nf = 3;    
+    nf = 3;
     R_Qinit = RQ(alphas_Qinit,nf);
 
     if (Qfin <= mcharm) {
@@ -623,7 +657,7 @@
   } else if ((Qinit>=mcharm)&&(Qinit<mbot)) {
     nf = 4;
     R_Qinit = RQ(alphas_Qinit,nf);
-    
+
     if ((Qfin >= mcharm)&&(Qfin<mbot)) {
       R_Qfin = RQ(alphas_Qfin,nf);
       return R_Qfin/R_Qinit*quark_mass;
@@ -643,7 +677,7 @@
  } else if ((Qinit>=mbot)&&(Qinit<mtop)) {
     nf = 5;
     R_Qinit = RQ(alphas_Qinit,nf);
-    
+
     if ((Qfin >= mbot)&&(Qfin<mtop)) {
       R_Qfin = RQ(alphas_Qfin,nf);
       return R_Qfin/R_Qinit*quark_mass;
@@ -663,7 +697,7 @@
   } else if (Qinit >= mtop) {
     nf = 6;
     R_Qinit = RQ(alphas_Qinit,nf);
-    
+
     if (Qfin >= mtop) {
       R_Qfin = RQ(alphas_Qfin,nf);
       return R_Qfin/R_Qinit*quark_mass;
@@ -678,16 +712,16 @@
 
   return 0.;
 }
-      
+
 
 double SM::QCD_beta(int c, int nf) {
 
   if ((c < 0)||(c > 2)) return 0.;
-  
+
   double beta = -1;
-  
+
   switch(c) {
-  
+
     case 0:
      beta=11.-2.*nf/3.;
      break;
@@ -698,7 +732,7 @@
      beta=2857.-5033.*nf/9.+325.*nf*nf/27.;
      break;
   }
-  
+
   return beta;
 }
 
@@ -712,24 +746,24 @@
   double beta0, beta1, beta2, alpha_s_running, Lambda4, Lambda5,  Lambda_min, Lambda_max, Lambda_moy, alphas_min, alphas_moy;
 // double beta0, beta1, beta2, alpha_s_running, Lambda4, Lambda5, Lambda6, Lambda_min, Lambda_max, Lambda_moy, alphas_min, alphas_moy, alpha_s_match;
   int nf;
-  
+
   double pi = M_PI;
 
   nf=5;
   beta0 = QCD_beta(0,nf);
   beta1 = QCD_beta(1,nf);
   beta2 = QCD_beta(2,nf);
-  
+
   Lambda_min=1.e-3;
   Lambda_max=1.;
   alphas_min=0.;
 
   while(fabs(1.-alphas_min/alphas_MZ)>=1.e-6) {
     alphas_min=4.*pi/beta0/log(pow(MZ/Lambda_min,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(MZ/Lambda_min,2.)))/log(pow(MZ/Lambda_min,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(MZ/Lambda_min,2.)),2.)*(pow(log(log(pow(MZ/Lambda_min,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
     Lambda_moy=(Lambda_min+Lambda_max)/2.;
     alphas_moy=4.*pi/beta0/log(pow(MZ/Lambda_moy,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(MZ/Lambda_moy,2.)))/log(pow(MZ/Lambda_moy,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(MZ/Lambda_moy,2.)),2.)*(pow(log(log(pow(MZ/Lambda_moy,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
     if((alphas_MZ>=alphas_min)&&(alphas_MZ<=alphas_moy))
       Lambda_max=Lambda_moy;
     else Lambda_min=Lambda_moy;
@@ -746,24 +780,24 @@
 
 /*** These aren't the flavours you are looking for - please move along ***
   } if((Q>mtop)) {
-    // 6 active flavors 
+    // 6 active flavors
     alpha_s_match=4.*pi/beta0/log(pow(mtop/Lambda5,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mtop/Lambda5,2.)))/log(pow(mtop/Lambda5,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mtop/Lambda5,2.)),2.)*(pow(log(log(pow(mtop/Lambda5,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
     nf=6;
     beta0 = QCD_beta(0,nf);
     beta1 = QCD_beta(1,nf);
     beta2 = QCD_beta(2,nf);
-  
+
     Lambda_min=1.e-3;
     Lambda_max=1.;
     alphas_min=0.;
-  
+
     while(fabs(1.-alphas_min/alpha_s_match)>=1.e-5) {
       alphas_min=4.*pi/beta0/log(pow(mtop/Lambda_min,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mtop/Lambda_min,2.)))/log(pow(mtop/Lambda_min,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mtop/Lambda_min,2.)),2.)*(pow(log(log(pow(mtop/Lambda_min,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-    
+
 	  Lambda_moy=(Lambda_min+Lambda_max)/2.;
       alphas_moy=4.*pi/beta0/log(pow(mtop/Lambda_moy,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mtop/Lambda_moy,2.)))/log(pow(mtop/Lambda_moy,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mtop/Lambda_moy,2.)),2.)*(pow(log(log(pow(mtop/Lambda_moy,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-    
+
       if((alpha_s_match>=alphas_min)&&(alpha_s_match<=alphas_moy))
         Lambda_max=Lambda_moy;
 	  else Lambda_min=Lambda_moy;
@@ -776,18 +810,18 @@
 */
   } else {
     /* 4 active flavors */
-  
+
     alpha_s_running=4.*pi/beta0/log(pow(mbot/Lambda5,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mbot/Lambda5,2.)))/log(pow(mbot/Lambda5,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mbot/Lambda5,2.)),2.)*(pow(log(log(pow(mbot/Lambda5,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
 
 //  1-loop ratio between pole mass and MSbar mass at pole mass
-    double mratio=1+4./3.*alpha_s_running/pi;   
-    
+    double mratio=1+4./3.*alpha_s_running/pi;
+
     double alpha_s_msbar=4.*pi/beta0/log(pow(mbot/mratio/Lambda5,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mbot/mratio/Lambda5,2.)))/log(pow(mbot/mratio/Lambda5,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mbot/mratio/Lambda5,2.)),2.)*(pow(log(log(pow(mbot/mratio/Lambda5,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
 
     double R_Qinit = RQ(alpha_s_running,4);
     double R_Qfin = RQ(alpha_s_msbar,4);
     mratio = mratio/R_Qfin*R_Qinit;
-    
+
     double xi_factor = 1.-alpha_s_running/pi/6.*log(pow(mratio,2))
     +pow(alpha_s_running/pi,2)*(11./12.-11./24.*log(pow(mratio,2))+1./36.*pow(log(pow(mratio,2)),2));
 
@@ -804,15 +838,15 @@
 
     while(fabs(1.-alphas_min/alpha_s_match)>=1.e-5) {
 	  alphas_min=4.*pi/beta0/log(pow(mbot/Lambda_min,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mbot/Lambda_min,2.)))/log(pow(mbot/Lambda_min,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mbot/Lambda_min,2.)),2.)*(pow(log(log(pow(mbot/Lambda_min,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
    	  Lambda_moy=(Lambda_min+Lambda_max)/2.;
       alphas_moy=4.*pi/beta0/log(pow(mbot/Lambda_moy,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mbot/Lambda_moy,2.)))/log(pow(mbot/Lambda_moy,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mbot/Lambda_moy,2.)),2.)*(pow(log(log(pow(mbot/Lambda_moy,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
 	  if((alpha_s_match>=alphas_min)&&(alpha_s_match<=alphas_moy))
 	     Lambda_max=Lambda_moy;
 	  else Lambda_min=Lambda_moy;
     }
-    
+
     Lambda4=Lambda_min;
 
     alpha_s_running=4.*pi/beta0/log(pow(Q/Lambda4,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(Q/Lambda4,2.)))/log(pow(Q/Lambda4,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(Q/Lambda4,2.)),2.)*(pow(log(log(pow(Q/Lambda4,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
@@ -820,19 +854,19 @@
     if (Q<=get_qmass_pole(4)) {
        /* 3 active flavors */
       double mcharm = get_qmass_pole(4);
-  
+
       alpha_s_running=4.*pi/beta0/log(pow(mcharm/Lambda4,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mcharm/Lambda4,2.)))/log(pow(mcharm/Lambda4,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mcharm/Lambda4,2.)),2.)*(pow(log(log(pow(mcharm/Lambda4,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
 
 //  1-loop ratio between pole mass and MSbar mass at pole mass
-      double mratio=1+4./3.*alpha_s_running/pi;   
-    
+      double mratio=1+4./3.*alpha_s_running/pi;
+
       double alpha_s_msbar=4.*pi/beta0/log(pow(mcharm/mratio/Lambda4,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mcharm/mratio/Lambda4,2.)))/log(pow(mcharm/mratio/Lambda4,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mcharm/mratio/Lambda4,2.)),2.)*(pow(log(log(pow(mcharm/mratio/Lambda4,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
 
 //  run MSbar mass to itself i.e. (m(m(M))
       double R_Qinit = RQ(alpha_s_running,3);
       double R_Qfin = RQ(alpha_s_msbar,3);
       mratio = mratio/R_Qfin*R_Qinit;
-    
+
       double xi_factor = 1.-alpha_s_running/pi/6.*log(pow(mratio,2))+pow(alpha_s_running/pi,2)*(11./12.-11./24.*log(pow(mratio,2))+1./36.*pow(log(pow(mratio,2)),2));
 
       double alpha_s_match = alpha_s_running*pow(xi_factor,2);
@@ -848,21 +882,21 @@
 
       while(fabs(1.-alphas_min/alpha_s_match)>=1.e-5) {
    	    alphas_min=4.*pi/beta0/log(pow(mcharm/Lambda_min,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mcharm/Lambda_min,2.)))/log(pow(mcharm/Lambda_min,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mcharm/Lambda_min,2.)),2.)*(pow(log(log(pow(mcharm/Lambda_min,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
 	    Lambda_moy=(Lambda_min+Lambda_max)/2.;
 	    alphas_moy=4.*pi/beta0/log(pow(mcharm/Lambda_moy,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(mcharm/Lambda_moy,2.)))/log(pow(mcharm/Lambda_moy,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(mcharm/Lambda_moy,2.)),2.)*(pow(log(log(pow(mcharm/Lambda_moy,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-  
+
 	    if((alpha_s_match>=alphas_min)&&(alpha_s_match<=alphas_moy))
 	      Lambda_max=Lambda_moy;
 	    else Lambda_min=Lambda_moy;
       }
-    
+
       double Lambda3=Lambda_min;
       alpha_s_running=4.*pi/beta0/log(pow(Q/Lambda3,2.))*(1.-2.*beta1/beta0/beta0*log(log(pow(Q/Lambda3,2.)))/log(pow(Q/Lambda3,2.))+4.*beta1*beta1/pow(beta0*beta0*log(pow(Q/Lambda3,2.)),2.)*(pow(log(log(pow(Q/Lambda3,2.)))-1./2.,2.)+beta2*beta0/8./beta1/beta1-5./4.));
-       
-       
+
+
     }
-    
+
     return alpha_s_running;
   }
 }
@@ -878,3 +912,16 @@
   m_qmass_ms[6] = get_qmass_MSbar(6);
 
 }
+
+void SM::set_CKM(double ckm11, double ckm12, double ckm13, double ckm21, double ckm22, double ckm23,double ckm31, double ckm32, double ckm33) {
+    m_CKM[0][0]     = ckm11;
+    m_CKM[0][1]     = ckm12;
+    m_CKM[0][2]     = ckm13;
+    m_CKM[1][0]     = ckm21;
+    m_CKM[1][1]     = ckm22;
+    m_CKM[1][2]     = ckm23;
+    m_CKM[2][0]     = ckm31;
+    m_CKM[2][1]     = ckm32;
+    m_CKM[2][2]     = ckm33;
+    clear_lookup();
+}
diff -ruN src/SM.h src_patched/SM.h
--- src/SM.h	2015-08-27 23:02:14.000000000 +0930
+++ src_patched/SM.h	2018-10-20 20:05:34.000000000 +1030
@@ -3,101 +3,103 @@
 
 #include <gsl/gsl_matrix.h>
 
-/** 
+/**
 * @brief Class describing the Standard Model
 *
 * This class holds all the parameters specifying the Standard Model, and
 * methods to access them in convenient ways.
-* 
+*
 */
 class SM {
-  
+
  public:
-  
+
   /// Default value for EM coupling \f$ \alpha_{\rm{EM}}(M_Z) \f$
-  const static double alpha    = 1./127.934;       
-  
+  const static double alpha;
+
   /// Default value for EM coupling at low energy
-  const static double alpha0   = 1./137.0359997;       
-  
+  const static double alpha0;
+
   /// Default value for the Fermi constant \f$ G_F \f$ (\f$ \rm{GeV}^{-2} \f$)
-  const static double GF      = 1.16637E-5; 
+  const static double GF;
 
   /// Default value for \f$ M_Z \f$ (GeV)
-  const static double MZ      = 91.15349;
+  const static double MZ;
 
   /// Default value for \f$ M_W \f$ (GeV)
-  const static double MW      = 80.36951;
+  const static double MW;
 
   /// Default value for the strong coupling \f$ \alpha_s(M_Z) \f$
-  const static double alpha_s = 0.119; 
-  
+  const static double alpha_s;
+
   /// Default value for total width \f$ \Gamma_Z \f$ (GeV)
-  const static double GammaZ  = 2.49581;
+  const static double GammaZ;
 
   /// Default value for total width \f$ \Gamma_W \f$ (GeV)
-  const static double GammaW  = 2.08856;
+  const static double GammaW;
 
   /// Default value for quark pole mass \f$ m_d \f$ (GeV)
-  const static double md_p    = 0.0; 
-  
+  const static double md_p;
+
   /// Default value for quark pole mass \f$ m_u \f$ (GeV)
-  const static double mu_p    = 0.0; 
+  const static double mu_p;
 
   /// Default value for quark pole mass \f$ m_s \f$ (GeV)
-  const static double ms_p    = 0.1; 
-  
+  const static double ms_p;
+
   // Scale for strange quark mass (GeV)
-  const static double Q_ms    = 2.0; 
-  
+  const static double Q_ms;
+
   /// Default value for quark pole mass \f$ m_c \f$ (GeV)
-  const static double mc_p    = 1.42; 
+  const static double mc_p;
 
   /// Default value for quark pole mass \f$ m_b \f$ (GeV)
-  const static double mb_p    = 4.75; 
-  
+  const static double mb_p;
+
   /// Default value for quark pole mass \f$ m_t \f$ (GeV)
-  const static double mt_p    = 172.5;
- 
+  const static double mt_p;
+
   /// Default value for electron pole mass \f$ m_e \f$ (GeV)
-  const static double me_p    = 0.510998918E-3;
+  const static double me_p;
 
   /// Default value for muon pole mass \f$ m_\mu \f$ (GeV)
-  const static double mmu_p   = 0.105658367;
-  
+  const static double mmu_p;
+
   /// Default value for tau pole mass \f$ m_\tau \f$ (GeV)
-  const static double mtau_p  = 1.77684;  
+  const static double mtau_p;
 
   // PDG booklet 2012
   /// Default value for CKM matrix element \f$ V_{ud} \f$
-  const static double Vud     = 0.97427;
+  const static double Vud;
   /// Default value for CKM matrix element \f$ V_{us} \f$
-  const static double Vus     = 0.22534;
+  const static double Vus;
   /// Default value for CKM matrix element \f$ V_{ub} \f$
-  const static double Vub     = 0.00351;
+  const static double Vub;
   /// Default value for CKM matrix element \f$ V_{cd} \f$
-  const static double Vcd     = 0.22520;
+  const static double Vcd;
   /// Default value for CKM matrix element \f$ V_{cs} \f$
-  const static double Vcs     = 0.97334;
+  const static double Vcs;
   /// Default value for CKM matrix element \f$ V_{cb} \f$
-  const static double Vcb     = 0.0412;
+  const static double Vcb;
   /// Default value for CKM matrix element \f$ V_{td} \f$
-  const static double Vtd     = 0.00867;
+  const static double Vtd;
   /// Default value for CKM matrix element \f$ V_{ts} \f$
-  const static double Vts     = 0.0404;
+  const static double Vts;
   /// Default value for CKM matrix element \f$ V_{tb} \f$
-  const static double Vtb     = 0.999146;
+  const static double Vtb;
 
 
   /**
   * @brief Default constructor initializing the Standard Model with default parameter
   *        values
-  * 
+  *
   * This constructor initializes a new SM object with default parameters. The
   * values used as defaults are specified by public constants in this class.
   */
   SM();
 
+  // SM (const SM &obj) {printf("copy constructor called");};	
+
 
   /**
   * @brief Sets the EM coupling \f$ \alpha \f$
@@ -113,7 +115,7 @@
   */
   void set_alpha0(double alpha_in);
 
- 
+
   /**
   * @brief Sets the Fermi constant \f$ G_F \f$
   *
@@ -191,7 +193,7 @@
   * @returns Value of \f$ g \f$
   */
   double get_g();
-  
+
   /**
   * @brief Current value of hypercharge U(1) coupling \f$ g' \f$
   *
@@ -211,7 +213,7 @@
   *
   * @returns Value of \f$ \alpha_s \f$
   */
-  double get_alpha_s();  
+  double get_alpha_s();
 
   /**
   * @brief Current value of \f$ M_W \f$
@@ -233,7 +235,7 @@
   * @returns Value of \f$ M_Z \f$ (GeV)
   */
   double get_MZ();
-  
+
   /**
   * @brief Current value of \f$ \Gamma_Z \f$
   *
@@ -260,9 +262,9 @@
   *
   * This method returns the mass of a given vector boson. The numbering
   * convention used throughout 2HDMC is such that (1 = photon, 2 = Z0, 3 = W+).
-  * 
+  *
   * @param v Index (1-3) for the vector boson
-  * 
+  *
   * @returns Value of \f$ m_V \f$ (GeV)
   */
   double get_vmass(int v);
@@ -272,16 +274,16 @@
   *
   * This method returns the decay width of a given vector boson. The numbering
   * convention is such that (1 = photon, 2 = Z0, 3 = W+).
-  * 
+  *
   * @param v Index (1-3) for the vector boson
-  * 
+  *
   * @returns Value of \f$ \Gamma_V \f$ (GeV)
   */
   double get_gamma_V(int v);
 
  /**
   * @brief Sets the CKM matrix to a 3x3 unit matrix
-  * 
+  *
   * This method sets the CKM matrix to a 3x3 unit matrix, i.e. eliminating
   * all charged current interactions between different generations.
   */
@@ -289,102 +291,102 @@
 
   /**
   * @brief Full CKM matrix
-  * 
+  *
   * This method can be used to retrieve the full CKM matrix as a gsl_matrix.
   *
   * @returns CKM matrix
-  * 
+  *
   * @see get_MD, get_MU, get_ML, get_CKM_element
   */
   gsl_matrix* get_CKM_matrix();
 
   /**
   * @brief Element of the CKM matrix
-  * 
+  *
   * This method can be used to retrieve a certain element of the CKM matrix.
   *
   * @param i Row index (1,2,3 = u,c,t) of CKM matrix element
   * @param j Column index (1,2,3 = d,s,b) of CKM matrix element
   * @returns The requested CKM element
-  * 
+  *
   * @see get_CKM
   */
   double get_CKM_element(int i, int j);
 
   /**
   * @brief Sets the pole mass of a lepton
-  * 
+  *
   * This method sets the pole mass of lepton \a l to the supplied value.
-  * 
+  *
   * @param l Index of lepton (1,2,3 = \f$ e,\mu,\tau \f$)
   * @param lmass_in New mass of lepton
   */
   void set_lmass_pole(int l, double lmass_in);
-  
+
   /**
   * @brief Sets the pole mass of a quark
-  * 
+  *
   * This method sets the pole mass of quark \a q to the supplied value.
-  * 
+  *
   * @param q Index of quark (1,2,3,4,5,6 = \f$ d,u,s,c,b,t \f$)
   * @param qmass_in New mass of quark
   */
   void set_qmass_pole(int q, double qmass_in);
-  
+
   void set_qmass_msbar(int flav, double qmass_in);
-  
+
   /**
   * @brief Sets the pole mass of a down-type quark
-  * 
+  *
   * This method sets the pole mass of quark \a d to the supplied value.
-  * 
+  *
   * @param d Index of quark (1,2,3 = \f$ d,s,b \f$)
   * @param dmass_in New mass of quark
   */
   void set_dmass_pole(int d, double dmass_in);
-  
+
   /**
   * @brief Sets the pole mass of an up-type quark
-  * 
+  *
   * This method sets the pole mass of quark \a u to the supplied value.
-  * 
+  *
   * @param u Index of quark (1,2,3 = \f$ u,c,t \f$)
   * @param umass_in New mass of quark
   */
-  void set_umass_pole(int u, double umass_in);  
+  void set_umass_pole(int u, double umass_in);
 
   /**
   * @brief Quark pole mass
-  * 
+  *
   * @param q Index (1,2,3,4,5,6 = \f$ d,u,s,c,b,t \f$) of quark
-  * 
+  *
   * @returns The pole mass \f$ m_q \f$
   */
   double get_qmass_pole(int q);
-  
+
   /**
   * @brief Down-type quark pole mass
-  * 
+  *
   * @param d Index (1,2,3 = \f$ d,s,b \f$) of down-type quark
-  * 
+  *
   * @returns Quark pole mass \f$ m_d \f$
   */
   double get_dmass_pole(int d);
 
   /**
   * @brief Up-type quark pole mass
-  * 
+  *
   * @param u Index (1,2,3 = \f$ u,c,t \f$) of up-type quark
-  * 
+  *
   * @returns Quark pole mass \f$ m_u \f$
   */
   double get_umass_pole(int u);
 
   /**
   * @brief Lepton pole mass
-  * 
+  *
   * @param l Index (1,2,3 = \f$ e,\mu,\tau \f$) of lepton
-  * 
+  *
   * @returns The pole mass \f$ m_l \f$
   */
   double get_lmass_pole(int l);
@@ -392,39 +394,39 @@
 
   /**
   * @brief Mass matrix for down-type quarks
-  * 
-  * This method can be used to retrieve, in matrix form, the current pole masses 
+  *
+  * This method can be used to retrieve, in matrix form, the current pole masses
   * used for the down-type quarks. The masses are returned as the diagonal
   * elements of a 3x3 gsl_matrix that must be allocated by the user.
   *
   * @returns Diagonal mass matrix for the down-type quarks
-  * 
+  *
   * @see get_MU, get_ML, get_CKM
   */
   gsl_matrix* get_MD();
 
   /**
   * @brief Mass matrix for up-type quarks
-  * 
-  * This method can be used to retrieve, in matrix form, the current pole masses 
+  *
+  * This method can be used to retrieve, in matrix form, the current pole masses
   * used for the up-type quarks. The masses are returned as the diagonal
   * elements of a 3x3 gsl_matrix that must be allocated by the user.
   *
   * @returns Diagonal mass matrix for the up-type quarks
-  * 
+  *
   * @see get_MD, get_ML, get_CKM
   */
   gsl_matrix* get_MU();
 
   /**
   * @brief Mass matrix for leptons
-  * 
-  * This method can be used to retrieve, in matrix form, the current pole masses 
+  *
+  * This method can be used to retrieve, in matrix form, the current pole masses
   * used for the leptons. The masses are returned as the diagonal
   * elements of a 3x3 gsl_matrix that must be allocated by the user.
   *
   * @returns Diagonal mass matrix for the leptons
-  * 
+  *
   * @see get_MD, get_MU, get_CKM
   */
   gsl_matrix* get_ML();
@@ -432,57 +434,57 @@
 
   /**
   * @brief Quark \f$ \overline{\rm{MS}}\f$ mass
-  * 
+  *
   * This method determines the \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_q(\overline{m}_q) \f$
-  * 
+  *
   * @param q Index (1,2,3,4,5,6 = \f$ d,u,s,c,b,t \f$) of quark
-  * 
+  *
   * @returns Quark \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_q(\overline{m}_q) \f$
-  * 
+  *
   * @see run_qmass_MSbar
   */
   double get_qmass_MSbar(int q);
 
   /**
   * @brief Down-type quark \f$ \overline{\rm{MS}}\f$ mass
-  * 
+  *
   * This method determines the \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_d(\overline{m}_d) \f$
-  * 
+  *
   * @param d Index (1,2,3 = \f$ d,s,b \f$) of down-type quark
-  * 
+  *
   * @returns Quark \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_d(\overline{m}_d) \f$
-  * 
+  *
   * @see get_umass_MSbar, run_qmass_MSbar
   */
   double get_dmass_MSbar(int d);
-  
+
   /**
   * @brief Up-type quark \f$ \overline{\rm{MS}}\f$ mass
-  * 
+  *
   * This method determines the \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_u(\overline{m}_u) \f$
-  * 
+  *
   * @param u Index (1,2,3 = \f$ u,c,t \f$) of up-type quark
-  * 
+  *
   * @returns Quark \f$ \overline{\rm{MS}}\f$ mass \f$ \overline{m}_u(\overline{m}_u) \f$
-  * 
+  *
   * @see get_dmass_MSbar, run_qmass_MSbar
   */
   double get_umass_MSbar(int u);
 
   /**
   * @brief Evaluates running quark masses
-  * 
-  * This method evaluates the running quark_mass \a quark_mass, initially specified 
+  *
+  * This method evaluates the running quark_mass \a quark_mass, initially specified
   * at the input scale \a Qinit, at the new scale \a Qfin. The calculation is performed
   * in the \f$ \overline{\rm{MS}} \f$ scheme with variable number of active
   * flavours and threshold matching.
-  * 
+  *
   * @param quark_mass The input value for the running quark mass
   * @param Qinit      Starting scale
   * @param Qfin       Final scale at which the mass is to be evaluated
   * @param mtop       \f$ \overline{\rm{MS}} \f$ top mass (for thresholds)
   * @param mbot       \f$ \overline{\rm{MS}} \f$ bottom mass (for thresholds)
-  * 
+  *
   * @returns The running mass at the scale \a Qfin
   */
   double run_qmass_MSbar(double quark_mass, double Qinit, double Qfin, double mtop, double mbot);
@@ -490,27 +492,27 @@
 
   /**
   * @brief Evaluates the running strong coupling
-  * 
-  * This method evaluates the running strong coupling \f$ \alpha_s \f$ in the 
+  *
+  * This method evaluates the running strong coupling \f$ \alpha_s \f$ in the
   * \f$ \overline{\rm{MS}} \f$ scheme at the scale specified by \a Q.
-  * 
+  *
   * @param Q          Scale at which to evaluate the running coupling
   * @param mtop       \f$ \overline{\rm{MS}} \f$ top mass (for thresholds)
   * @param mbot       \f$ \overline{\rm{MS}} \f$ bottom mass (for thresholds)
-  * 
+  *
   * @returns The strong coupling \f$ \alpha_s \f$ at the scale \a Q
   */
   double run_alphas_MSbar(double Q, double mtop, double mbot);
 
-  /** 
+  /**
   * @brief Number of active flavours
-  * 
-  * This method returns the number of active quark flavours to be used at 
+  *
+  * This method returns the number of active quark flavours to be used at
   * a certain mass scale when decoupling the heavier quarks. The thresholds
   * are determined from the quark \f$ \overline{\rm{MS}} \f$ masses.
-  * 
+  *
   * @param M The scale for which the number of flavours is desired
-  * 
+  *
   * @returns The number of quark flavours active at this scale
   */
   int get_Nactivef(double M);
@@ -518,36 +520,37 @@
 
   /**
   * @brief %SM width of the top quark
-  * 
-  * Calculates the width of the top quark in the %SM, i.e. no contributions from 
+  *
+  * Calculates the width of the top quark in the %SM, i.e. no contributions from
   * \f$ t\to H^+ b \f$ decays etc. are included.
-  * 
+  *
   * @returns The top width \f$ \Gamma_t \f$
   */
   double get_gamma_top();
   double get_gamma_tWd(int d);
 
- 
- 
+  // sets the terms in the CKM matrix
+  void set_CKM(double ckm11, double ckm12, double ckm13, double ckm21, double ckm22, double ckm23,double ckm31, double ckm32, double ckm33);
+
 
   // --- These masses are for compatibility test with HDECAY ---
   // Scale for HD quark masses (HD)
-  const static double Q_HD    = 5.0; 
-  
+  const static double Q_HD;
+
   // switch for HD quark masses (HD)
-  const static bool b_HD    = false; 
-  
+  const static bool b_HD    = false;
+
   /// Default value for running quark mass at 5 GeV \f$ m_s(5) \f$ (GeV)
-  const static double ms_5    = 0.08160951656; 
+  const static double ms_5;
 
   /// Default value for running quark mass at 5 GeV \f$ m_c(5) \f$ (GeV)
-  const static double mc_5    = 0.8960809463; 
+  const static double mc_5;
 
   /// Default value for running quark mass at 5 GeV \f$ m_b(5) \f$ (GeV)
-  const static double mb_5    = 4.310679848; 
-  
+  const static double mb_5;
+
   /// Default value for running quark mass at 5 GeV \f$ m_t(5) \f$ (GeV)
-  const static double mt_5    = 246.5552058;
+  const static double mt_5;
   // -------------------------------------------------------------
 
 
@@ -569,15 +572,15 @@
   double m_CKM[3][3];
 
   double m_qmass_ms[7];
-  
-	// Support functions for the running mass calculation	
+
+	// Support functions for the running mass calculation
   double m_threshold(double as);
   double RQ(double as, int nf, int loops);
   double QCD_beta(int c, int nf);
 
   void clear_lookup();
 
-  
+
 };
 
 #endif
diff -ruN src/THDM.cpp src_patched/THDM.cpp
--- src/THDM.cpp	2015-08-27 22:34:33.000000000 +0930
+++ src_patched/THDM.cpp	2018-10-31 18:38:25.000000000 +1030
@@ -1,12 +1,12 @@
 /*******************************************************************************
  2HDMC - two-Higgs-doublet model calculator
  THDM class
- 
+
  http://2hdmc.hepforge.org
 *******************************************************************************/
 
 #include "THDM.h"
-#include "DecayTable.h"
+#include "DecayTableTHDM.h"
 #include "Constraints.h"
 #include "HBHS.h"
 #include "Util.h"
@@ -33,6 +33,8 @@
 
 using namespace std;
 
+  const double THDM::EPS = 1E-12;
+
 /***************************************************************************
 * Method used by external codes (SusHi) to set the model parameters
 *
@@ -46,15 +48,15 @@
 
 /*
    cout << "Key="<< key << endl;
-   for (int i=0; i<nsmpara; i++) {  
+   for (int i=0; i<nsmpara; i++) {
      cout << i << " " << smpara[i] << endl;
   }
-   for (int i=0; i<npara; i++) {  
+   for (int i=0; i<npara; i++) {
      cout << i << " " << para[i] << endl;
   }
 */
 
-   for (int i=0; i<nres; i++) {  
+   for (int i=0; i<nres; i++) {
      res[i] = 0.;
   }
 
@@ -67,13 +69,13 @@
    sm.set_MZ(smpara[3]);
    sm.set_qmass_msbar(5,smpara[4]);
    sm.set_qmass_pole(6,smpara[5]);
-   
+
    model->set_SM(sm);
 
    int type = 0;
-   
+
  if (key==1) {
-   
+
    double lam1 = para[0];
    double lam2 = para[1];
    double lam3 = para[2];
@@ -84,13 +86,13 @@
    double m12_2 = para[7];
    double tb = para[8];
    type = (int)para[9];
-   
+
    bool ok = model->set_param_gen(lam1,lam2,lam3,lam4,lam5,lam6,lam7,m12_2,tb);
-   
+
    if (!ok) return -1;
-   model->set_yukawas_type(type);	
+   model->set_yukawas_type(type);
  } else if (key==2) {
- 
+
    double mh = para[0];
    double mH = para[1];
    double mA = para[2];
@@ -101,13 +103,13 @@
    double m12_2 = para[7];
    double tb = para[8];
    type = (int)para[9];
-   
+
    bool ok = model->set_param_phys(mh,mH,mA,mC,sba,lam6,lam7,m12_2,tb);
    if (!ok) return -1;
-   model->set_yukawas_type(type);	 
- 
+   model->set_yukawas_type(type);
+
  } else if (key==3) {
-  
+
    double mh = para[0];
    double mH = para[1];
    double sba = para[2];
@@ -120,9 +122,9 @@
    bool ok = model->set_param_hybrid_sba(mh,mH,sba,Z4,Z5,Z7,tb);
    if (!ok) return -1;
    model->set_yukawas_type(type);
-     
+
  } else if (key==4) {
-  
+
    double mh = para[0];
    double mH = para[1];
    double cba = para[2];
@@ -135,33 +137,33 @@
    bool ok = model->set_param_hybrid(mh,mH,cba,Z4,Z5,Z7,tb);
    if (!ok) return -1;
    model->set_yukawas_type(type);
-     
+
  } else {
   return -1;
  }
 
-//   model->print_param_gen(); 
+//   model->print_param_gen();
 //   model->print_param_phys();
-  
+
    double mh,mH,mA,mC,sba,l6,l7,m12_2,tb;
-  
+
    model->get_param_phys(mh,mH,mA,mC,sba,l6,l7,m12_2,tb);
-  
+
    bool P = model->check_perturbativity(4.*M_PI);
    bool U = model->check_unitarity(16.*M_PI);
    bool S = model->check_stability();
 
-    DecayTable table(*model);
+    DecayTableTHDM table(*model);
 
     double gtoth = table.get_gammatot_h(1);
     double gtotH = table.get_gammatot_h(2);
     double gtotA = table.get_gammatot_h(3);
- 
+
     res[0] = mh;
     res[1] = mH;
     res[2] = mA;
     res[3] = -asin(sba)+atan(tb);
-    res[4] = tb; 
+    res[4] = tb;
     res[5] = (double)type;
     res[6] = S ? 1.0 : 0.0;
     res[7] = P ? 1.0 : 0.0;
@@ -170,7 +172,7 @@
     res[10] = gtoth;
     res[11] = gtotH;
     res[12] = gtotA;
-		
+
     if (slha) {
      model->write_LesHouches("2HDMC.out",1,0,1);
     }
@@ -185,13 +187,13 @@
   init();
 }
 
-
 void THDM::init() {
   if (first_run) {
   	print_info();
   }
 
   params_set = false;
+  params_full_set = false;
   yukawas_type = -1;
 
   v2 = sm.get_v2();
@@ -220,9 +222,57 @@
   gsl_matrix_set_zero(rho_N);
 }
 
+bool THDM::set_param_full(double lambda1, double lambda2, double lambda3,
+			 double lambda4, double lambda5, double lambda6,
+			 double lambda7, double m12_2, double tan_beta,
+       double m_h,double m_H, double m_A, double m_Hp,
+			 double sba) {
+
+      // tan(beta) must be greater than 0 for valid basis
+      if (tan_beta<=0) {
+        params_set = false;
+        return params_set;
+      }
+
+      double v2  = sm.get_v2();
+
+      lambda[1] = lambda1;
+      lambda[2] = lambda2;
+      lambda[3] = lambda3;
+      lambda[4] = lambda4;
+      lambda[5] = lambda5;
+      lambda[6] = lambda6;
+      lambda[7] = lambda7;
+      beta = atan(tan_beta);
+
+      double tb  = tan_beta;
+      double ctb = 1./tb;
+      double cb  = 1./sqrt(1.+tb*tb);
+      double sb  = tb*cb;
+      double sb2 = sb*sb;
+      double cb2 = cb*cb;
+      double s2b = 2.*sb*cb;
+      double c2b = cb2-sb2;
+      double s3b = 3.*sb-4.*sb*sb2;
+      double c3b = 4.*cb*cb2-3.*cb;
+
+      m22_2 = m12_2*ctb-0.5*v2*(lambda[2]*sb2+(lambda[3]+lambda[4]+lambda[5])*cb2+lambda[6]*cb2*ctb+3.*lambda[7]*sb*cb);
+
+      this->m_h = m_h;
+      this->m_H = m_H;
+      this->m_A = m_A;
+      this->m_Hp = m_Hp;
+      this->m12_2 = m12_2;
+      sinba = sba;
+
+      params_set = true;
+      params_full_set = true;
+      return params_set;
+    }
+
 
 bool THDM::set_param_gen(double lambda1, double lambda2, double lambda3,
-			 double lambda4, double lambda5, double lambda6, 
+			 double lambda4, double lambda5, double lambda6,
 			 double lambda7, double m12_2, double tan_beta) {
 
   // tan(beta) must be greater than 0 for valid basis
@@ -252,8 +302,8 @@
   double c2b = cb2-sb2;
   double s3b = 3.*sb-4.*sb*sb2;
   double c3b = 4.*cb*cb2-3.*cb;
-  
-  m22_2 = m12_2*ctb-0.5*v2*(lambda[2]*sb2+(lambda[3]+lambda[4]+lambda[5])*cb2+lambda[6]*cb2*ctb+3.*lambda[7]*sb*cb);  
+
+  m22_2 = m12_2*ctb-0.5*v2*(lambda[2]*sb2+(lambda[3]+lambda[4]+lambda[5])*cb2+lambda[6]*cb2*ctb+3.*lambda[7]*sb*cb);
 
   // Mass of CP-odd Higgs
   double mA_2 = m12_2/(sb*cb)-0.5*v2*(2.*lambda5+lambda6*ctb+lambda7*tb);
@@ -273,12 +323,13 @@
     params_set=false;
   }
 
+  params_full_set = false;
   return params_set;
 }
 
 
 bool THDM::set_param_HHG(double Lambda1, double Lambda2, double Lambda3,
-			 double Lambda4, double Lambda5, double Lambda6, 
+			 double Lambda4, double Lambda5, double Lambda6,
 			 double tan_beta) {
 
   if (tan_beta<=0) {
@@ -287,7 +338,7 @@
   }
 
   double l1,l2,l3,l4,l5,l6,l7,m12_2;
-  
+
   l1 = 2.*(Lambda1+Lambda3);
   l2 = 2.*(Lambda2+Lambda3);
   l3 = 2.*Lambda3+Lambda4;
@@ -308,7 +359,7 @@
 			  double m12_2,double tan_beta) {
 
   if (m_h>m_H) {
-    cerr << "WARNING: Cannot set physical masses such that m_H < m_h\n"; 
+    cerr << "WARNING: Cannot set physical masses such that m_H < m_h\n";
     params_set = false;
     return params_set;
   }
@@ -337,7 +388,7 @@
   double ca2 = ca*ca;
 
   double cba = sqrt(1.-sba*sba);
- 
+
   lambda[1]=(m_H*m_H*ca2+m_h*m_h*sa2-m12_2*tb)/v2/cb2-1.5*lambda6*tb+0.5*lambda7*tb*tb*tb;
   lambda[2]=(m_H*m_H*sa2+m_h*m_h*ca2-m12_2*ctb)/v2/sb2+0.5*lambda6*ctb*ctb*ctb-1.5*lambda7*ctb;
   lambda[3]=((m_H*m_H-m_h*m_h)*ca*sa+2.*m_Hp*m_Hp*sb*cb-m12_2)/v2/sb/cb-0.5*lambda6*ctb-0.5*lambda7*tb;
@@ -347,20 +398,21 @@
   sinba = sba;
 
   params_set=true;
+  params_full_set=false;
 
   return params_set;
 }
 
 
 bool THDM::set_param_higgs(double Lambda1, double Lambda2, double Lambda3,
-			   double Lambda4, double Lambda5, double Lambda6, 
+			   double Lambda4, double Lambda5, double Lambda6,
 			   double Lambda7, double m_Hp) {
 
   if (m_Hp<0) {
     params_set = false;
     return params_set;
   }
-  
+
   lambda[1]=Lambda1;
   lambda[2]=Lambda2;
   lambda[3]=Lambda3;
@@ -372,7 +424,7 @@
   m22_2=m_Hp*m_Hp-0.5*v2*Lambda3;
 
   double m_A2 = m_Hp*m_Hp-0.5*v2*(Lambda5-Lambda4);
-  
+
   double s2ba = -2.*Lambda6*v2;
   double c2ba = -(m_A2+(Lambda5-Lambda1)*v2);
   // Handle special case with degenerate masses
@@ -383,7 +435,9 @@
   } else {
     cerr << "WARNING: Requested masses m_h and m_H too close (" << m_A2+(Lambda5-Lambda1)*v2 << ", " << Lambda6 << "), precision problems expected\n";
     params_set = false;
-  }  
+  }
+
+  params_full_set=false;
 
   return params_set;
 }
@@ -396,7 +450,7 @@
   bool params_set = true;
 
   double vsmall = 1E-10;
-  
+
   if ((mh<0)||(abs(cba) > 1)||(abs(mh-mH)<vsmall)) {
     params_set = false;
     return params_set;
@@ -407,13 +461,13 @@
   double sba = sign(cba)*sqrt(1.-cba*cba);
 
   params_set = set_param_hybrid_sba(mh,mH,sba,Z4,Z5,Z7,tanb);
-  
+
   return params_set;
 }
 
- 
 
-// Hybrid basis from 1507.04281 (but with sba as the input) 
+
+// Hybrid basis from 1507.04281 (but with sba as the input)
 bool THDM::set_param_hybrid_sba(double mh, double mH, double sba, double Z4,
 			   double Z5, double Z7, double tanb) {
 
@@ -421,7 +475,7 @@
 
   bool params_set = true;
   double vsmall = 1E-10;
-  
+
   if ((mh<0)||(abs(sba) > 1)||(abs(mh-mH)<vsmall)||(abs(tanb-1.)<vsmall)) {
     params_set = false;
     return params_set;
@@ -431,7 +485,7 @@
   double v2 = sm.get_v2();
 
   double Z6 = (pow(mh,2)-pow(mH,2))*cba*sba/v2;
-  
+
   Lambda1 = 0.;
   Lambda2 = 0.;
   Lambda3 = 0.;
@@ -442,18 +496,18 @@
 
   // Lambda1 fixed from Higgs masses
   Lambda1 = (mh*mh*sba*sba+mH*mH*cba*cba)/v2;
-  
+
   double Lambda345;
 
   double t2b = 2.*tanb/(1.-tanb*tanb);
-  
+
   if (abs(tanb-1.0)>vsmall) {
 
 	// Lambda2 fixed from requested tan(beta) value
    	Lambda2 = Lambda1 + 2*(Z6+Z7)/t2b;
-  	
+
   	// Only one value of Lambda345 compatible with softly broken Z2 symmetry
-	Lambda345 = Lambda1+2.*Z6/t2b-(Z6-Z7)*t2b;  		
+	Lambda345 = Lambda1+2.*Z6/t2b-(Z6-Z7)*t2b;
 	Lambda3 = Lambda345-Lambda4-Lambda5;
   } else {
     cout << "The point tanb=1 is problematic." << endl;
@@ -471,10 +525,10 @@
   // First set the potential of 2HDM using input in the Higgs basis
   params_set = set_param_higgs(Lambda1, Lambda2, Lambda3, Lambda4, Lambda5, Lambda6, Lambda7, mHp);
 
-  // Recalculate internal state from Higgs basis to desired tanb value 
+  // Recalculate internal state from Higgs basis to desired tanb value
   // (where lambda6=lambda7=0 is manifest).
   if (params_set) recalc_tan_beta(tanb);
-  
+
   return params_set;
 }
 
@@ -485,7 +539,7 @@
     params_set = false;
     return params_set;
   }
-  
+
   double v2 = sm.get_v2()/2;
 
   lambda[1]=0.5*pow(m_h,2)/v2;
@@ -497,7 +551,7 @@
   lambda[7]=0.0;
   beta=0;
   m22_2=m_Hp*m_Hp-lambda3*v2;
-  
+
   if (m_h>m_H) {
     sinba = 0.;
   } else {
@@ -507,6 +561,7 @@
   set_yukawas_inert();
 
   params_set = true;
+  params_full_set=false;
   return params_set;
 }
 
@@ -521,7 +576,7 @@
    bool pset = set_param_phys(mh,mA,mA,mA,1., 0., 0., m12_2_sm, 1.);
 
    set_yukawas_type(1);
-   
+
    return pset;
 
 }
@@ -553,7 +608,7 @@
   m12_2=mA*mA*cb*sb;
 
   double pset = set_param_gen(l1,l2,l3,l4,l5,l6,l7,m12_2,tan_beta);
-  
+
   if (pset) set_yukawas_type(2);
 
   return pset;
@@ -575,7 +630,7 @@
   double cb2 = cb*cb;
   double sb2 = sb*sb;
   double m_A2 = mA*mA;
-  
+
   double g = sm.get_g();
   double gp = sm.get_gprime();
 
@@ -587,13 +642,13 @@
   l6 = 0.;
   l7 = 0.;
   m12_2=mA*mA*cb*sb;
-  
+
   double m_h2 = 0.;
   double dm = 1.E-5;
-  
-  
+
+
   while ((abs(sqrt(m_h2)-mh)>dm)&&(l2 < 4.*M_PI)) {
-  
+
   	double M112   =  m_A2*sb2+v2*(l1*cb2);
    	double M122   = -m_A2*sb*cb+v2*(l3+l4)*sb*cb;
    	double M222   =  m_A2*cb2+v2*l2*sb2;
@@ -623,7 +678,7 @@
 void THDM::set_kappa_D() {
   gsl_matrix *md = sm.get_MD();
   gsl_matrix_memcpy(kappa_D,md);
-  gsl_matrix_scale(kappa_D,sqrt(2)/sm.get_v());  
+  gsl_matrix_scale(kappa_D,sqrt(2)/sm.get_v());
   gsl_matrix_free(md);
 }
 
@@ -685,7 +740,7 @@
     gsl_matrix_scale(rho_U,1./tan(beta));
     gsl_matrix_scale(rho_L,-tan(beta));
   }
-  
+
 }
 
 
@@ -844,12 +899,12 @@
   double kd_pole=gsl_matrix_get(kappa_D,0,0);
   double ks_pole=gsl_matrix_get(kappa_D,1,1);
   double kb_pole=gsl_matrix_get(kappa_D,2,2);
-  
+
    double mb_mb = sm.get_qmass_MSbar(5);
   double mb_pole = sm.get_qmass_pole(5);
-    
+
   double mb_run = sm.run_qmass_MSbar(mb_mb,mb_mb,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
+
   kd = kd_pole;
   ks = ks_pole;
   kb = kb_pole/mb_pole*mb_run;
@@ -859,15 +914,15 @@
   double ku_pole=gsl_matrix_get(kappa_U,0,0);
   double kc_pole=gsl_matrix_get(kappa_U,1,1);
   double kt_pole=gsl_matrix_get(kappa_U,2,2);
-  
+
   double mt_mt = sm.get_qmass_MSbar(6);
   double mc_mc = sm.get_qmass_MSbar(4);
   double mc_pole = sm.get_qmass_pole(4);
   double mt_pole = sm.get_qmass_pole(6);
-    
-  double mc_run = sm.run_qmass_MSbar(mc_mc,mc_mc,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));  
+
+  double mc_run = sm.run_qmass_MSbar(mc_mc,mc_mc,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
   double mt_run = sm.run_qmass_MSbar(mt_mt,mt_mt,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
+
   ku = ku_pole;
   kc = kc_pole/mc_pole*mc_run;
   kt = kt_pole/mt_pole*mt_run;
@@ -882,12 +937,12 @@
   double rd_pole=gsl_matrix_get(rho_D,0,0);
   double rs_pole=gsl_matrix_get(rho_D,1,1);
   double rb_pole=gsl_matrix_get(rho_D,2,2);
-  
+
   double mb_mb = sm.get_qmass_MSbar(5);
   double mb_pole = sm.get_qmass_pole(5);
-    
+
   double mb_run = sm.run_qmass_MSbar(mb_mb,mb_mb,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
+
   rd = rd_pole;
   rs = rs_pole;
   rb = rb_pole/mb_pole*mb_run;
@@ -897,15 +952,15 @@
   double ru_pole=gsl_matrix_get(rho_U,0,0);
   double rc_pole=gsl_matrix_get(rho_U,1,1);
   double rt_pole=gsl_matrix_get(rho_U,2,2);
-  
+
   double mt_mt = sm.get_qmass_MSbar(6);
   double mc_mc = sm.get_qmass_MSbar(4);
   double mc_pole = sm.get_qmass_pole(4);
   double mt_pole = sm.get_qmass_pole(6);
-    
-  double mc_run = sm.run_qmass_MSbar(mc_mc,mc_mc,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));  
+
+  double mc_run = sm.run_qmass_MSbar(mc_mc,mc_mc,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
   double mt_run = sm.run_qmass_MSbar(mt_mt,mt_mt,mu,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
+
   ru = ru_pole;
   rc = rc_pole/mc_pole*mc_run;
   rt = rt_pole/mt_pole*mt_run;
@@ -939,7 +994,7 @@
 
 
 void THDM::get_param_gen(double &lambda1, double &lambda2, double &lambda3,
-			 double &lambda4, double &lambda5, double &lambda6, 
+			 double &lambda4, double &lambda5, double &lambda6,
 			 double &lambda7, double &m12_2,double &tan_beta) {
   lambda1=lambda[1];
   lambda2=lambda[2];
@@ -954,7 +1009,7 @@
 
 
 void THDM::get_param_HHG(double &Lambda1, double &Lambda2, double &Lambda3,
-			 double &Lambda4, double &Lambda5, double &Lambda6, 
+			 double &Lambda4, double &Lambda5, double &Lambda6,
 			 double &tan_beta) {
 
   double sb=sin(beta);
@@ -983,38 +1038,50 @@
   lambda6=lambda[6];
   lambda7=lambda[7];
   tan_beta=tan(beta);
-  double sb  = sin(beta);
-  double sb2 = sb*sb;
-  double cb	 = cos(beta);
-  double cb2 = cb*cb;
-  double tb	 = tan(beta);
-  double ctb = 1./tb;
-  double m_A2;
-  m12_2=get_m12_2();
-  if (tan_beta>0) {
-    m_A2=m12_2/sb/cb-0.5*v2*(2*lambda[5]+lambda[6]*ctb+lambda[7]*tb);
-  } else { 
-    m_A2=m22_2+0.5*v2*(lambda[3]+lambda[4]-lambda[5]);
-  }
-  double m_Hp2  =  m_A2+0.5*v2*(lambda[5]-lambda[4]);
-  double M112   =  m_A2*sb2+v2*(lambda[1]*cb2+2.*lambda[6]*sb*cb+lambda[5]*sb2);
-  double M122   = -m_A2*sb*cb+v2*((lambda[3]+lambda[4])*sb*cb+lambda[6]*cb2+lambda[7]*sb2);
-  double M222   =  m_A2*cb2+v2*(lambda[2]*sb2+2.*lambda[7]*sb*cb+lambda[5]*cb2);
-  double m_h2   =  0.5*(M112+M222-sqrt((M112-M222)*(M112-M222)+4.*M122*M122));
-  double m_H2   =  0.5*(M112+M222+sqrt((M112-M222)*(M112-M222)+4.*M122*M122));
-  
-  sba = sinba;
-
-  // Sanity checks. Masses set negative in case of troubles
-  if (m_h2>0)   m_h=sqrt(m_h2);   else m_h=-sqrt(-m_h2);
-  if (m_H2>0)   m_H=sqrt(m_H2);   else m_H=-sqrt(-m_H2);
-  if (m_A2>0)   m_A=sqrt(m_A2);   else m_A=-sqrt(-m_A2);
-  if (m_Hp2>0)  m_Hp=sqrt(m_Hp2); else m_Hp=-sqrt(-m_Hp2);
+
+  if (params_full_set) {
+    m_h = this->m_h;
+    m_H = this->m_H;
+    m_A = this->m_A;
+    m_Hp = this->m_Hp;
+    m12_2 = this->m12_2;
+    sba = sinba;
+  }
+  else {
+  // original tree-level conversion below
+    double sb  = sin(beta);
+    double sb2 = sb*sb;
+    double cb	 = cos(beta);
+    double cb2 = cb*cb;
+    double tb	 = tan(beta);
+    double ctb = 1./tb;
+    double m_A2;
+    m12_2=get_m12_2();
+    if (tan_beta>0) {
+      m_A2=m12_2/sb/cb-0.5*v2*(2*lambda[5]+lambda[6]*ctb+lambda[7]*tb);
+    } else {
+      m_A2=m22_2+0.5*v2*(lambda[3]+lambda[4]-lambda[5]);
+    }
+    double m_Hp2  =  m_A2+0.5*v2*(lambda[5]-lambda[4]);
+    double M112   =  m_A2*sb2+v2*(lambda[1]*cb2+2.*lambda[6]*sb*cb+lambda[5]*sb2);
+    double M122   = -m_A2*sb*cb+v2*((lambda[3]+lambda[4])*sb*cb+lambda[6]*cb2+lambda[7]*sb2);
+    double M222   =  m_A2*cb2+v2*(lambda[2]*sb2+2.*lambda[7]*sb*cb+lambda[5]*cb2);
+    double m_h2   =  0.5*(M112+M222-sqrt((M112-M222)*(M112-M222)+4.*M122*M122));
+    double m_H2   =  0.5*(M112+M222+sqrt((M112-M222)*(M112-M222)+4.*M122*M122));
+
+    sba = sinba;
+
+    // Sanity checks. Masses set negative in case of troubles
+    if (m_h2>0)   m_h=sqrt(m_h2);   else m_h=-sqrt(-m_h2);
+    if (m_H2>0)   m_H=sqrt(m_H2);   else m_H=-sqrt(-m_H2);
+    if (m_A2>0)   m_A=sqrt(m_A2);   else m_A=-sqrt(-m_A2);
+    if (m_Hp2>0)  m_Hp=sqrt(m_Hp2); else m_Hp=-sqrt(-m_Hp2);
+    }
 }
 
 
 void THDM::get_param_higgs(double &Lambda1, double &Lambda2, double &Lambda3,
-			   double &Lambda4, double &Lambda5, double &Lambda6, 
+			   double &Lambda4, double &Lambda5, double &Lambda6,
 			   double &Lambda7, double &m_Hp) {
 
   double sb=sin(beta);
@@ -1044,20 +1111,20 @@
   double m12_2 = get_m12_2();
   double m11_2 = m12_2*tb-0.5*v2*(lambda[1]*cb2+(lambda[3]+lambda[4]+lambda[5])*sb2+3.*lambda[6]*sb*cb+lambda[7]*sb2*tb);
   double M22_2 = m11_2*sb2+m22_2*cb2+m12_2*s2b;
-  
+
   m_Hp=sqrt(M22_2+0.5*v2*Lambda3);
 }
 
 
 void THDM::get_param_hybrid(double &m_h, double &m_H, double &cba,
 			   double &Z4, double &Z5, double &Z7, double &tan_beta) {
-   
+
    double Lambda1,Lambda2,Lambda3,Lambda4,Lambda5,Lambda6,Lambda7,mHp;
-   
+
    get_param_higgs(Lambda1,Lambda2,Lambda3,Lambda4,Lambda5,Lambda6,Lambda7,mHp);
-   
+
    double mh,mH,mA,sinba,lam6,lam7,m12_2,tb;
-   
+
    get_param_phys(mh,mH,mA,mHp,sinba,lam6,lam7,m12_2,tb);
    if ((abs(lam6)>EPS)||(abs(lam7)>EPS)) {
     printf("\nWARNING: Model has hard Z_2-violation\n");
@@ -1140,7 +1207,7 @@
   cp = 0.;
 
   if ((h<1)||(h>3)) return;
-  
+
   double sba = get_sba();
   double cba = get_cba();
 
@@ -1151,7 +1218,7 @@
     if (f1==f2) {
       double mms  = sm.get_dmass_MSbar(f1);
       double mp   = sm.get_dmass_pole(f1);
-      
+
       // Starting scale for MSbar mass evolution
       double Qinit = mms;
       if (f1==2) {
@@ -1161,7 +1228,7 @@
 
       // Starting scale for MSbar mass evolution for comp with HD
       if(sm.b_HD) Qinit = SM::Q_HD;
-       
+
       double mrun = sm.run_qmass_MSbar(mms,Qinit,get_hmass(h),sm.get_qmass_pole(6),sm.get_qmass_pole(5));
 
       if (mrun>0) {
@@ -1184,7 +1251,7 @@
       y = -I*I/sqrt(2.)*rd;
       break;
     }
-  
+
     cs = x;
     cp = y;
   }
@@ -1200,7 +1267,7 @@
 
 
   if ((h<1)||(h>3)) return;
-  
+
   double sba = get_sba();
   double cba = get_cba();
 
@@ -1222,7 +1289,7 @@
         ru = ru/mp*mrun;
       }
     }
-    
+
     switch(h) {
     case 1:
       x = -I/sqrt(2.)*(ku*sba+ru*cba);
@@ -1237,7 +1304,7 @@
       y = -I*(-I/sqrt(2.))*ru;
       break;
     }
-  
+
     cs = x;
     cp = y;
 
@@ -1253,7 +1320,7 @@
   cp = 0.;
 
   if ((h<1)||(h>3)) return;
-  
+
   double sba = get_sba();
   double cba = get_cba();
 
@@ -1275,7 +1342,7 @@
       y = -I*I/sqrt(2.)*rl;
       break;
     }
-  
+
     cs = x;
     cp = y;
   }
@@ -1292,11 +1359,11 @@
   gsl_matrix* ckm = sm.get_CKM_matrix();
 
   if (h!=4) return;
-  
+
   double mHp = get_hmass(4);
 
-  if ((u<=3)&&(u>=1)&&(d<=3)&&(d>=1)) {    
-    gsl_matrix *RD = gsl_matrix_alloc(3,3); 
+  if ((u<=3)&&(u>=1)&&(d<=3)&&(d>=1)) {
+    gsl_matrix *RD = gsl_matrix_alloc(3,3);
     gsl_matrix *RU = gsl_matrix_alloc(3,3);
 
     gsl_matrix_view A = gsl_matrix_submatrix(ckm,0,0,3,3);
@@ -1304,7 +1371,7 @@
     gsl_blas_dgemm(CblasNoTrans,CblasNoTrans,1.0, &A.matrix, &B.matrix,0.0,RD);
     B = gsl_matrix_submatrix(rho_U,0,0,3,3);
     gsl_blas_dgemm(CblasConjTrans,CblasNoTrans,1.0, &B.matrix, &A.matrix,0.0,RU);
-  
+
     double rd = gsl_matrix_get(RD,u-1,d-1);
     double ru = gsl_matrix_get(RU,u-1,d-1);
     gsl_matrix_free(RD);
@@ -1317,7 +1384,7 @@
     double mdp   = sm.get_dmass_pole(d);
     double mums  = sm.get_umass_MSbar(u);
     double mup   = sm.get_umass_pole(u);
-    
+
     // Special case for strange quark not defined as ms(ms)
     if (d==2) {
      Qinit = SM::Q_ms;
@@ -1331,15 +1398,15 @@
     // Starting scale for MSbar mass evolution for comp with HD
     if(sm.b_HD) Qinit = SM::Q_HD;
     double murun = sm.run_qmass_MSbar(mums,Qinit,mHp,sm.get_qmass_pole(6),sm.get_qmass_pole(5));
-  
-    
+
+
     if (mdrun>0) {
       rd = rd/mdp*mdrun;
     }
     if (murun>0) {
       ru = ru/mup*murun;
     }
-    
+
     cs = -I*0.5*(rd-ru);
     cp = -I*0.5*(rd+ru);
   }
@@ -1356,8 +1423,8 @@
   cp = 0.;
 
   if (h!=4) return;
-  
-  if ((n<=3)&&(n>=1)&&(l<=3)&&(l>=1)) {    
+
+  if ((n<=3)&&(n>=1)&&(l<=3)&&(l>=1)) {
     double rl = gsl_matrix_get(rho_L,n-1,l-1);
     double rn = gsl_matrix_get(rho_N,n-1,l-1);
 
@@ -1370,19 +1437,19 @@
 void THDM::get_coupling_vhh(int v,int h1,int h2,complex <double> &c) {
   // Convention of hep-ph/0602242
   complex <double> I(0.0,1.0);
-  
+
   double e=sm.get_e();
   double g=sm.get_g();
   double costw=sm.get_costw();
   double cos2tw=cos(2.*acos(costw));
-  
+
   c=0;
   if (h1>h2) {
     int tmp=h1;
     h1=h2;
     h2=tmp;
   }
-  
+
   // gamma
   if (v==1) {
     if ((h1==4)&&(h2==4))
@@ -1398,7 +1465,7 @@
   // W+  (to get coupling for W- take complex conjugate)
   if ((v==3)&&(h1<4)&&(h2==4)) {
     c=conj(-I*g/2.*get_qki(h1,2));
-  }  
+  }
 
 }
 
@@ -1406,14 +1473,14 @@
 void THDM::get_coupling_vvh(int v1,int v2,int h,complex <double> &c) {
   // Convention of hep-ph/0602242
   complex <double> I(0.0,1.0);
-  
+
   double g=sm.get_g();
   double costw=sm.get_costw();
   double MW=sm.get_MW();
   double MZ=sm.get_MZ();
-  
+
   c=0;
-  
+
   // Z Z
   if ((v1==2)&&(v2==2)&&(h<4)) {
     c=I*g/costw*MZ*real(get_qki(h,1));
@@ -1429,12 +1496,12 @@
 void THDM::get_coupling_vvhh(int v1,int v2,int h1,int h2,complex <double> &c) {
   // Convention of hep-ph/0602242
   complex <double> I(0.0,1.0);
-  
+
   double g=sm.get_g();
   double e=sm.get_e();
   double costw=sm.get_costw();
   double cos2tw=cos(2.*acos(costw));
-  
+
   c=0;
   if (v1>v2) {
     int tmp=v1;
@@ -1446,7 +1513,7 @@
     h1=h2;
     h2=tmp;
   }
-  
+
   // Z Z h/H/A h/H/A
   if ((v1==2)&&(v2==2)&&(h1<4)&&(h2<4)){
     c=I/2.*g*g/costw/costw*real(conj(get_qki(h1,1))*get_qki(h2,1)+conj(get_qki(h1,2))*get_qki(h2,2));
@@ -1485,12 +1552,12 @@
 void THDM::get_coupling_hhh(int h1,int h2,int h3,complex <double> &c) {
   // Conventions are according to hep-ph/0602242
   complex <double> I(0.0,1.0);
-  
+
   double Z1,Z2,Z3,Z4,Z5,l6,l7,m_Hp;
   get_param_higgs(Z1,Z2,Z3,Z4,Z5,l6,l7,m_Hp);
   double Z6=-l6,Z7=-l7;
   double v=sm.get_v();
-  
+
   c=0;
   if (h1>h2) {
     int tmp=h1;
@@ -1532,7 +1599,7 @@
 		  real(conj(get_qki(h[0],2))*get_qki(h[1],2)*get_qki(h[2],2)*Z7));
     }
   // Neutral and charged higgses
-  if ((h1<4)&&(h2==4)&&(h3==4)) 
+  if ((h1<4)&&(h2==4)&&(h3==4))
     c=-I*v*(real(get_qki(h1,1)*Z3+real(get_qki(h1,2)*Z7)));
 
   gsl_permutation_free (per);
@@ -1542,11 +1609,11 @@
 void THDM::get_coupling_hhhh(int h1,int h2,int h3,int h4,complex <double> &c) {
   // Conventions are according to hep-ph/0602242
   complex <double> I(0.0,1.0);
-  
+
   double Z1,Z2,Z3,Z4,Z5,l6,l7,m_Hp;
   get_param_higgs(Z1,Z2,Z3,Z4,Z5,l6,l7,m_Hp);
   double Z6=-l6,Z7=-l7;
-  
+
   c=0;
   if (h1>h2) {
     int tmp=h1;
@@ -1636,7 +1703,7 @@
   // S-Matrices from Ginzburg and Ivanov, hep-ph/0508020
   double S20 = lambda[3]-lambda[4];
   if (abs(S20) > abs(egmax)) egmax = S20;
-  
+
   double s2 = sqrt(2.);
 
   double S21_data[] = { lambda[1],    lambda[5],    s2*lambda[6],
@@ -1660,7 +1727,7 @@
   gsl_eigen_symm_workspace *w3 = gsl_eigen_symm_alloc(3);
   gsl_eigen_symm_workspace *w4 = gsl_eigen_symm_alloc(4);
   gsl_vector *eval3 = gsl_vector_alloc(3);
-  gsl_vector *eval4 = gsl_vector_alloc(4);    
+  gsl_vector *eval4 = gsl_vector_alloc(4);
 
   double eg = 0.0;
 
@@ -1670,7 +1737,7 @@
     eg = gsl_vector_get(eval3,i);
     if (abs(eg)>abs(egmax)) egmax = eg;
   }
-  
+
   gsl_eigen_symm(&S01.matrix,eval4,w4);
   for (int i=0;i<4;i++) {
     eg = gsl_vector_get(eval4,i);
@@ -1749,7 +1816,7 @@
   if (lambda[3]<-sqrt(lambda[1]*lambda[2])) return false;
   // Check for cos(theta)=0
   if (lambda[3]+lambda[4]-lambda[5]<-sqrt(lambda[1]*lambda[2])) return false;
-  if ((abs(lambda[6])<EPS)&&(abs(lambda[7])<EPS)) { 
+  if ((abs(lambda[6])<EPS)&&(abs(lambda[7])<EPS)) {
     // Check if lambda6 and lambda7 are zero
     if (lambda[3]+lambda[4]-abs(lambda[5])<-sqrt(lambda[1]*lambda[2])) return false;
     // No more conditions exist if lambda6 and lambda7 are zero
@@ -1761,7 +1828,7 @@
   gamma=acos(sqrt((4*lambda[6]*lambda[7]-2*lambda[4]*lambda[3]+lambda[4]*lambda[2]+lambda[4]*lambda[1]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]+lambda[1]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7])*(-2*lambda[7]*lambda[7]+lambda[2]*lambda[5]+lambda[4]*lambda[2]-lambda[3]*lambda[5]-lambda[4]*lambda[3]+2*lambda[6]*lambda[7]))/(4*lambda[6]*lambda[7]-2*lambda[4]*lambda[3]+lambda[4]*lambda[2]+lambda[4]*lambda[1]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]+lambda[1]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7]));
   rho=sin(gamma)*(lambda[7]-cos(gamma)*cos(gamma)*lambda[7]+lambda[6]*cos(gamma)*cos(gamma))/(cos(gamma)*(-lambda[5]-lambda[4]+cos(gamma)*cos(gamma)*lambda[4]+cos(gamma)*cos(gamma)*lambda[5]));
   // Check abs(rho) [0,1]
-  if ((abs(rho)<=1.) && 
+  if ((abs(rho)<=1.) &&
       // Check gamma [0,Pi/2]
       ((gamma>=0.) && (gamma<=M_PI/2.)) &&
       ((1./2.)*(-lambda[4]*lambda[3]*lambda[3]+lambda[4]*lambda[2]*lambda[1]-lambda[3]*lambda[3]*lambda[5]+lambda[2]*lambda[1]*lambda[5]-2*lambda[7]*lambda[7]*lambda[1]+4*lambda[6]*lambda[7]*lambda[3]-2*lambda[2]*lambda[6]*lambda[6])/(lambda[4]*lambda[1]+lambda[4]*lambda[2]-2*lambda[4]*lambda[3]+lambda[1]*lambda[5]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7]+4*lambda[6]*lambda[7])<0))
@@ -1770,17 +1837,17 @@
   gamma=M_PI-acos(sqrt((4*lambda[6]*lambda[7]-2*lambda[4]*lambda[3]+lambda[4]*lambda[2]+lambda[4]*lambda[1]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]+lambda[1]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7])*(-2*lambda[7]*lambda[7]+lambda[2]*lambda[5]+lambda[4]*lambda[2]-lambda[3]*lambda[5]-lambda[4]*lambda[3]+2*lambda[6]*lambda[7]))/(4*lambda[6]*lambda[7]-2*lambda[4]*lambda[3]+lambda[4]*lambda[2]+lambda[4]*lambda[1]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]+lambda[1]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7]));
   rho=sin(gamma)*(lambda[7]-cos(gamma)*cos(gamma)*lambda[7]+lambda[6]*cos(gamma)*cos(gamma))/(cos(gamma)*(-lambda[5]-lambda[4]+cos(gamma)*cos(gamma)*lambda[4]+cos(gamma)*cos(gamma)*lambda[5]));
   // Check abs(rho) [0,1]
-  if ((abs(rho)<=1.) && 
+  if ((abs(rho)<=1.) &&
       // Check gamma [0,Pi/2]
       ((gamma>=0.) && (gamma<=M_PI/2.)) &&
       ((1./2.)*(-lambda[4]*lambda[3]*lambda[3]+lambda[4]*lambda[2]*lambda[1]-lambda[3]*lambda[3]*lambda[5]+lambda[2]*lambda[1]*lambda[5]-2*lambda[7]*lambda[7]*lambda[1]+4*lambda[6]*lambda[7]*lambda[3]-2*lambda[2]*lambda[6]*lambda[6])/(lambda[4]*lambda[1]+lambda[4]*lambda[2]-2*lambda[4]*lambda[3]+lambda[1]*lambda[5]-2*lambda[3]*lambda[5]+lambda[2]*lambda[5]-2*lambda[6]*lambda[6]-2*lambda[7]*lambda[7]+4*lambda[6]*lambda[7])<0))
     return false;
-  
+
   // Check for rho=1 and ct!=+-1
   ct=(1./2.)*(-lambda[6]*lambda[3]-lambda[6]*lambda[4]+lambda[6]*lambda[2]+lambda[5]*lambda[6]+lambda[7]*lambda[1]-lambda[7]*lambda[3]-lambda[7]*lambda[4]+lambda[7]*lambda[5])/sqrt((-lambda[3]*lambda[5]-lambda[5]*lambda[4]+lambda[2]*lambda[5]+lambda[5]*lambda[5]+lambda[6]*lambda[7]-lambda[7]*lambda[7])*(lambda[1]*lambda[5]+lambda[6]*lambda[7]-lambda[3]*lambda[5]+lambda[5]*lambda[5]-lambda[5]*lambda[4]-lambda[6]*lambda[6]));
   gamma=atan(sqrt((-lambda[3]*lambda[5]-lambda[5]*lambda[4]+lambda[2]*lambda[5]+lambda[5]*lambda[5]+lambda[6]*lambda[7]-lambda[7]*lambda[7])*(lambda[1]*lambda[5]+lambda[6]*lambda[7]-lambda[3]*lambda[5]+lambda[5]*lambda[5]-lambda[5]*lambda[4]-lambda[6]*lambda[6]))/(-lambda[3]*lambda[5]-lambda[5]*lambda[4]+lambda[2]*lambda[5]+lambda[5]*lambda[5]+lambda[6]*lambda[7]-lambda[7]*lambda[7]));
   // Check ct [-1,1]
-  if ((abs(ct)<=1.) && 
+  if ((abs(ct)<=1.) &&
       // Check abs(gamma) [0,Pi/2]
       (abs(gamma)<=M_PI/2.) &&
       // Check stability
@@ -1878,7 +1945,7 @@
       if ((stability_minimum(p32))&&(p32.v<0)) return false;
     }
   }
-  
+
   return true;
 
 }
@@ -1902,10 +1969,10 @@
 
   fprintf(output,"##################################################################\n");
   fprintf(output,"#                                                                #\n");
-  fprintf(output,"#                 Two-Higgs Doublet Model Output                 #\n");    
+  fprintf(output,"#                 Two-Higgs Doublet Model Output                 #\n");
   fprintf(output,"#          Produced by 2HDMC: http://2hdmc.hepforge.org          #\n");
   fprintf(output,"#                                                                #\n");
-  fprintf(output,"##################################################################\n");  
+  fprintf(output,"##################################################################\n");
   fprintf(output,"Block MODSEL # Select Model\n");
   fprintf(output,"    0   10    #  10 = 2HDM\n");
   fprintf(output,"Block FMODSEL # FLHA definitions, see [arXiv:1008.0762]\n");
@@ -1997,53 +2064,53 @@
   (k1>0 ? lu[1][1] = r1/k1 : lu[1][1]=0.);
   (k2>0 ? lu[2][2] = r2/k2 : lu[2][2]=0.);
   (k3>0 ? lu[3][3] = r3/k3 : lu[3][3]=0.);
-  
+
   get_kappa_down(k1,k2,k3);
   get_yukawas_down(r1,r2,r3);
   (k1>0 ? ld[1][1] = r1/k1 : ld[1][1]=0.);
   (k2>0 ? ld[2][2] = r2/k2 : ld[2][2]=0.);
   (k3>0 ? ld[3][3] = r3/k3 : ld[3][3]=0.);
-  
+
   get_kappa_lepton(k1,k2,k3);
   get_yukawas_lepton(r1,r2,r3);
   (k1>0 ? ll[1][1] = r1/k1 : ll[1][1]=0.);
   (k2>0 ? ll[2][2] = r2/k2 : ll[2][2]=0.);
   (k3>0 ? ll[3][3] = r3/k3 : ll[3][3]=0.);
-  
-  
+
+
   fprintf(output,"Block UCOUPL\n");
   for (int i=1;i<=3;i++) {
     for (int j=1;j<=3;j++) {
        fprintf(output,"%5d%6d   % 16.8e   # LU_{%d,%d}\n",i,j,lu[i][j],i,j);
     }
   }
-  
+
   fprintf(output,"Block DCOUPL\n");
   for (int i=1;i<=3;i++) {
     for (int j=1;j<=3;j++) {
        fprintf(output,"%5d%6d   % 16.8e   # LD_{%d,%d}\n",i,j,ld[i][j],i,j);
     }
   }
-  
+
   fprintf(output,"Block LCOUPL\n");
   for (int i=1;i<=3;i++) {
     for (int j=1;j<=3;j++) {
        fprintf(output,"%5d%6d   % 16.8e   # LL_{%d,%d}\n",i,j,ll[i][j],i,j);
     }
   }
-  
+
 #if defined HiggsBounds
 
   if (HBHS) {
-  
+
   int hbres[6];
   double hbobs[6];
   int hbchan[6];
-  int hbcomb[6]; 
-  
+  int hbcomb[6];
+
   HB_set_input_effC(*this);
   HB_run_full(hbres, hbchan, hbobs, hbcomb);
-  
+
   fprintf(output, "Block HBRESULT\n");
   fprintf(output, "# Higgs  Result  Channel    Obsratio      Ncomb\n");
   fprintf(output, "%5d   %5d   %6d %16.8E %5d    # Full result\n", 0, hbres[0],hbchan[0],hbobs[0],hbcomb[0]);
@@ -2051,27 +2118,27 @@
   fprintf(output, "%5d   %5d   %6d %16.8E %5d    # H\n",  2, hbres[2],hbchan[2],hbobs[2],hbcomb[2]);
   fprintf(output, "%5d   %5d   %6d %16.8E %5d    # A\n",  3, hbres[3],hbchan[3],hbobs[3],hbcomb[3]);
   fprintf(output, "%5d   %5d   %6d %16.8E %5d    # H+\n", 4, hbres[4],hbchan[4],hbobs[4],hbcomb[4]);
-  
+
   double csqmu;
   double csqmh;
   double csqtot;
   int nobs;
   double pval;
-   
+
   HS_run(&csqmu, &csqmh, &csqtot, &nobs, &pval);
-  
+
   fprintf(output, "Block HSRESULT\n");
   fprintf(output, " %5d %16.8E # Total HS chi^2 \n", 0, csqtot);
   fprintf(output, " %5d %16.8E # chi^2 from rates\n", 1, csqmu);
   fprintf(output, " %5d %16.8E # chi^2 from mass\n", 2, csqmh);
   fprintf(output, " %5d %16d # Number of observables\n", 3, nobs);
-  
+
   }
 
 #endif
 
 
-  DecayTable table(*this);
+  DecayTableTHDM table(*this);
   table.set_qcd(qcd_on);
   fprintf(output,"#     PDG   Width\n");
   table.print_top_decays_LesHouches(output,fulldecay);
@@ -2087,7 +2154,7 @@
 
     complex <double> c1;
     complex <double> c2;
- 
+
     fprintf(output,"BLOCK MGUSER\n");
     get_coupling_hll(1,1,1,c1,c2);
     fprintf(output,"         1     % 16.8e   # REPLGH1EE   , Real part of scalar part of h1ee coupling\n",real(c1));
@@ -2416,7 +2483,7 @@
   }
 
   fclose(output);
-  
+
   printf("LesHouches output written to file %s\n", file);
 }
 
@@ -2430,7 +2497,7 @@
   for (int i=0;i<8;i++)  lambda[i] = 0.;
   for (int i=0;i<40;i++) masses[i] = 0.;
   for (int i=0;i<32;i++) par[i] = false;
-  
+
   int     model     = -1;
   double  tb        = 0.;
   double  m12_2     = 0.;
@@ -2504,7 +2571,7 @@
 	  if (ncmd==24) type = (int)x;
 	  if (ncmd<32) par[ncmd] = true;
 	}
-      
+
 	if (block=="MASS") {
 	  ss >> x;
 	  if (ncmd<40) masses[ncmd]=x;
@@ -2522,7 +2589,7 @@
   for (int i=1;i<=6;i++) {
     if (masses[i]>0) sm.set_qmass_pole(i,masses[i]);
   }
-  
+
   if (masses[11]>0) sm.set_lmass_pole(1,masses[11]);
   if (masses[13]>0) sm.set_lmass_pole(2,masses[13]);
   if (masses[15]>0) sm.set_lmass_pole(3,masses[15]);
@@ -2552,7 +2619,7 @@
   }
 
   return pset;
-  
+
 }
 
 
@@ -2576,7 +2643,7 @@
 
 
 void THDM::print_param_gen() {
-  double lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,tan_beta,m12_2;  
+  double lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,tan_beta,m12_2;
   get_param_gen(lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,m12_2,tan_beta);
 
   printf("\n2HDM parameters in generic basis:\n");
@@ -2586,15 +2653,15 @@
   printf(" lambda_4: %12.5f\n",lambda4);
   printf(" lambda_5: %12.5f\n",lambda5);
   printf(" lambda_6: %12.5f\n",lambda6);
-  printf(" lambda_7: %12.5f\n",lambda7);  
+  printf(" lambda_7: %12.5f\n",lambda7);
   printf("    m12^2: %12.5f\n",m12_2);
   printf("tan(beta): %12.5f\n",tan_beta);
 }
 
 void THDM::print_param_hybrid() {
-  double mh,mH,cba,tb,Z4,Z5,Z7;  
+  double mh,mH,cba,tb,Z4,Z5,Z7;
   get_param_hybrid(mh,mH,cba,Z4,Z5,Z7,tb);
-  double lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,tan_beta,m12_2;  
+  double lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,tan_beta,m12_2;
   get_param_gen(lambda1,lambda2,lambda3,lambda4,lambda5,lambda6,lambda7,m12_2,tan_beta);
 
   printf("\n2HDM parameters in Hybrid basis:\n");
@@ -2607,8 +2674,8 @@
   printf(" cos(b-a): %12.5f\n",cba);
   printf("       Z4: %12.5f\n",Z4);
   printf("       Z5: %12.5f\n",Z5);
-  printf("       Z7: %12.5f\n",Z7); 
-  printf("tan(beta): %12.5f\n",tb); 
+  printf("       Z7: %12.5f\n",Z7);
+  printf("tan(beta): %12.5f\n",tb);
 }
 
 void THDM::print_hdecay() {
@@ -2616,7 +2683,7 @@
   get_param_phys(mh,mH,mA,mHp,sba,lambda6,lambda7,m12_2,tan_beta);
 
   alpha = -asin(sba)+atan(tan_beta);
- 
+
   printf("\n2HDM output for HDECAY\n");
   printf(" *************************** 2 Higgs Doublet Model **************************\n");
   printf(" TYPE; 1 (I), 2 (II)\n");
@@ -2659,7 +2726,7 @@
   printf("     m_H+: %12.5f\n",mHp);
   printf(" sin(b-a): %12.5f\n",sba);
   printf(" lambda_6: %12.5f\n",lambda6);
-  printf(" lambda_7: %12.5f\n",lambda7);  
+  printf(" lambda_7: %12.5f\n",lambda7);
   printf("    m12^2: %12.5f\n",m12_2);
   printf("tan(beta): %12.5f\n",tan_beta);
 }
@@ -2681,23 +2748,29 @@
 
 
 double THDM::get_m12_2() {
-  //hep-ph/0207010
-  double sb=sin(beta);
-  double sb2=sb*sb;
-  double cb=cos(beta);
-  double cb2=cb*cb;
-  double tb=tan(beta);
-  double ctb=1./tb;
-  
-  double m12_2 = 0.;
-
-  if (tb>0) {
-    m12_2=(m22_2+0.5*v2*(lambda[2]*sb2+(lambda[3]+lambda[4]+lambda[5])*cb2+lambda[6]*cb2*ctb+3.*lambda[7]*sb*cb))*tb;
-  } else {
-    m12_2=0.5*v2*lambda[6];
+  if (params_full_set) {
+    return this->m12_2;
   }
+  else
+  {
+    //hep-ph/0207010
+    double sb=sin(beta);
+    double sb2=sb*sb;
+    double cb=cos(beta);
+    double cb2=cb*cb;
+    double tb=tan(beta);
+    double ctb=1./tb;
+
+    double m12_2 = 0.;
+
+    if (tb>0) {
+      m12_2=(m22_2+0.5*v2*(lambda[2]*sb2+(lambda[3]+lambda[4]+lambda[5])*cb2+lambda[6]*cb2*ctb+3.*lambda[7]*sb*cb))*tb;
+    } else {
+      m12_2=0.5*v2*lambda[6];
+    }
 
-  return m12_2;
+    return m12_2;
+  }
 }
 
 
@@ -2705,12 +2778,16 @@
   return sm;
 }
 
+SM* THDM::get_SM_pointer(){
+  // SM* smpointer;
+  // smpointer = &sm;
+  return &sm;
+}
+
 
 void THDM::set_SM(SM sm_in) {
   sm=sm_in;
   v2 = sm.get_v2();
-
-  
 }
 
 
@@ -2739,19 +2816,19 @@
 }
 
 double THDM::get_alpha() {
-  
+
   double mh,mH,mA,mHp,sba,l6,l7,tb,m12_2;
   get_param_phys(mh,mH,mA,mHp,sba,l6,l7,m12_2,tb);
 
   double beta = atan(tb);
   double cba = get_cba();
-  
+
   double ba = atan2(sba, cba);
   double a = -ba+beta;
-  
+
   if (a>M_PI/2) a = a - M_PI;
 
-  printf("Getting alpha: %16.8E %16.8E %16.8E %16.8E %16.8E %16.8E\n", tb, sba, cba, ba, beta,  a);
+  //printf("Getting alpha: %16.8E %16.8E %16.8E %16.8E %16.8E %16.8E\n", tb, sba, cba, ba, beta,  a);
 
 
   return a;
@@ -2770,3 +2847,8 @@
   printf("*                                                  *\n");
   printf("****************************************************\n");
 }
+
+
+int THDM::get_yukawas_type() {
+  return yukawas_type;
+}
diff -ruN src/THDM.h src_patched/THDM.h
--- src/THDM.h	2015-08-26 21:40:57.000000000 +0930
+++ src_patched/THDM.h	2018-10-31 18:38:35.000000000 +1030
@@ -11,9 +11,9 @@
 
 /**
 * \mainpage 2HDMC Class documentation
-* 2HDMC is a general-purpose calculator for the two-Higgs doublet model. 
-* It allows parametrization of the Higgs potential in many different ways, 
-* convenient specification of generic Yukawa sectors, the evaluation of decay 
+* 2HDMC is a general-purpose calculator for the two-Higgs doublet model.
+* It allows parametrization of the Higgs potential in many different ways,
+* convenient specification of generic Yukawa sectors, the evaluation of decay
 * widths, theoretical constraints and much more.
 */
 
@@ -24,8 +24,8 @@
 * in terms of the potential parameters and Yukawa couplings necessary for
 * a full specification of the model. Several methods are available to set
 * the model parameters to various special cases.
-* 
-* From a THDM object, all the couplings between physical states can be 
+*
+* From a THDM object, all the couplings between physical states can be
 * accessed, including Higgs-fermion, Higgs-Vector, Higgs-Higgs, 3H and 4H
 * couplings.
 */
@@ -35,28 +35,27 @@
 
 class THDM {
 
- public: 
-  
+ public:
+
+
 
-  
-  /** 
+  /**
   * @brief Default constructor.
-  *   
+  *
   * Empty default constructor which does nothing except initialization of this
   * THDM object. The model is not specified in any way by using this constructor.
   */
   THDM();
 
-
   /**
   * @brief Sets the underlying SM
   *
-  * This method can be used to specify the SM parameters which this 2HDM 
+  * This method can be used to specify the SM parameters which this 2HDM
   * is using.
   *
   * @param sm_in SM object specifying the parameters to use in this 2HDM
   */
-  void set_SM(SM sm_in);  
+  void set_SM(SM sm_in);
 
   /**
   * @brief Returns the underlying SM
@@ -64,14 +63,21 @@
   * @returns The SM object specifying the parameters used in this 2HDM
   */
   SM get_SM();
+  SM* get_SM_pointer();
+
+  bool set_param_full(double lambda1, double lambda2, double lambda3,
+                      double lambda4, double lambda5, double lambda6,
+                      double lambda7, double m12_2, double tan_beta,
+                      double m_h,double m_H, double m_A, double m_Hp,
+                      double sba);
 
-  /** 
+  /**
   * @brief Specifies 2HDM using generic potential
-  *   
+  *
   * This method lets the user specify the 2HDM using a generic basis.
-  * For details on the basis choices available for the Higgs potential, we 
+  * For details on the basis choices available for the Higgs potential, we
   * refer to the complete <a href="http://arxiv.org/abs/0902.0851">manual</a>.
-  * 
+  *
   * @param lambda1 Value of \f$ \lambda_1 \f$
   * @param lambda2 Value of \f$ \lambda_2 \f$
   * @param lambda3 Value of \f$ \lambda_3 \f$
@@ -81,20 +87,20 @@
   * @param lambda7 Value of \f$ \lambda_7 \f$
   * @param m12_2 Soft \f$ Z_2 \f$-breaking parameter
   * @param tan_beta Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_gen(double lambda1, double lambda2, double lambda3,
-                     double lambda4, double lambda5, double lambda6, 
+                     double lambda4, double lambda5, double lambda6,
                      double lambda7, double m12_2, double tan_beta);
 
-  /** 
+  /**
   * @brief Specifies 2HDM in the Higgs basis
-  *   
+  *
   * This method lets the user specify the 2HDM in the Higgs basis \f$ (v_2\equiv 0) \f$.
-  * For details on the basis choices available for the Higgs potential, we 
+  * For details on the basis choices available for the Higgs potential, we
   * refer to the complete <a href="http://arxiv.org/abs/0902.0851">manual</a>.
-  * 
+  *
   * @param Lambda1 Value of \f$ \Lambda_1 \f$
   * @param Lambda2 Value of \f$ \Lambda_2 \f$
   * @param Lambda3 Value of \f$ \Lambda_3 \f$
@@ -103,16 +109,16 @@
   * @param Lambda6 Value of \f$ \Lambda_6 \f$
   * @param Lambda7 Value of \f$ \Lambda_7 \f$
   * @param m_Hp    Mass of the charged Higgs
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_higgs(double Lambda1, double Lambda2, double Lambda3,
-                       double Lambda4, double Lambda5, double Lambda6, 
+                       double Lambda4, double Lambda5, double Lambda6,
                        double Lambda7, double m_Hp);
 
-  /** 
+  /**
   * @brief Specifies 2HDM in the hybrid basis of 1507.04281
-  *   
+  *
   * @param mh Value of light CP-even Higgs mass \f$ m_h \f$
   * @param mH Value of heavy CP-even Higgs mass \f$ m_H \f$
   * @param cba Mixing parameter \f$ \cos(\beta-\alpha) \f$. Valid range: -1 < cba <= 1.
@@ -120,14 +126,14 @@
   * @param Z_5 Value of \f$ Z_5 \f$
   * @param Z_7 Value of \f$ Z_7 \f$
   * @param tanb Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_hybrid(double mh, double mH, double cba, double Z4,double Z5, double Z7, double tanb);
 
-  /** 
+  /**
   * @brief Specifies 2HDM in the hybrid basis of 1507.04281, but with sba instead of cba
-  *   
+  *
   * @param mh Value of light CP-even Higgs mass \f$ m_h \f$
   * @param mH Value of heavy CP-even Higgs mass \f$ m_H \f$
   * @param sba Mixing parameter \f$ \sin(\beta-\alpha) \f$. Valid range: -1 < cba <= 1.
@@ -135,19 +141,19 @@
   * @param Z_5 Value of \f$ Z_5 \f$
   * @param Z_7 Value of \f$ Z_7 \f$
   * @param tanb Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_hybrid_sba(double mh, double mH, double sba, double Z4,double Z5, double Z7, double tanb);
 
-  /** 
+  /**
   * @brief Specifies 2HDM using potential from the Higgs Hunter's Guide
-  *   
+  *
   * This method lets the user specify the 2HDM using the CP-conserving form
   * of the potential given by Eq. (4.8) in "The Higgs Hunter's Guide".
-  * For details on the basis choices available for the Higgs potential, we 
+  * For details on the basis choices available for the Higgs potential, we
   * refer to the complete <a href="http://arxiv.org/abs/0902.0851">manual</a>.
-  * 
+  *
   * @param lambda1 Value of \f$ \lambda_1 \f$
   * @param lambda2 Value of \f$ \lambda_2 \f$
   * @param lambda3 Value of \f$ \lambda_3 \f$
@@ -155,20 +161,20 @@
   * @param lambda5 Value of \f$ \lambda_5 \f$
   * @param lambda6 Value of \f$ \lambda_6 \f$
   * @param tan_beta Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_HHG(double lambda1, double lambda2, double lambda3,
-                     double lambda4, double lambda5, double lambda6, 
+                     double lambda4, double lambda5, double lambda6,
                      double tan_beta);
 
-  /** 
+  /**
   * @brief Specifies 2HDM in the physical basis
-  *   
+  *
   * This method lets the user specify the 2HDM using the basis of physical
-  * Higgs masses. For details on the basis choices available for the Higgs 
+  * Higgs masses. For details on the basis choices available for the Higgs
   * potential, we refer to the complete <a href="http://arxiv.org/abs/0902.0851">manual</a>.
-  * 
+  *
   * @param m_h  Mass of lightest CP-even Higgs \f$ h \f$
   * @param m_H  Mass of heavier CP-even Higgs \f$ H \f$
   * @param m_A  Mass of CP-odd Higgs \f$ A \f$
@@ -178,7 +184,7 @@
   * @param lambda7  Value of \f$ \lambda_7 \f$ in generic potential
   * @param m12_2    Soft \f$ Z_2 \f$-breaking parameter
   * @param tan_beta Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_param_phys(double m_h,double m_H, double m_A, double m_Hp,
@@ -188,55 +194,55 @@
   bool set_param_sm(double mh);
 
 
-  /** 
+  /**
   * @brief Specifies the 2HDM of the tree-level MSSM
-  *   
+  *
   * This method lets the user specify a 2HDM with the properties of the tree-level
   * MSSM in terms of masses and coupling relations. The Yukawa sector is also
   * automatically selected to be of type II.
-  * 
+  *
   * @param m_A      Mass of CP-odd Higgs \f$ A \f$
   * @param tan_beta Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_MSSM(double m_A, double tan_beta);
 
-  /** 
+  /**
   * @brief Specifies the 2HDM of the tree-level MSSM + mass corrections to h ("hMSSM")
-  *   
+  *
   * This method lets the user specify a 2HDM with the properties of the tree-level
   * MSSM, with additional mass corrections from the lambda_2 contribution to the (2,2)
-  * element of the mass matrix. These can be identified as the leading (mt^4) MSSM 
+  * element of the mass matrix. These can be identified as the leading (mt^4) MSSM
   * corrections. The Yukawa sector is automatically selected to be of type II.
-  * 
+  *
   * @param m_h      Mass of light CP-even Higgs \f$ h \f$
   * @param m_A      Mass of CP-odd Higgs \f$ A \f$
   * @param tan_beta Ratio of vevs, \f$ \tan\beta=v_2/v_1 \f$
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_hMSSM(double mh, double mA, double tanb);
 
 
-  /** 
+  /**
   * @brief Specifies the 2HDM with one "inert Higgs" doublet
-  *   
+  *
   * This method lets the user specify a 2HDM with special properties as follows:
   * only one of the doublets acquires a vev, there is an exact \f$ Z_2 \f$-symmetry,
-  * preventing interdoublet mixing, and the doublet without a vev has no Yukawa 
-  * couplings. This results in one doublet being "inert" (or dark). The lightest 
+  * preventing interdoublet mixing, and the doublet without a vev has no Yukawa
+  * couplings. This results in one doublet being "inert" (or dark). The lightest
   * Higgs originating from this doublet is then stable, thus a dark matter candidate.
   * The conventions used for specifying the parameters for this model are the same as
   * in <a href="http://arxiv.org/abs/0810.3924">arXiv:0810.3924</a>.
-  * 
+  *
   * @param m_h  Mass of "SM-like" Higgs - NB: Changed meaning compared to "physical" basis
   * @param m_H  Mass of CP-even "inert" Higgs - NB: Changed meaning compared to "physical" basis
   * @param m_A  Mass of CP-odd "inert" Higgs
   * @param m_Hp Mass of charged "inert" Higgs
   * @param lambda2 Value of \f$ \lambda_2 \f$ parameter
   * @param lambda3 Value of \f$ \lambda_2 \f$ parameter
-  * 
+  *
   * @returns Boolean \a true if all parameters were set correctly, \a false otherwise
   */
   bool set_inert(double m_h,double m_H, double m_A, double m_Hp, double lambda2, double lambda3);
@@ -244,42 +250,42 @@
 
   /**
   * @brief Returns parameter set in the generic basis
-  * 
-  * This method returns a consistent set of parameter values describing the 
+  *
+  * This method returns a consistent set of parameter values describing the
   * current model in the generic basis.
-  * 
+  *
   * @param lambda1 Returned value of \f$ \lambda_1 \f$
   * @param lambda2 Returned value of \f$ \lambda_2 \f$
-  * @param lambda3 Returned value of \f$ \lambda_3 \f$ 
-  * @param lambda4 Returned value of \f$ \lambda_4 \f$ 
-  * @param lambda5 Returned value of \f$ \lambda_5 \f$ 
-  * @param lambda6 Returned value of \f$ \lambda_6 \f$ 
-  * @param lambda7 Returned value of \f$ \lambda_7 \f$ 
-  * @param m12_2   Returned value of \f$ m_{12}^2 \f$ 
-  * @param tan_beta Returned value of \f$ \tan\beta \f$ 
+  * @param lambda3 Returned value of \f$ \lambda_3 \f$
+  * @param lambda4 Returned value of \f$ \lambda_4 \f$
+  * @param lambda5 Returned value of \f$ \lambda_5 \f$
+  * @param lambda6 Returned value of \f$ \lambda_6 \f$
+  * @param lambda7 Returned value of \f$ \lambda_7 \f$
+  * @param m12_2   Returned value of \f$ m_{12}^2 \f$
+  * @param tan_beta Returned value of \f$ \tan\beta \f$
   */
   void get_param_gen(double &lambda1, double &lambda2, double &lambda3,
-                     double &lambda4, double &lambda5, double &lambda6, 
+                     double &lambda4, double &lambda5, double &lambda6,
                      double &lambda7, double &m12_2,   double &tan_beta);
 
 
   /**
   * @brief Returns parameter set in the Higgs basis
-  * 
-  * This method returns a consistent set of parameter values describing the 
+  *
+  * This method returns a consistent set of parameter values describing the
   * current model in the Higgs basis.
-  * 
+  *
   * @param Lambda1 Returned value of \f$ \Lambda_1 \f$
   * @param Lambda2 Returned value of \f$ \Lambda_2 \f$
-  * @param Lambda3 Returned value of \f$ \Lambda_3 \f$ 
-  * @param Lambda4 Returned value of \f$ \Lambda_4 \f$ 
-  * @param Lambda5 Returned value of \f$ \Lambda_5 \f$ 
-  * @param Lambda6 Returned value of \f$ \Lambda_6 \f$ 
-  * @param Lambda7 Returned value of \f$ \Lambda_7 \f$ 
+  * @param Lambda3 Returned value of \f$ \Lambda_3 \f$
+  * @param Lambda4 Returned value of \f$ \Lambda_4 \f$
+  * @param Lambda5 Returned value of \f$ \Lambda_5 \f$
+  * @param Lambda6 Returned value of \f$ \Lambda_6 \f$
+  * @param Lambda7 Returned value of \f$ \Lambda_7 \f$
   * @param m_Hp    Returned value of the charged Higgs mass
   */
   void get_param_higgs(double &Lambda1, double &Lambda2, double &Lambda3,
-                       double &Lambda4, double &Lambda5, double &Lambda6, 
+                       double &Lambda4, double &Lambda5, double &Lambda6,
                        double &Lambda7, double &m_Hp);
 
   void get_param_hybrid(double &m_h, double &m_H, double &sba,
@@ -288,39 +294,39 @@
 
   /**
   * @brief Returns parameter set in Higgs Hunter's Guide basis
-  * 
-  * This method returns a consistent set of parameter values describing the 
+  *
+  * This method returns a consistent set of parameter values describing the
   * current model in the basis used in the Higgs Hunter's Guide. NB: The use
   * of this method assumes \f$ \lambda_6=\lambda_7=0 \f$ in the generic basis.
-  * 
+  *
   * @param lambda1 Returned value of \f$ \lambda_1 \f$
   * @param lambda2 Returned value of \f$ \lambda_2 \f$
-  * @param lambda3 Returned value of \f$ \lambda_3 \f$ 
-  * @param lambda4 Returned value of \f$ \lambda_4 \f$ 
-  * @param lambda5 Returned value of \f$ \lambda_5 \f$ 
-  * @param lambda6 Returned value of \f$ \lambda_6 \f$ 
-  * @param tan_beta Returned value of \f$ \tan\beta \f$ 
+  * @param lambda3 Returned value of \f$ \lambda_3 \f$
+  * @param lambda4 Returned value of \f$ \lambda_4 \f$
+  * @param lambda5 Returned value of \f$ \lambda_5 \f$
+  * @param lambda6 Returned value of \f$ \lambda_6 \f$
+  * @param tan_beta Returned value of \f$ \tan\beta \f$
   */
   void get_param_HHG(double &lambda1, double &lambda2, double &lambda3,
-                     double &lambda4, double &lambda5, double &lambda6, 
+                     double &lambda4, double &lambda5, double &lambda6,
                      double &tan_beta);
 
 
   /**
   * @brief Returns parameter set in physical basis
-  * 
-  * This method returns a consistent set of parameter values describing the 
+  *
+  * This method returns a consistent set of parameter values describing the
   * current model in the "physical" basis.
-  * 
+  *
   * @param m_h      Returned value of lightest CP-even Higgs mass
   * @param m_H      Returned value of heaviest CP-even Higgs mass
   * @param m_A      Returned value of CP-odd Higgs mass
   * @param m_Hp     Returned value of charged Higgs mass
-  * @param sba      Returned value of \f$ \sin(\beta-\alpha) \f$ 
+  * @param sba      Returned value of \f$ \sin(\beta-\alpha) \f$
   * @param lambda6  Returned value of \f$ \lambda_6 \f$
-  * @param lambda7  Returned value of \f$ \lambda_7 \f$  
-  * @param m12_2    Returned value of \f$ m_{12}^2 \f$ 
-  * @param tan_beta Returned value of \f$ \tan\beta \f$ 
+  * @param lambda7  Returned value of \f$ \lambda_7 \f$
+  * @param m12_2    Returned value of \f$ m_{12}^2 \f$
+  * @param tan_beta Returned value of \f$ \tan\beta \f$
   */
   void get_param_phys(double &m_h,double &m_H, double &m_A, double &m_Hp,
                       double &sba, double &lambda6, double &lambda7,
@@ -329,38 +335,38 @@
 
   /**
   * @brief Changes basis for the Higgs doublets
-  * 
-  * This method performs a change of basis, changing the value of 
+  *
+  * This method performs a change of basis, changing the value of
   * \f$ \tan\beta \f$. This results in a recalculation of all the other
   * potential parameters, but the physical couplings remain unchanged.
-  * Yukawa couplings are not modified. 
-  * 
+  * Yukawa couplings are not modified.
+  *
   * @param tan_beta Value of \f$ \tan\beta \f$ to use in the new basis
   */
   void recalc_tan_beta(double tan_beta);
 
   /**
   * @brief Returns the mass of physical Higgs bosons
-  * 
+  *
   * This method returns the mass of a physical Higgs Boson. The numbering
   * convention corresponds to (1,2,3,4 = h,H,A,H+) where always \f$ m_h < m_H \f$.
-  * 
+  *
   * @param h Index of Higgs boson
-  * 
+  *
   * @returns The mass of Higgs boson \a h
   */
   double get_hmass(int h);
 
   /**
   * @brief Returns invariant \f$ \sin(\beta-\alpha) \f$
-  * 
+  *
   * @returns Value of \f$ \sin(\beta-\alpha) \f$ in model
   */
   double get_sba();
 
   /**
   * @brief Returns invariant \f$ \cos(\beta-\alpha) \f$
-  * 
+  *
   * @returns Value of \f$ \cos(\beta-\alpha) \f$ in model
   */
   double get_cba();
@@ -368,14 +374,14 @@
 
   /**
   * @brief Higgs coupling \f$ q_{ki} \f$ factors
-  * 
+  *
   * This method returns the invariants \f$ q_{ki} \f$ (<a href="
   * http://arxiv.org/abs/hep-ph/0602242">hep-ph/0602242</a>) which are used
   * for the triple and quartic Higgs couplings.
-  * 
+  *
   * @param k Higgs index (1--4)
   * @param i Coupling index (1--2)
-  * 
+  *
   * @returns The value of the coefficient \f$ q_{ki} \f$
   */
   complex <double> get_qki(int k, int i);
@@ -386,7 +392,7 @@
   *
   * This method is used to specify a type of Yukawa sector for the 2HDM.
   * The types (1-4) implemented follow the convention of <a href=""></a>.
-  * 
+  *
   * @param type Type of Yukawa sector (1--4)
   */
   void set_yukawas_type(int type);
@@ -396,13 +402,13 @@
   *
   * This method initializes and sets the Yukawa couplings for the down-type quarks.
   * The diagonal matrix \f$ \kappa^D \f$ is automatically specified to comply with
-  * the quark pole masses, whereas the diagonal elements of \f$ \rho^D \f$ can be 
+  * the quark pole masses, whereas the diagonal elements of \f$ \rho^D \f$ can be
   * specified as input.
-  * 
+  *
   * @param rhod Diagonal element of \f$ \rho^D \f$ for the \f$ d \f$ quark
   * @param rhos Diagonal element of \f$ \rho^D \f$ for the \f$ s \f$ quark
   * @param rhob Diagonal element of \f$ \rho^D \f$ for the \f$ b \f$ quark
-  * 
+  *
   * @see set_yukawas_up, set_yukawas_lepton
   */
   void set_yukawas_down(double rhod, double rhos, double rhob);
@@ -413,13 +419,13 @@
   *
   * This method initializes and sets the Yukawa couplings for the up-type quarks.
   * The diagonal matrix \f$ \kappa^U \f$ is automatically specified to comply with
-  * the quark pole masses, whereas the diagonal elements of \f$ \rho^U \f$ can be 
+  * the quark pole masses, whereas the diagonal elements of \f$ \rho^U \f$ can be
   * specified as input.
-  * 
+  *
   * @param rhou Diagonal element of \f$ \rho^U \f$ for the \f$ u \f$ quark
   * @param rhoc Diagonal element of \f$ \rho^U \f$ for the \f$ c \f$ quark
   * @param rhot Diagonal element of \f$ \rho^U \f$ for the \f$ t \f$ quark
-  * 
+  *
   * @see set_yukawas_down, set_yukawas_lepton
   */
   void set_yukawas_up(double rhou, double rhoc, double rhot);
@@ -429,9 +435,9 @@
   *
   * This method initializes and sets the Yukawa couplings for the leptons.
   * The diagonal matrix \f$ \kappa^L \f$ is automatically specified to comply with
-  * the lepton pole masses, whereas the diagonal element of \f$ \rho^L \f$ can be 
+  * the lepton pole masses, whereas the diagonal element of \f$ \rho^L \f$ can be
   * specified as input.
-  * 
+  *
   * @param rhoe   Diagonal element of \f$ \rho^L \f$ for \f$ e \f$
   * @param rhomu  Diagonal element of \f$ \rho^L \f$ for \f$ \mu \f$
   * @param rhotau Diagonal element of \f$ \rho^L \f$ for \f$ \tau \f$
@@ -439,7 +445,7 @@
   * @see set_yukawas_down, set_yukawas_up
   */
   void set_yukawas_lepton(double rhoe, double rhomu, double rhotau);
- 
+
 
   /**
   * @brief Initializes and sets Yukawa couplings for down-type quarks
@@ -448,7 +454,7 @@
   * The diagonal matrix \f$ \kappa^D \f$ is automatically specified to comply with
   * the quark pole masses, whereas the symmetric matrix \f$ \rho^D \f$ is given by
   * the six elements specified as input.
-  * 
+  *
   * @param rho11 Yukawa coupling \f$ \rho^D_{dd} \f$
   * @param rho22 Yukawa coupling \f$ \rho^D_{ss} \f$
   * @param rho33 Yukawa coupling \f$ \rho^D_{bb} \f$
@@ -458,7 +464,7 @@
   */
   void set_yukawas_down(double rho11,double rho22,double rho33,double rho12,double rho13,double rho23);
 
- 
+
   /**
   * @brief Initializes and sets Yukawa couplings for up-type quarks
   *
@@ -466,7 +472,7 @@
   * The diagonal matrix \f$ \kappa^U \f$ is automatically specified to comply with
   * the quark pole masses, whereas the symmetric matrix \f$ \rho^U \f$ is given by
   * the six elements specified as input.
-  * 
+  *
   * @param rho11 Yukawa coupling \f$ \rho^U_{uu} \f$
   * @param rho22 Yukawa coupling \f$ \rho^U_{cc} \f$
   * @param rho33 Yukawa coupling \f$ \rho^U_{tt} \f$
@@ -475,8 +481,8 @@
   * @param rho23 Yukawa coupling \f$ \rho^U_{ct} \f$
   */
   void set_yukawas_up(double rho11,double rho22,double rho33,double rho12,double rho13,double rho23);
-  
-  
+
+
   /**
   * @brief Initializes and sets Yukawa couplings for leptons
   *
@@ -484,7 +490,7 @@
   * The diagonal matrix \f$ \kappa^L \f$ is automatically specified to comply with
   * the lepton masses, whereas the symmetric matrix \f$ \rho^L \f$ is given by
   * the six elements specified as input.
-  * 
+  *
   * @param rho11 Yukawa coupling \f$ \rho^L_{ee} \f$
   * @param rho22 Yukawa coupling \f$ \rho^L_{\mu\mu} \f$
   * @param rho33 Yukawa coupling \f$ \rho^L_{\tau\tau} \f$
@@ -493,7 +499,7 @@
   * @param rho23 Yukawa coupling \f$ \rho^L_{\mu\tau} \f$
   */
   void set_yukawas_lepton(double rho11,double rho22,double rho33,double rho12,double rho13,double rho23);
-  
+
   /**
   * @brief Initializes and sets Yukawa couplings for the inert 2HDM
   *
@@ -503,32 +509,32 @@
   */
   void set_yukawas_inert();
 
- 
+
   /**
   * @brief Returns diagonal elements of Yukawa matrix for down-type quarks
-  * 
+  *
   * @param rhod Returned value of \f$ \rho^D_{dd} \f$
-  * @param rhos Returned value of \f$ \rho^D_{ss} \f$ 
+  * @param rhos Returned value of \f$ \rho^D_{ss} \f$
   * @param rhob Returned value of \f$ \rho^D_{bb} \f$
   */
   void get_yukawas_down(double &rhod, double &rhos, double &rhob);
 
- 
+
   /**
   * @brief Returns diagonal elements of Yukawa matrix for up-type quarks
-  * 
+  *
   * @param rhou Returned value of \f$ \rho^U_{uu} \f$
-  * @param rhoc Returned value of \f$ \rho^U_{cc} \f$ 
+  * @param rhoc Returned value of \f$ \rho^U_{cc} \f$
   * @param rhot Returned value of \f$ \rho^U_{tt} \f$
   */
   void get_yukawas_up(double &rhou, double &rhoc, double &rhot);
-  
+
 
   /**
   * @brief Returns diagonal elements of Yukawa matrix for leptons
-  * 
+  *
   * @param rhoe Returned value of \f$ \rho^L_{ee} \f$
-  * @param rhomu Returned value of \f$ \rho^L_{\mu\mu} \f$ 
+  * @param rhomu Returned value of \f$ \rho^L_{\mu\mu} \f$
   * @param rhotau Returned value of \f$ \rho^L_{\tau\tau} \f$
   */
   void get_yukawas_lepton(double &rhoe, double &rhomu, double &rhotau);
@@ -537,33 +543,33 @@
   void get_kappa_down(double &kd, double &ks, double &kb);
   void get_kappa_up(double &ku, double &kc, double &kt);
   void get_kappa_lepton(double &ke, double &kmu, double &ktau);
- 
+
   void get_kappa_down(double mu, double &kd, double &ks, double &kb);
   void get_kappa_up(double mu, double &ku, double &kc, double &kt);
   void get_kappa_lepton(double mu, double &ke, double &kmu, double &ktau);
   void get_rho_down(double mu, double &rd, double &rs, double &rb);
   void get_rho_up(double mu, double &ru, double &rc, double &rt);
   void get_rho_lepton(double mu, double &re, double &rmu, double &rtau);
-  
+
   /**
   * @brief Returns Yukawa matrix for down-type quarks
-  * 
+  *
   * @param rho_D_out Returned Yukawa matrix \f$ \rho^D \f$
   */
   void get_yukawas_down(gsl_matrix *rho_D_out);
 
- 
+
   /**
   * @brief Returns Yukawa matrix for up-type quarks
-  * 
+  *
   * @param rho_U_out Returned Yukawa matrix \f$ \rho^U \f$
   */
   void get_yukawas_up(gsl_matrix *rho_U_out);
 
-  
+
   /**
   * @brief Returns Yukawa matrix for leptons
-  * 
+  *
   * @param rho_L_out Returned Yukawa matrix \f$ \rho^L \f$
   */
   void get_yukawas_lepton(gsl_matrix *rho_L_out);
@@ -571,85 +577,85 @@
 
   /**
   * @brief Couplings of Higgses to down-type fermions
-  * 
+  *
   * Calculates the coupling \f$ hdd \f$ between one physical Higgs state, specified
   * by \a h, and two down-type quarks \a f1 and \a f2.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param f1 First fermion (1,2,3 = d,s,b)
   * @param f2 Second fermion (1,2,3 = d,s,b)
   * @param cs Returned (complex) value for scalar coupling
-  * @param cp Returned (complex) value for pseudoscalar coupling 
+  * @param cp Returned (complex) value for pseudoscalar coupling
   */
   void get_coupling_hdd(int h,int f1,int f2,complex <double> &cs, complex <double> &cp);
 
 
   /**
   * @brief Couplings of Higgses to up-type fermions
-  * 
+  *
   * Calculates the coupling \f$ huu \f$ between one physical Higgs state, specified
   * by \a h, and two up-type quarks \a f1 and \a f2.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param f1 First fermion (1,2,3 = u,c,t)
   * @param f2 Second fermion (1,2,3 = u,c,t)
   * @param cs Returned (complex) value for scalar coupling
-  * @param cp Returned (complex) value for pseudoscalar coupling 
+  * @param cp Returned (complex) value for pseudoscalar coupling
   */
   void get_coupling_huu(int h,int f1,int f2,complex <double> &cs, complex <double> &cp);
-  
+
 
   /**
   * @brief Couplings of Higgses to mixed type fermions
-  * 
+  *
   * Calculates the coupling \f$ hdu \f$ between one physical Higgs state, specified
   * by \a h (only relevant one is charged Higgs), and two quarks \a f1 and \a f2.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param d Down-type fermion (1,2,3 = d,s,b)
   * @param u Up-type fermion (1,2,3 = u,c,t)
   * @param cs Returned (complex) value for scalar coupling
-  * @param cp Returned (complex) value for pseudoscalar coupling 
+  * @param cp Returned (complex) value for pseudoscalar coupling
   */
   void get_coupling_hdu(int h,int d,int u,complex <double> &cs, complex <double> &cp);
 
   /**
   * @brief Couplings of Higgses to charged leptons
-  * 
+  *
   * Calculates the coupling \f$ hll \f$ between one physical Higgs state, specified
   * by \a h, and two leptons \a f1 and \a f2.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param f1 First fermion (1,2,3 = \f$ e,\mu,\tau \f$)
   * @param f2 Second fermion (1,2,3 = \f$ e,\mu,\tau \f$)
   * @param cs Returned (complex) value for scalar coupling
-  * @param cp Returned (complex) value for pseudoscalar coupling 
+  * @param cp Returned (complex) value for pseudoscalar coupling
   */
   void get_coupling_hll(int h,int f1,int f2,complex <double> &cs, complex <double> &cp);
 
-  /** 
+  /**
   * @brief Couplings of Higgses to mixed leptons
-  * 
+  *
   * Calculates the coupling \f$ hl\nu_l \f$ between one physical Higgs state, specified
   * by \a h (only relevant one is charged Higgs), and two leptons \a f1 and \a f2.
-  * 
+  *
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param l  Charged lepton (1,2,3 = \f$ e,\mu,\tau \f$)
   * @param n  Neutrino (1,2,3 = \f$ \nu_e,\nu_\mu,\nu_\tau \f$)
   * @param cs Returned (complex) value for scalar coupling
-  * @param cp Returned (complex) value for pseudoscalar coupling 
+  * @param cp Returned (complex) value for pseudoscalar coupling
   */
   void get_coupling_hln(int h,int l,int n,complex <double> &cs, complex <double> &cp);
 
-  
-  /** 
+
+  /**
   * @brief Couplings of Higgses to pairs of vector bosons
-  * 
+  *
   * Calculates the coupling \f$ hV_1 V_2 \f$ between one physical Higgs state, specified
   * by \a h , and two vector bosons \a v1 and \a v2. NB: Neutral Higgses have no coupling
-  * to photons implemented, but the loop mediated decays \f$ h\to \gamma \gamma \f$ can 
-  * nevertheless be calculated using the DecayTable class. Conventions are according to hep-ph/0602242.
-  * 
+  * to photons implemented, but the loop mediated decays \f$ h\to \gamma \gamma \f$ can
+  * nevertheless be calculated using the DecayTableTHDM class. Conventions are according to hep-ph/0602242.
+  *
   * @param v1 Index of first vector boson (1,2,3 = \f$ \gamma,Z,W^+ \f$)
   * @param v2 Index of second vector boson (1,2,3 = \f$ \gamma,Z,W^+ \f$)
   * @param h  Index of Higgs boson (1,2,3,4 = h,H,A,H+)
@@ -657,26 +663,26 @@
   */
   void get_coupling_vvh(int v1,int v2,int h,complex <double> &c);
 
-  /** 
+  /**
   * @brief Couplings of vector bosons to pairs of Higgses
-  * 
+  *
   * Calculates the coupling \f$ Vh_1 h_2 \f$ between two physical Higgs states, specified
   * by \a h1 and \a h2, and one vector boson \a v. Conventions are according to hep-ph/0602242.
-  * 
+  *
   * @param h1 Index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h2 Index of second Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param v  Index of vector boson (1,2,3 = \f$ \gamma,Z,W^+ \f$)
   * @param c  Returned (complex) value for coupling
   */
   void get_coupling_vhh(int v,int h1,int h2,complex <double> &c);
-  
 
-  /** 
+
+  /**
   * @brief Triple Higgs couplings
-  * 
-  * Calculates the coupling \f$ h_1 h_2 h_3 \f$ between three physical Higgs states. 
+  *
+  * Calculates the coupling \f$ h_1 h_2 h_3 \f$ between three physical Higgs states.
   * Conventions are according to hep-ph/0602242
-  * 
+  *
   * @param h1 Index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h2 Index of second Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h3 Index of third Higgs boson (1,2,3,4 = h,H,A,H+)
@@ -684,26 +690,26 @@
   */
   void get_coupling_hhh(int h1,int h2,int h3,complex <double> &c);
 
-  /** 
+  /**
   * @brief Couplings of two vector bosons and two Higgses
-  * 
+  *
   * Calculates the coupling \f$ V_1 V_2 h_1 h_2 \f$ between two vector bosons and
   * two physical Higgs states. Conventions are according to hep-ph/0602242
-  * 
+  *
   * @param v1 Index of first vector boson (1,2,3 = \f$ \gamma,Z,W^+ \f$)
   * @param v2 Index of second vector boson (1,2,3 = \f$ \gamma,Z,W^+ \f$)
   * @param h1 Index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h2 Index of second Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param c  Returned (complex) value for coupling
-  */ 
+  */
   void get_coupling_vvhh(int v1,int v2,int h1,int h2,complex <double> &c);
-  
-  /** 
+
+  /**
   * @brief Quartic Higgs couplings
-  * 
+  *
   * Calculates the coupling \f$ h_1 h_2 h_3 h_4 \f$ between four physical Higgs states.
   * Conventions are according to hep-ph/0602242
-  * 
+  *
   * @param h1 Index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h2 Index of second Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param h3 Index of third Higgs boson (1,2,3,4 = h,H,A,H+)
@@ -713,118 +719,118 @@
   void get_coupling_hhhh(int h1,int h2,int h3,int h4,complex <double> &c);
 
 
-  /** 
+  /**
   * @brief Calculates tree-level unitarity constraints
-  * 
-  * This method calculates the eigenvalues of the S-matrix for Higgs-Higgs scattering 
+  *
+  * This method calculates the eigenvalues of the S-matrix for Higgs-Higgs scattering
   * as defined in <a href="http://xxx.lanl.gov/abs/hep-ph/0508020">hep-ph/0508020</a>.
-  * 
+  *
   * @returns Value of largest eigenvalue
   */
   double calc_unitarity();
-  
-  /** 
+
+  /**
   * @brief Checks tree-level unitarity constraints
-  * 
+  *
   * This method checks whether the parameters of the Higgs potential results
   * in an S-matrix for Higgs-Higgs scattering that fullfills tree-level unitarity,
   * as discussed in <a href="http://xxx.lanl.gov/abs/hep-ph/0508020">hep-ph/0508020</a>.
-  * 
+  *
   * @param unitarity_limit optional value to be used for unitarity limit (default = \f$ 16\pi \f$)
-  * 
+  *
   * @returns Boolean \a true if the unitarity constraint is satisfied, \a false otherwise
   */
   bool check_unitarity(double unitarity_limit = 16*M_PI);
-  
 
-  /** 
+
+  /**
   * @brief Calculates largest quartic Higgs coupling
-  * 
+  *
   * This method calculates all the quartic Higgs boson couplings and returns the largest one as well as the indices of the four Higgs bosons
-  * 
-  * @param gmax  Returned (complex) value for coupling 
+  *
+  * @param gmax  Returned (complex) value for coupling
   * @param imax  Returned index of first Higgs boson (1,2,3,4 = h,H,A,H+)
   * @param jmax  Returned index of second boson (1,2,3,4 = h,H,A,H+)
   * @param kmax  Returned index of third boson (1,2,3,4 = h,H,A,H+)
   * @param lmax  Returned index of fourth boson (1,2,3,4 = h,H,A,H+)
   */
   void calc_perturbativity(complex <double> &gmax,int &imax,int &jmax,int &kmax,int &lmax);
-  
-  /** 
+
+  /**
   * @brief Checks perturbativity
-  * 
-  * This method checks whether the couplings of the Higgs and Gauge bosons fullfills perturbativity 
-  * 
+  *
+  * This method checks whether the couplings of the Higgs and Gauge bosons fullfills perturbativity
+  *
   * @param perturbativity_limit optional value to be used for perturbativity limit (default = \f$ 4\pi \f$)
-  * 
+  *
   * @returns Boolean \a true if the perturbativity constraint is satisfied, \a false otherwise
   */
   bool check_perturbativity(double perturbativity_limit = 4*M_PI);
-    
-  /** 
+
+  /**
   * @brief Checks the stability of the Higgs potential
-  * 
+  *
   * This method checks whether the Higgs potential is stable, i.e. if no
   * directions exist in field space for which \f$ V\to -\infty \f$ for large
   * values of the fields. This is done through a combination of analytical and numerical
   * algorithms, depending on the generality of the specified potential.
-  * 
+  *
   * @returns Boolean \a true if the potential is deemed stable, \a false otherwise
   */
   bool check_stability();
 
-  /** 
+  /**
   * @brief Prints the potential parameters in the generic basis to stdout
   */
   void print_param_gen();
-  
-  /** 
+
+  /**
   * @brief Prints the potential parameters in the Higgs basis to stdout
   */
   void print_param_higgs();
 
-  
-  /** 
+
+  /**
   * @brief Prints the potential parameters in the hybrid basis to stdout
   */
   void print_param_hybrid();
-  
 
-  /** 
+
+  /**
   * @brief Prints the potential parameters in the physical basis to stdout
   */
   void print_param_phys();
-  
-  /** 
+
+  /**
   * @brief Prints the potential parameters in the Higgs Hunter's Guide basis to stdout
   */
   void print_param_HHG();
-  
-  /** 
+
+  /**
   * @brief Prints the Yukawa matrices to stdout
   */
   void print_yukawas();
 
   void print_hdecay();
 
-  /** 
+  /**
   * @brief Reads the 2HDM parameters from a LesHouches compliant file
-  * 
+  *
   * This method reads the parameters necessary to specify the 2HDM (and the %SM)
   * from a file complying with the LesHouches standard. There are several options
   * for how to prepare this file (see <a href="http://arxiv.org/abs/0902.0851">manual</a> for details,
   * or the code distribution for examples).
-  * 
+  *
   * @param file The name of the file to read
-  * 
-  * @returns Boolean \a true if the file could be opened and read correctly AND 
+  *
+  * @returns Boolean \a true if the file could be opened and read correctly AND
   *          a 2HDM was correctly specified in the file, \a false otherwise
   */
   bool read_LesHouches(const char* file);
 
-  /** 
+  /**
   * @brief Writes output in a LesHouches compliant file format
-  * 
+  *
   * This method writes the potential parameters and other selected output to
   * a specified file in LesHouches-compliant file format which can then be
   * further processed by other codes.
@@ -832,25 +838,27 @@
   * @param file The name of the file which is to be written
   * @param fulldecay If \a true, decay modes of the Higgs bosons in LesHouches
   *                  format are written to the file
-  * @param couplings If \a true, all couplings (> 200 values) for the Higgs bosons 
-  *                  are written to the file. Should be used when supplying input 
+  * @param couplings If \a true, all couplings (> 200 values) for the Higgs bosons
+  *                  are written to the file. Should be used when supplying input
   *                  for MadGraph/MadEvent 2HDMC model
-  * @param qcd_on    Turns QCD corrections on or off, default is on. Should be 
+  * @param qcd_on    Turns QCD corrections on or off, default is on. Should be
   *                  turned off when supplying input for MadGraph/MadEvent 2HDMC model
   */
   void write_LesHouches(const char* file, bool fulldecay, bool couplings, bool qcd_on=true, bool HBHS=true);
 
-  void write_model(const char* file);
-
+  // get the mixing angle alpha
   double get_alpha();
 
+  // get the yukawa type
+  int get_yukawas_type();
+
   /**
 	* @brief Small value
-	* 
+	*
 	*  Minimum value used for widths, branching ratios etc. to determine when
 	*  something should be considered zero.
 	*/
-  const static double EPS = 1E-12;
+  const static double EPS;
 
  private:
   double      lambda[8];
@@ -858,7 +866,13 @@
   double      m22_2;
   double      sinba;
   bool        params_set;
+  bool        params_full_set;
   double      v2;
+  double      m_h;
+  double      m_H;
+  double      m_A;
+  double      m_Hp;
+  double      m12_2;
   gsl_matrix *kappa_D;
   gsl_matrix *kappa_U;
   gsl_matrix *kappa_L;
@@ -872,8 +886,8 @@
   const static char *version;
 
   SM sm;
-  
-  void init();  
+
+  void init();
   double get_m12_2();
   void set_kappa();
   void set_kappa_D();
diff -ruN src/Util.cpp src_patched/Util.cpp
--- src/Util.cpp	2015-08-28 22:18:43.000000000 +0930
+++ src_patched/Util.cpp	2018-10-15 12:56:13.000000000 +1030
@@ -8,7 +8,7 @@
 int sign(double x) {
 	if (x>=0) return 1;
 	if (x<0) return -1;
-	
+
 	return 0;
 }
 
@@ -29,7 +29,7 @@
 
   F.function = &stability_fcn;
   F.params = &p;
-  
+
   T = gsl_min_fminimizer_brent;
   s = gsl_min_fminimizer_alloc (T);
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
@@ -43,12 +43,12 @@
       m = gsl_min_fminimizer_x_minimum (s);
       a = gsl_min_fminimizer_x_lower (s);
       b = gsl_min_fminimizer_x_upper (s);
-      
+
       status = gsl_min_test_interval (a, b, abs_err, 0.0);
-     
+
     }
   while (status == GSL_CONTINUE && iter < max_iter);
-  
+
   p.m=m;
   p.v=gsl_min_fminimizer_f_minimum(s);
   gsl_min_fminimizer_free (s);
@@ -125,7 +125,7 @@
   //   A[0] = cg1/sqrt(cg);
   //   A[1] = cg + pow(cg1,2);
   //   A[2] = 1./sqrt(cg);
-  //   
+  //
   A[0] = k/sqrt(cg0);
   A[1] = cg0+pow(k,2);
   A[2] = 1./sqrt(cg0);
@@ -143,25 +143,25 @@
 
 
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-        
+
   double result, error;
-    
+
   ip.x1 = y;
-   
+
   gsl_function F;
   F.function = &hvv_fcn2;
   F.params = &ip;
-      
+
   double imin = 0.;
   double imax = pow(1.-sqrt(y),2);
-  
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
   int status = gsl_integration_qags (&F,imin,imax,0,1e-6,1000,
-			w, &result, &error); 
-    
-  if (status) 
+			w, &result, &error);
+
+  if (status)
     if (status!=GSL_EROUND) {
-      printf("GSL integration warning in H -> VV (off-shell). Please check result.\n");
+      //printf("GSL integration warning in H -> VV (off-shell). Please check result.\n");
       if (EXIT_ON_GSL_ERROR) exit(-1);
     }
   gsl_set_error_handler(old_handler);
@@ -200,7 +200,7 @@
      prod = bw1*bw2*gamma0*mh2*mh2;
   }
   return prod;
-     
+
 }
 
 double htt_fcn1(double y, void *params) {
@@ -208,30 +208,30 @@
   integration_params_tt ip = *((integration_params_tt*)params);
 
   gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-        
+
   double result, error;
-    
+
   ip.x1 = y;
-   
+
   gsl_function F;
   F.function = &htt_fcn2;
   F.params = &ip;
-      
+
   double imin = 0.;
   double imax = 2.-ip.x1;
-  
+
   gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
 //  int status = gsl_integration_qags (&F,imin,imax,0,1e-4,1000,
-//			w, &result, &error); 
+//			w, &result, &error);
   int status = gsl_integration_qag (&F,imin,imax,0,1e-4,1000,GSL_INTEG_GAUSS61,
-			w, &result, &error); 
+			w, &result, &error);
 
 
 
-    
-  if (status) 
+
+  if (status)
     if (status!=GSL_EROUND) {
-      printf("GSL integration warning in H/A -> tt (offshell). Please check the result., %d\n", status);
+      //printf("GSL integration warning in H/A -> tt (offshell). Please check the result., %d\n", status);
       if (EXIT_ON_GSL_ERROR) exit(-1);
     }
   gsl_set_error_handler(old_handler);
@@ -258,40 +258,40 @@
 
   double y1 = 1.-x1;
   double y2 = 1.-x2;
-  
+
   double kt = pow(mt/mh,2);
   double kb = pow(mb/mh,2);
   double kW = pow(mW/mh,2);
-  
+
   double gt = pow(gammat/mh,2);
-  
+
   double prod;
-  
+
   if ((x1 < sqrt(4.*kt))||(x2 < sqrt(4.*kb))) return 0.;
   if (x1+x2>2.) return 0.;
-  
+
   double cond = fabs((2.*(1.-x1-x2+kt+kb-kW)+x1*x2)) - (sqrt(pow(x1,2)-4.*kt)*sqrt(pow(x2,2)-4.*kb));
-   
+
   if(cond>0) {
      prod = 0;
   }
   else {
 
      double GA = 0;
-     
+
      if (ip.h<3) {
 		GA = pow(y1,2)*(1.-y1-y2+kW-5.*kt)+2.*kW*(y1*y2-kW-2.*kt*y1+4.*kt*kW)-kt*y1*y2+kt*(1.-4.*kt)*(2.*y1+kW+kt);
      } else if (ip.h==3) {
         GA = pow(y1,2)*(1.-y1-y2+kW-kt)+2*kW*(y1*y2-kW)-kt*(y1*y2-2.*y1-kW-kt);
      }
-     
+
      prod = GA/(pow(y1,2)+gt*kt);
 //     printf("xx %16.8E %16.8E %16.8E %16.8E\n", x1, x2, cond, prod);
 
   }
-  
+
   return prod;
-     
+
 }
 
 
@@ -310,14 +310,14 @@
 
   double A[3];
   A[0] = k2/sqrt(g);
-  A[1] = g+pow(k2,2); 
+  A[1] = g+pow(k2,2);
   A[2] = 1./sqrt(g);
 
   double cg0 = k2;
   double cg2 = g;
   double cg4 = k1;
   double cg6 = x;
-  
+
 
   // Maple code for differential width
   double cg = (-log(A[1]) * cg6 * sqrt(cg2) + log(A[1]) * sqrt(cg2) + 0.2e1 * atan(A[0]) * cg6 - 0.2e1 * atan(A[0]) * pow(cg6, 0.2e1) - 0.2e1 * atan(A[0]) * cg6 * cg4 + 0.2e1 * atan(A[0]) * cg6 * cg0 - 0.2e1 * atan(A[0]) * cg0 + cg6 * log(cg2 - 0.2e1 * pow(cg6, 0.3e1) + cg2 * pow(cg6, 0.2e1) + pow(cg0, 0.2e1) + pow(cg6, 0.2e1) - 0.2e1 * cg6 * cg0 + pow(cg6, 0.4e1) - 0.2e1 * pow(cg0, 0.2e1) * cg6 + 0.4e1 * cg0 * pow(cg6, 0.2e1) + 0.2e1 * cg0 * cg6 * cg4 - 0.2e1 * cg4 * cg0 * pow(cg6, 0.2e1) + pow(cg0, 0.2e1) * pow(cg6, 0.2e1) + 0.2e1 * pow(cg6, 0.3e1) * cg4 - 0.2e1 * pow(cg6, 0.3e1) * cg0 + pow(cg4, 0.2e1) * pow(cg6, 0.2e1) - 0.2e1 * cg2 * cg6 - 0.2e1 * cg4 * pow(cg6, 0.2e1)) * sqrt(cg2) - 0.2e1 * cg6 * log(0.1e1 - cg6) * sqrt(cg2) - log(cg2 - 0.2e1 * pow(cg6, 0.3e1) + cg2 * pow(cg6, 0.2e1) + pow(cg0, 0.2e1) + pow(cg6, 0.2e1) - 0.2e1 * cg6 * cg0 + pow(cg6, 0.4e1) - 0.2e1 * pow(cg0, 0.2e1) * cg6 + 0.4e1 * cg0 * pow(cg6, 0.2e1) + 0.2e1 * cg0 * cg6 * cg4 - 0.2e1 * cg4 * cg0 * pow(cg6, 0.2e1) + pow(cg0, 0.2e1) * pow(cg6, 0.2e1) + 0.2e1 * pow(cg6, 0.3e1) * cg4 - 0.2e1 * pow(cg6, 0.3e1) * cg0 + pow(cg4, 0.2e1) * pow(cg6, 0.2e1) - 0.2e1 * cg2 * cg6 - 0.2e1 * cg4 * pow(cg6, 0.2e1)) * sqrt(cg2) + 0.2e1 * log(0.1e1 - cg6) * sqrt(cg2) + 0.2e1 * atan((cg4 * cg6 - cg6 * cg0 + pow(cg6, 0.2e1) - cg6 + cg0) / (-0.1e1 + cg6) * A[2]) * cg6 - 0.2e1 * atan((cg4 * cg6 - cg6 * cg0 + pow(cg6, 0.2e1) - cg6 + cg0) / (-0.1e1 + cg6) * A[2]) * pow(cg6, 0.2e1) - 0.2e1 * atan((cg4 * cg6 - cg6 * cg0 + pow(cg6, 0.2e1) - cg6 + cg0) / (-0.1e1 + cg6) * A[2]) * cg6 * cg4 + 0.2e1 * atan((cg4 * cg6 - cg6 * cg0 + pow(cg6, 0.2e1) - cg6 + cg0) / (-0.1e1 + cg6) * A[2]) * cg6 * cg0 - 0.2e1 * atan((cg4 * cg6 - cg6 * cg0 + pow(cg6, 0.2e1) - cg6 + cg0) / (-0.1e1 + cg6) * A[2]) * cg0) * A[2] / 0.2e1;
@@ -330,9 +330,9 @@
 double cubic(double v, double X[4], double Y[4]) {
 
   if (v<0) return 0;
-  
+
   double x = log(v);
-   
+
   double x0 = log(X[0]);
   double x1 = log(X[1]);
   double x2 = log(X[2]);
@@ -341,12 +341,12 @@
   double y1 = log(Y[1]);
   double y2 = log(Y[2]);
   double y3 = log(Y[3]);
-   
+
   double A0 = (x-x1)*(x-x2)*(x-x3)/(x0-x1)/(x0-x2)/(x0-x3);
   double A1 = (x-x0)*(x-x2)*(x-x3)/(x1-x0)/(x1-x2)/(x1-x3);
   double A2 = (x-x0)*(x-x1)*(x-x3)/(x2-x0)/(x2-x1)/(x2-x3);
   double A3 = (x-x0)*(x-x1)*(x-x2)/(x3-x0)/(x3-x1)/(x3-x2);
-  
+
   double c = exp(A0*y0+A1*y1+A2*y2+A3*y3);
 
   return c;
@@ -356,28 +356,28 @@
 double htb_fcn1(double y, void *params) {
 
 	integration_params_tb ip = *((integration_params_tb*)params);
-	
+
 	gsl_integration_workspace * w = gsl_integration_workspace_alloc (1000);
-	
+
 	double result, error;
 	double msq = ip.M*ip.M - ip.mW*ip.mW;
 	double lsq1 = sqrtlambda( ip.M*ip.M , y , ip.mW*ip.mW );
 	double lsq2 = sqrtlambda( y , ip.mb*ip.mb , ip.md*ip.md );
 	ip.x1 = y;
-	 
+
 	gsl_function F;
 	F.function = &htb_fcn2;
 	F.params = &ip;
-	
+
 	double imin = (msq*msq-pow((lsq1 + lsq2),2))/(4*y);
 	double imax = (msq*msq-pow((lsq1 - lsq2),2))/(4*y);
-	
+
 	gsl_error_handler_t *old_handler = gsl_set_error_handler_off();
-	int status = gsl_integration_qag (&F,imin,imax,0,1e-4,1000,GSL_INTEG_GAUSS61,w, &result, &error); 
-	
+	int status = gsl_integration_qag (&F,imin,imax,0,1e-4,1000,GSL_INTEG_GAUSS61,w, &result, &error);
+
 	if(status)
 	if(status!=GSL_EROUND) {
-		printf("GSL integration warning in H+ -> tb (off-shell). Please check the result.\n");
+		//printf("GSL integration warning in H+ -> tb (off-shell). Please check the result.\n");
 		if (EXIT_ON_GSL_ERROR) exit(-1);
 	}
 	gsl_set_error_handler(old_handler);
@@ -390,7 +390,7 @@
 }
 
 
-double htb_fcn2(double y, void *params) 
+double htb_fcn2(double y, void *params)
 {
 	integration_params_tb ip = *((integration_params_tb*)params);
 	
@@ -404,16 +404,16 @@
 	double Zu = ip.Z_u;
 	double Zd = ip.Z_d;
 	double gtop = ip.gtop;
-		
+
 	double p1p2 = .5*(mh*mh + mb*mb - x1 - x2);
 	double p1p3 = .5*(x1 - md*md - mb*mb);
 	double p2p3 = .5*(x2 - mW*mW - md*md);
-	
-	double num = (mW*mW*p1p3 + 2*p2p3*p1p2)*(Zu*Zu*pow(mt,4) - Zd*Zd*md*md*x2) + 
+
+	double num = (mW*mW*p1p3 + 2*p2p3*p1p2)*(Zu*Zu*pow(mt,4) - Zd*Zd*md*md*x2) +
                      (mW*mW*md*md*(p2p3 + mb*mb) + 2*md*md*p2p3*(mW*mW + p2p3))*(2*Zd*Zd*(p1p2+p1p3) + 2*mt*mt*Zu*Zd);
-	
+
 	double prod = num/(pow((x2 - mt*mt),2)+mt*mt*gtop*gtop);
-	
+
 	return prod;
 }
 
@@ -428,5 +428,3 @@
 	double lam = sqrt(pow(a1,2) + pow(a2,2)+pow(a3,2) - 2*(a1*a2 + a1*a3 + a2*a3));
 	return lam;
 }
-
-
