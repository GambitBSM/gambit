amended_files:
  ../Backends/include/gambit/Backends/backend_types/SPheno.hpp:
  - "    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147>\
    \ Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n\
    \    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147>\
    \ Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n\
    \    typedef Farray<Freal8,1,1,1,39> Farray_Freal8_1_1_1_39;\n    typedef Farray<Freal8,1,1,1,39>\
    \ Farray_Freal8_1_1_1_39;\n    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n\
    \    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5>\
    \ Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n\
    \    typedef Farray<Freal8,1,2,1,26> Farray_Freal8_1_2_1_26;\n    typedef Farray<Freal8,1,2,1,26>\
    \ Farray_Freal8_1_2_1_26;\n    typedef Farray<Freal8,1,15> Farray_Freal8_1_15;\n\
    \    typedef Farray<Freal8,1,15> Farray_Freal8_1_15;\n    typedef Farray<Freal8,1,62>\
    \ Farray_Freal8_1_62;\n    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n\
    \    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147>\
    \ Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n\
    \    typedef Farray<Freal8,1,3,1,147> Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,3,1,147>\
    \ Farray_Freal8_1_3_1_147;\n    typedef Farray<Freal8,1,1,1,39> Farray_Freal8_1_1_1_39;\n\
    \    typedef Farray<Freal8,1,1,1,39> Farray_Freal8_1_1_1_39;\n    typedef Farray<Freal8,1,1,1,5>\
    \ Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n\
    \    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5>\
    \ Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,2,1,26> Farray_Freal8_1_2_1_26;\n\
    \    typedef Farray<Freal8,1,2,1,26> Farray_Freal8_1_2_1_26;\n    typedef Farray<Freal8,1,3,1,12>\
    \ Farray_Freal8_1_3_1_12;\n    typedef Farray<Freal8,1,3,1,12> Farray_Freal8_1_3_1_12;\n\
    \    typedef Farray<Freal8,1,3,1,12> Farray_Freal8_1_3_1_12;\n    typedef Farray<Freal8,1,3,1,12>\
    \ Farray_Freal8_1_3_1_12;\n    typedef Farray<Freal8,1,3,1,12> Farray_Freal8_1_3_1_12;\n\
    \    typedef Farray<Freal8,1,3,1,12> Farray_Freal8_1_3_1_12;\n    typedef Farray<Freal8,1,1,1,39>\
    \ Farray_Freal8_1_1_1_39;\n    typedef Farray<Freal8,1,1,1,39> Farray_Freal8_1_1_1_39;\n\
    \    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5>\
    \ Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n\
    \    typedef Farray<Freal8,1,1,1,5> Farray_Freal8_1_1_1_5;\n    typedef Farray<Freal8,1,2,1,26>\
    \ Farray_Freal8_1_2_1_26;\n    typedef Farray<Freal8,1,2,1,26> Farray_Freal8_1_2_1_26;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,2> Farray_Freal8_1_1_1_2;\n    typedef Farray<Freal8,1,70>\
    \ Farray_Freal8_1_70;\n    typedef Farray<Freal8,1,5,1,1,1,5> Farray_Freal8_1_5_1_1_1_5;\n\
    \    typedef Farray<Flogical,1,10> Farray_Flogical_1_10;\n    typedef Farray<Flogical,1,10>\
    \ Farray_Flogical_1_10;\n    typedef Farray<Freal8,1,1,1,3,1,3> Farray_Freal8_1_1_1_3_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3,1,3> Farray_Freal8_1_1_1_3_1_3;\n    typedef\
    \ Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1>\
    \ Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n\
    \    typedef Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1,1,1>\
    \ Farray_Freal8_1_1_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1,1,1> Farray_Freal8_1_1_1_1_1_1;\n\
    \    typedef Farray<Freal8,1,1,1,1,1,1> Farray_Freal8_1_1_1_1_1_1;\n    typedef\
    \ Farray<Freal8,1,1,1,1,1,1> Farray_Freal8_1_1_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1,1,1>\
    \ Farray_Freal8_1_1_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1,1,1> Farray_Freal8_1_1_1_1_1_1;\n\
    \    typedef Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1>\
    \ Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n\
    \    typedef Farray<Freal8,1,1,1,1> Farray_Freal8_1_1_1_1;\n    typedef Farray<Freal8,1,1,1,2>\
    \ Farray_Freal8_1_1_1_2;\n    typedef Farray<Freal8,1,1,1,2> Farray_Freal8_1_1_1_2;\n\
    \    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1>\
    \ Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,2> Farray_Freal8_1_1_1_2;\n\
    \    typedef Farray<Freal8,1,2,1,1> Farray_Freal8_1_2_1_1;\n    typedef Farray<Freal8,1,2,1,1>\
    \ Farray_Freal8_1_2_1_1;\n    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n\
    \    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1>\
    \ Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef\
    \ Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n\
    \    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1>\
    \ Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n\
    \    typedef Farray<Freal8,1,1,1,3> Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1,1,3>\
    \ Farray_Freal8_1_1_1_3;\n    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n\
    \    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1>\
    \ Farray_Freal8_1_1;\n    typedef Farray<Freal8,1,1> Farray_Freal8_1_1;\n    typedef\
    \ Farray<Fcomplex16,1,1,1,1> Farray_Fcomplex16_1_1_1_1;\n    typedef Farray<Fcomplex16,1,1,1,1>\
    \ Farray_Fcomplex16_1_1_1_1;\n"
  ../Backends/include/gambit/Backends/frontends/CalcHEP_3_6_27.hpp:
  - 'BE_INI_CONDITIONAL_DEPENDENCY(Inert_spectrum, Spectrum, Inert)

    '
  - BE_ALLOW_MODELS(Inert)
  ../Backends/src/frontends/CalcHEP_3_6_27.cpp:
  - "    if (ModelInUse(\"Inert\"))\n    {\n      BEpath = backendDir + \"/../models/Inert\"\
    ;\n      path = BEpath.c_str();\n      modeltoset = (char*)malloc(strlen(path)+11);\n\
    \      sprintf(modeltoset, \"%s\", path);\n      decays[\"~H0\"] = std::vector<\
    \ std::vector<str> >{ {\"Hm2\",\"Hp2\"}, {\"~A0\",\"h\"}, {\"~A0\",\"Z\"}, {\"\
    Wp\",\"Hp2\"}, {\"Wm\",\"Hm2\"} };\n      decays[\"~A0\"] = std::vector< std::vector<str>\
    \ >{ {\"Hm2\",\"Hp2\"}, {\"h\",\"~H0\"}, {\"Z\",\"~H0\"}, {\"Wp\",\"Hp2\"}, {\"\
    Wm\",\"Hm2\"} };\n      decays[\"h\"] = std::vector< std::vector<str> >{ {\"~A0\"\
    ,\"~A0\"}, {\"~H0\",\"~H0\"}, {\"Hm2\",\"Hp2\"}, {\"~H0\",\"~A0\"}, {\"Wp\",\"\
    Hp2\"}, {\"Wm\",\"Hm2\"} };\n      decays[\"Hp2\"] = std::vector< std::vector<str>\
    \ >{ {\"~A0\",\"Wm\"}, {\"~H0\",\"Wm\"}, {\"h\",\"Wm\"}, {\"Wm\",\"A\"}, {\"Z\"\
    ,\"Wm\"}, {\"U1\",\"d1\"}, {\"U2\",\"d1\"}, {\"U3\",\"d1\"}, {\"U1\",\"d2\"},\
    \ {\"U2\",\"d2\"}, {\"U3\",\"d2\"}, {\"U1\",\"d3\"}, {\"U2\",\"d3\"}, {\"U3\"\
    ,\"d3\"}, {\"Nu1\",\"e1\"}, {\"Nu2\",\"e1\"}, {\"Nu3\",\"e1\"}, {\"Nu1\",\"e2\"\
    }, {\"Nu2\",\"e2\"}, {\"Nu3\",\"e2\"}, {\"Nu1\",\"e3\"}, {\"Nu2\",\"e3\"}, {\"\
    Nu3\",\"e3\"} };\n      decays[\"Hm2\"] = std::vector< std::vector<str> >{ {\"\
    ~A0\",\"Wp\"}, {\"~H0\",\"Wp\"}, {\"h\",\"Wp\"}, {\"A\",\"Wp\"}, {\"Z\",\"Wp\"\
    }, {\"D1\",\"u1\"}, {\"D2\",\"u1\"}, {\"D3\",\"u1\"}, {\"D1\",\"u2\"}, {\"D2\"\
    ,\"u2\"}, {\"D3\",\"u2\"}, {\"D1\",\"u3\"}, {\"D2\",\"u3\"}, {\"D3\",\"u3\"},\
    \ {\"E1\",\"nu1\"}, {\"E2\",\"nu1\"}, {\"E3\",\"nu1\"}, {\"E1\",\"nu2\"}, {\"\
    E2\",\"nu2\"}, {\"E3\",\"nu2\"}, {\"E1\",\"nu3\"}, {\"E2\",\"nu3\"}, {\"E3\",\"\
    nu3\"} };\n      xsecs[std::vector<str>{\"~H0\", \"~H0\"}] = std::vector< std::vector<str>\
    \ >{ {\"Wm\",\"Wp\"}, {\"g\",\"g\"}, {\"E3\",\"e1\"}, {\"Wp\",\"Hp2\"}, {\"U2\"\
    ,\"u1\"}, {\"D1\",\"d3\"}, {\"D3\",\"d3\"}, {\"D2\",\"d2\"}, {\"U2\",\"u3\"},\
    \ {\"D1\",\"d1\"}, {\"D3\",\"d1\"}, {\"E2\",\"e1\"}, {\"U3\",\"u2\"}, {\"E1\"\
    ,\"e1\"}, {\"E2\",\"e2\"}, {\"E3\",\"e2\"}, {\"~H0\",\"~A0\"}, {\"Z\",\"h\"},\
    \ {\"U1\",\"u3\"}, {\"E1\",\"e3\"}, {\"U1\",\"u1\"}, {\"h\",\"h\"}, {\"D2\",\"\
    d1\"}, {\"Hm2\",\"Hp2\"}, {\"Hm2\",\"Wm\"}, {\"D3\",\"d2\"}, {\"D2\",\"d3\"},\
    \ {\"U2\",\"u2\"}, {\"A\",\"A\"}, {\"D1\",\"d2\"}, {\"~A0\",\"~A0\"}, {\"Z\",\"\
    Z\"}, {\"U3\",\"u1\"}, {\"E2\",\"e3\"}, {\"U1\",\"u2\"}, {\"U3\",\"u3\"}, {\"\
    E1\",\"e2\"}, {\"E3\",\"e3\"} };\n      model = \"Inert\";\n    }\n    \n"
  - "  if (ModelInUse(\"Inert\"))\n  {\n    // Obtain spectrum information to pass\
    \ to CalcHEP\n    const Spectrum& spec = *Dep::Inert_spectrum;\n    \n    // Obtain\
    \ model contents\n    static const SpectrumContents::Inert Inert_contents;\n \
    \   \n    // Obtain list of all parameters within model\n    static const std::vector<SpectrumParameter>\
    \ Inert_params = Inert_contents.all_parameters();\n    \n    Assign_All_Values(spec,\
    \ Inert_params);\n  }\n  \n"
  ../ColliderBit/include/gambit/ColliderBit/ColliderBit_Higgs_rollcall.hpp:
  - '    MODEL_CONDITIONAL_DEPENDENCY(Inert_spectrum, Spectrum, Inert)

    '
  ../ColliderBit/src/ColliderBit_Higgs.cpp:
  - "      else if (ModelInUse(\"Inert\"))\n      {\n        spectrum_dependency =\
    \ &Dep::Inert_spectrum;\n        Higgses = initVector<str>(\"h0_1\",\"h0_2\",\"\
    A0\");\n      }\n"
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp:
  - "    MODEL_CONDITIONAL_DEPENDENCY(Inert_spectrum, Spectrum, Inert)\n    ALLOW_MODELS(Inert)\n"
  - '      BACKEND_OPTION((MicrOmegas_Inert),(gimmemicro))

    '
  - "      BACKEND_OPTION((MicrOmegas_Inert),(gimmemicro))\n      ALLOW_MODEL(Inert)\n"
  ../DarkBit/src/DarkBit.cpp:
  - "      if(ModelInUse(\"Inert\"))\n        props.mass = Dep::Inert_spectrum->get(Par::Pole_Mass,\
    \ props.name);\n"
  ../DecayBit/include/gambit/DecayBit/DecayBit_rollcall.hpp:
  - "  #define CAPABILITY H_minus_decay_rates\n  START_CAPABILITY\n\n    #define FUNCTION\
    \ CH_Inert_H_minus_decays\n    START_FUNCTION(DecayTable::Entry)\n    DEPENDENCY(Inert_spectrum,\
    \ Spectrum)\n    BACKEND_REQ(CH_Decay_Width, (), double, (str&, str&, std::vector<str>&))\n\
    \    ALLOW_MODELS(Inert)\n    #undef FUNCTION\n\n  #undef CAPABILITY\n"
  - "    MODEL_CONDITIONAL_DEPENDENCY(Inert_spectrum, Spectrum, Inert)\n    MODEL_CONDITIONAL_DEPENDENCY(H_minus_decay_rates,\
    \ DecayTable::Entry, Inert)\n"
  - "    #define FUNCTION all_Inert_decays_from_SPheno\n    START_FUNCTION(DecayTable)\n\
    \    DEPENDENCY(W_minus_decay_rates, DecayTable::Entry)\n    DEPENDENCY(W_plus_decay_rates,\
    \ DecayTable::Entry)\n    DEPENDENCY(Z_decay_rates, DecayTable::Entry)\n    DEPENDENCY(Inert_spectrum,\
    \ Spectrum)\n    BACKEND_REQ(SARAHSPheno_Inert_decays, (libSPhenoInert), int,\
    \ (const Spectrum&, DecayTable&, const Finputs&) )\n    BACKEND_OPTION((SARAHSPheno_Inert,\
    \ 4.0.3), (libSPhenoInert))\n    ALLOW_MODELS(Inert)\n    #undef FUNCTION\n  \
    \  \n"
  ../DecayBit/src/DecayBit.cpp:
  - "    void CH_Inert_h0_2_decays(DecayTable::Entry& result)\n    {\n      using\
    \ namespace Pipes::CH_Inert_h0_2_decays;\n      // Clear previous decays\n   \
    \   result = DecayTable::Entry();\n      \n      const Spectrum& spec = *Dep::Inert_spectrum;\n\
    \      \n      str model = \"Inert\";\n      str in = \"~H0\"; // In state: CalcHEP\
    \ particle name\n      std::vector<std::vector<str>> out_calchep = {{\"Hm2\",\
    \ \"Hp2\"}, {\"~A0\", \"h\"}, {\"~A0\", \"Z\"}, {\"Wp\", \"Hp2\"}, {\"Wm\", \"\
    Hm2\"}}; // Out states: CalcHEP particle names\n      std::vector<std::vector<str>>\
    \ out_gambit = {{\"H-\", \"H+\"}, {\"A0\", \"h0_1\"}, {\"A0\", \"Z0\"}, {\"W+\"\
    , \"H+\"}, {\"W-\", \"H-\"}}; // Out states: GAMBIT particle names\n      \n \
    \     for (unsigned int i=0; i<out_calchep.size(); i++)\n      {\n        \n \
    \       double gamma = BEreq::CH_Decay_Width(model, in, out_calchep[i]); // Partial\
    \ width\n        double newwidth = result.width_in_GeV + gamma;  // Adjust total\
    \ width\n        double wscaling = ( gamma == 0. ) ? 1 : result.width_in_GeV/newwidth;\
    \ // Scaling for BFs, avoid NaNs\n        result.width_in_GeV = newwidth;\n  \
    \      \n        for (auto it = result.channels.begin(); it != result.channels.end();\
    \ ++it)\n        {\n          it->second.first  *= wscaling; // rescale BF \n\
    \          it->second.second *= wscaling; // rescale error on BF \n        }\n\
    \        \n        // Avoid NaNs!\n        double BF = ( gamma == 0. ) ? 0. :\
    \ gamma/result.width_in_GeV;\n        \n        result.set_BF(BF, 0.0, out_gambit[i][0],\
    \ out_gambit[i][1]);\n        \n      }\n      \n      check_width(LOCAL_INFO,\
    \ result.width_in_GeV, runOptions->getValueOrDef<bool>(false, \"invalid_point_for_negative_width\"\
    ));\n    }\n    \n    void CH_Inert_A0_decays(DecayTable::Entry& result)\n   \
    \ {\n      using namespace Pipes::CH_Inert_A0_decays;\n      // Clear previous\
    \ decays\n      result = DecayTable::Entry();\n      \n      const Spectrum& spec\
    \ = *Dep::Inert_spectrum;\n      \n      str model = \"Inert\";\n      str in\
    \ = \"~A0\"; // In state: CalcHEP particle name\n      std::vector<std::vector<str>>\
    \ out_calchep = {{\"Hm2\", \"Hp2\"}, {\"h\", \"~H0\"}, {\"Z\", \"~H0\"}, {\"Wp\"\
    , \"Hp2\"}, {\"Wm\", \"Hm2\"}}; // Out states: CalcHEP particle names\n      std::vector<std::vector<str>>\
    \ out_gambit = {{\"H-\", \"H+\"}, {\"h0_1\", \"h0_2\"}, {\"Z0\", \"h0_2\"}, {\"\
    W+\", \"H+\"}, {\"W-\", \"H-\"}}; // Out states: GAMBIT particle names\n     \
    \ \n      for (unsigned int i=0; i<out_calchep.size(); i++)\n      {\n       \
    \ \n        double gamma = BEreq::CH_Decay_Width(model, in, out_calchep[i]); //\
    \ Partial width\n        double newwidth = result.width_in_GeV + gamma;  // Adjust\
    \ total width\n        double wscaling = ( gamma == 0. ) ? 1 : result.width_in_GeV/newwidth;\
    \ // Scaling for BFs, avoid NaNs\n        result.width_in_GeV = newwidth;\n  \
    \      \n        for (auto it = result.channels.begin(); it != result.channels.end();\
    \ ++it)\n        {\n          it->second.first  *= wscaling; // rescale BF \n\
    \          it->second.second *= wscaling; // rescale error on BF \n        }\n\
    \        \n        // Avoid NaNs!\n        double BF = ( gamma == 0. ) ? 0. :\
    \ gamma/result.width_in_GeV;\n        \n        result.set_BF(BF, 0.0, out_gambit[i][0],\
    \ out_gambit[i][1]);\n        \n      }\n      \n      check_width(LOCAL_INFO,\
    \ result.width_in_GeV, runOptions->getValueOrDef<bool>(false, \"invalid_point_for_negative_width\"\
    ));\n    }\n    \n    void CH_Inert_Higgs_decays(DecayTable::Entry& result)\n\
    \    {\n      using namespace Pipes::CH_Inert_Higgs_decays;\n      // Clear previous\
    \ decays\n      result = DecayTable::Entry();\n      \n      const Spectrum& spec\
    \ = *Dep::Inert_spectrum;\n      \n      result = *Dep::Reference_SM_Higgs_decay_rates;\n\
    \      \n      str model = \"Inert\";\n      str in = \"h\"; // In state: CalcHEP\
    \ particle name\n      std::vector<std::vector<str>> out_calchep = {{\"~A0\",\
    \ \"~A0\"}, {\"~H0\", \"~H0\"}, {\"Hm2\", \"Hp2\"}, {\"~H0\", \"~A0\"}, {\"Wp\"\
    , \"Hp2\"}, {\"Wm\", \"Hm2\"}}; // Out states: CalcHEP particle names\n      std::vector<std::vector<str>>\
    \ out_gambit = {{\"A0\", \"A0\"}, {\"h0_2\", \"h0_2\"}, {\"H-\", \"H+\"}, {\"\
    h0_2\", \"A0\"}, {\"W+\", \"H+\"}, {\"W-\", \"H-\"}}; // Out states: GAMBIT particle\
    \ names\n      \n      for (unsigned int i=0; i<out_calchep.size(); i++)\n   \
    \   {\n        \n        double gamma = BEreq::CH_Decay_Width(model, in, out_calchep[i]);\
    \ // Partial width\n        double newwidth = result.width_in_GeV + gamma;  //\
    \ Adjust total width\n        double wscaling = ( gamma == 0. ) ? 1 : result.width_in_GeV/newwidth;\
    \ // Scaling for BFs, avoid NaNs\n        result.width_in_GeV = newwidth;\n  \
    \      \n        for (auto it = result.channels.begin(); it != result.channels.end();\
    \ ++it)\n        {\n          it->second.first  *= wscaling; // rescale BF \n\
    \          it->second.second *= wscaling; // rescale error on BF \n        }\n\
    \        \n        // Avoid NaNs!\n        double BF = ( gamma == 0. ) ? 0. :\
    \ gamma/result.width_in_GeV;\n        \n        result.set_BF(BF, 0.0, out_gambit[i][0],\
    \ out_gambit[i][1]);\n        \n      }\n      \n      check_width(LOCAL_INFO,\
    \ result.width_in_GeV, runOptions->getValueOrDef<bool>(false, \"invalid_point_for_negative_width\"\
    ));\n    }\n    \n    void CH_Inert_H_plus_decays(DecayTable::Entry& result)\n\
    \    {\n      using namespace Pipes::CH_Inert_H_plus_decays;\n      // Clear previous\
    \ decays\n      result = DecayTable::Entry();\n      \n      const Spectrum& spec\
    \ = *Dep::Inert_spectrum;\n      \n      str model = \"Inert\";\n      str in\
    \ = \"Hp2\"; // In state: CalcHEP particle name\n      std::vector<std::vector<str>>\
    \ out_calchep = {{\"~A0\", \"Wm\"}, {\"~H0\", \"Wm\"}, {\"h\", \"Wm\"}, {\"Wm\"\
    , \"A\"}, {\"Z\", \"Wm\"}, {\"U1\", \"d1\"}, {\"U2\", \"d1\"}, {\"U3\", \"d1\"\
    }, {\"U1\", \"d2\"}, {\"U2\", \"d2\"}, {\"U3\", \"d2\"}, {\"U1\", \"d3\"}, {\"\
    U2\", \"d3\"}, {\"U3\", \"d3\"}, {\"Nu1\", \"e1\"}, {\"Nu2\", \"e1\"}, {\"Nu3\"\
    , \"e1\"}, {\"Nu1\", \"e2\"}, {\"Nu2\", \"e2\"}, {\"Nu3\", \"e2\"}, {\"Nu1\",\
    \ \"e3\"}, {\"Nu2\", \"e3\"}, {\"Nu3\", \"e3\"}}; // Out states: CalcHEP particle\
    \ names\n      std::vector<std::vector<str>> out_gambit = {{\"A0\", \"W-\"}, {\"\
    h0_2\", \"W-\"}, {\"h0_1\", \"W-\"}, {\"W-\", \"gamma\"}, {\"Z0\", \"W-\"}, {\"\
    ubar_1\", \"d_1\"}, {\"ubar_2\", \"d_1\"}, {\"ubar_3\", \"d_1\"}, {\"ubar_1\"\
    , \"d_2\"}, {\"ubar_2\", \"d_2\"}, {\"ubar_3\", \"d_2\"}, {\"ubar_1\", \"d_3\"\
    }, {\"ubar_2\", \"d_3\"}, {\"ubar_3\", \"d_3\"}, {\"nubar_1\", \"e-_1\"}, {\"\
    nubar_2\", \"e-_1\"}, {\"nubar_3\", \"e-_1\"}, {\"nubar_1\", \"e-_2\"}, {\"nubar_2\"\
    , \"e-_2\"}, {\"nubar_3\", \"e-_2\"}, {\"nubar_1\", \"e-_3\"}, {\"nubar_2\", \"\
    e-_3\"}, {\"nubar_3\", \"e-_3\"}}; // Out states: GAMBIT particle names\n    \
    \  \n      for (unsigned int i=0; i<out_calchep.size(); i++)\n      {\n      \
    \  \n        double gamma = BEreq::CH_Decay_Width(model, in, out_calchep[i]);\
    \ // Partial width\n        double newwidth = result.width_in_GeV + gamma;  //\
    \ Adjust total width\n        double wscaling = ( gamma == 0. ) ? 1 : result.width_in_GeV/newwidth;\
    \ // Scaling for BFs, avoid NaNs\n        result.width_in_GeV = newwidth;\n  \
    \      \n        for (auto it = result.channels.begin(); it != result.channels.end();\
    \ ++it)\n        {\n          it->second.first  *= wscaling; // rescale BF \n\
    \          it->second.second *= wscaling; // rescale error on BF \n        }\n\
    \        \n        // Avoid NaNs!\n        double BF = ( gamma == 0. ) ? 0. :\
    \ gamma/result.width_in_GeV;\n        \n        result.set_BF(BF, 0.0, out_gambit[i][0],\
    \ out_gambit[i][1]);\n        \n      }\n      \n      check_width(LOCAL_INFO,\
    \ result.width_in_GeV, runOptions->getValueOrDef<bool>(false, \"invalid_point_for_negative_width\"\
    ));\n    }\n    \n    void CH_Inert_H_minus_decays(DecayTable::Entry& result)\n\
    \    {\n      using namespace Pipes::CH_Inert_H_minus_decays;\n      // Clear\
    \ previous decays\n      result = DecayTable::Entry();\n      \n      const Spectrum&\
    \ spec = *Dep::Inert_spectrum;\n      \n      str model = \"Inert\";\n      str\
    \ in = \"Hm2\"; // In state: CalcHEP particle name\n      std::vector<std::vector<str>>\
    \ out_calchep = {{\"~A0\", \"Wp\"}, {\"~H0\", \"Wp\"}, {\"h\", \"Wp\"}, {\"A\"\
    , \"Wp\"}, {\"Z\", \"Wp\"}, {\"D1\", \"u1\"}, {\"D2\", \"u1\"}, {\"D3\", \"u1\"\
    }, {\"D1\", \"u2\"}, {\"D2\", \"u2\"}, {\"D3\", \"u2\"}, {\"D1\", \"u3\"}, {\"\
    D2\", \"u3\"}, {\"D3\", \"u3\"}, {\"E1\", \"nu1\"}, {\"E2\", \"nu1\"}, {\"E3\"\
    , \"nu1\"}, {\"E1\", \"nu2\"}, {\"E2\", \"nu2\"}, {\"E3\", \"nu2\"}, {\"E1\",\
    \ \"nu3\"}, {\"E2\", \"nu3\"}, {\"E3\", \"nu3\"}}; // Out states: CalcHEP particle\
    \ names\n      std::vector<std::vector<str>> out_gambit = {{\"A0\", \"W+\"}, {\"\
    h0_2\", \"W+\"}, {\"h0_1\", \"W+\"}, {\"gamma\", \"W+\"}, {\"Z0\", \"W+\"}, {\"\
    dbar_1\", \"u_1\"}, {\"dbar_2\", \"u_1\"}, {\"dbar_3\", \"u_1\"}, {\"dbar_1\"\
    , \"u_2\"}, {\"dbar_2\", \"u_2\"}, {\"dbar_3\", \"u_2\"}, {\"dbar_1\", \"u_3\"\
    }, {\"dbar_2\", \"u_3\"}, {\"dbar_3\", \"u_3\"}, {\"e+_1\", \"nu_1\"}, {\"e+_2\"\
    , \"nu_1\"}, {\"e+_3\", \"nu_1\"}, {\"e+_1\", \"nu_2\"}, {\"e+_2\", \"nu_2\"},\
    \ {\"e+_3\", \"nu_2\"}, {\"e+_1\", \"nu_3\"}, {\"e+_2\", \"nu_3\"}, {\"e+_3\"\
    , \"nu_3\"}}; // Out states: GAMBIT particle names\n      \n      for (unsigned\
    \ int i=0; i<out_calchep.size(); i++)\n      {\n        \n        double gamma\
    \ = BEreq::CH_Decay_Width(model, in, out_calchep[i]); // Partial width\n     \
    \   double newwidth = result.width_in_GeV + gamma;  // Adjust total width\n  \
    \      double wscaling = ( gamma == 0. ) ? 1 : result.width_in_GeV/newwidth; //\
    \ Scaling for BFs, avoid NaNs\n        result.width_in_GeV = newwidth;\n     \
    \   \n        for (auto it = result.channels.begin(); it != result.channels.end();\
    \ ++it)\n        {\n          it->second.first  *= wscaling; // rescale BF \n\
    \          it->second.second *= wscaling; // rescale error on BF \n        }\n\
    \        \n        // Avoid NaNs!\n        double BF = ( gamma == 0. ) ? 0. :\
    \ gamma/result.width_in_GeV;\n        \n        result.set_BF(BF, 0.0, out_gambit[i][0],\
    \ out_gambit[i][1]);\n        \n      }\n      \n      check_width(LOCAL_INFO,\
    \ result.width_in_GeV, runOptions->getValueOrDef<bool>(false, \"invalid_point_for_negative_width\"\
    ));\n    }\n    \n"
  - "      \n      // Inert-specific\n      if (ModelInUse(\"Inert\"))\n      {\n\
    \        decays(\"H-\") = *Dep::H_minus_decay_rates;\n      }\n"
  - "    \n    /// Get all the decays from SPheno (for the Inert model).\n    void\
    \ all_Inert_decays_from_SPheno(DecayTable& decays)\n    {\n      namespace myPipe\
    \ = Pipes::all_Inert_decays_from_SPheno;\n      \n      // Get the spectrum object\n\
    \      Spectrum spectrum = *myPipe::Dep::Inert_spectrum;\n      \n      // Set\
    \ up the input structure\n      Finputs inputs;\n      inputs.param = myPipe::Param;\n\
    \      inputs.options = myPipe::runOptions;\n      \n      // Use SPheno to fill\
    \ the decay table\n      myPipe::BEreq::SARAHSPheno_Inert_decays(spectrum, decays,\
    \ inputs);\n      \n      // Add some SM decays\n      decays(\"Z0\") = *myPipe::Dep::Z_decay_rates;\
    \           // Add the Z decays\n      decays(\"W+\") = *myPipe::Dep::W_plus_decay_rates;\
    \      // Add the W decays for W+.\n      decays(\"W-\") = *myPipe::Dep::W_minus_decay_rates;\
    \     // Add the W decays for W-\n      \n      /// Spit out the full decay table\
    \ as an SLHA2 file.\n      /// We do not provide SLHA1 as that requires knowledge\
    \ of the pseudonyms, which we do not have in general.\n      if (myPipe::runOptions->getValueOrDef<bool>(false,\
    \ \"drop_SLHA_file\"))\n      {\n        str prefix   = myPipe::runOptions->getValueOrDef<str>(\"\
    \", \"SLHA_output_prefix\");\n        str filename = myPipe::runOptions->getValueOrDef<str>(\"\
    GAMBIT_decays\", \"SLHA_output_filename\");\n        decays.writeSLHAfile(2,prefix+filename+\"\
    .slha2\",false);\n      }\n      \n    }\n    \n"
  ../Models/include/gambit/Models/SpectrumContents/RegisteredSpectra.hpp:
  - '    struct Inert                : SubSpectrumContents { Inert(); };

    '
  ../SpecBit/include/gambit/SpecBit/SpecBit_rollcall.hpp:
  - "  \n  /// Module function declarations for SpecBit_Inert.cpp\n  #include \"gambit/SpecBit/SpecBit_Inert_rollcall.hpp\"\
    \n  \n"
  ../Utils/include/gambit/Utils/citation_keys.hpp:
  - "    \"Bloor:2021gtp\", // GUM 1.0 Paper\n    \"Staub:2013tta\", // SARAH 4.0\n\
    \    \"Staub:2012pb\", // SARAH 3.2\n    \"Staub:2008uz\", // SARAH\n    \"Staub:2010jh\"\
    , // SARAH: Automatic Calc of SUSY RGE and Self Energies\n    \"Staub:2015kfa\"\
    , // SARAH: Exploring new models in detail\n    \"Pukhov:2004ca\", // Calchep\
    \ 2.3\n    \"Belyaev:2012qa\", // Calchep 3.4\n    \"Belanger:2014vza\", // Micromegas\
    \ 4.1\n    \"Belanger:2013oya\", // Micromegas 3.0\n    \"Belanger:2010gh\", //\
    \ Micromegas 2.4\n    \"Belanger:2008sj\", // Micromegas 2.2\n    \"Belanger:2006is\"\
    , // Micromegas 2.0\n    \"Belanger:2004yn\", // Micromegas 1.3\n    \"Belanger:2001fz\"\
    , // Micromegas 1.0\n    \"Porod:2003um\", // Spheno\n    \"Porod:2011nf\", //\
    \ Spheno 3.1\n"
  ../cmake/backends.cmake:
  - "\n# MicrOmegas Inert model\nset(model \"Inert\")\nset(patch \"${PROJECT_SOURCE_DIR}/Backends/patches/${name}/${ver}/Inert/patch_${name}_${ver}_${model}.dif\"\
    )\nset(patchdir \"${PROJECT_SOURCE_DIR}/Backends/patches/${name}/${ver}/Inert\"\
    )\ncheck_ditch_status(${name}_${model} ${ver} ${dir})\nif(NOT ditched_${name}_${model}_${ver})\n\
    \  ExternalProject_Add(${name}_${model}_${ver}\n    DOWNLOAD_COMMAND \"\"\n  \
    \  SOURCE_DIR ${dir}\n    PATCH_COMMAND ./newProject ${model} && patch -p0 < ${patch}\n\
    \    CONFIGURE_COMMAND ${CMAKE_COMMAND} -E copy_directory ${patchdir}/mdlfiles\
    \ ${dir}/${model}/work/models/\n    BUILD_IN_SOURCE 1\n    CONFIGURE_COMMAND \"\
    \"\n    BUILD_COMMAND ${CMAKE_COMMAND} -E chdir ${model} ${CMAKE_MAKE_PROGRAM}\
    \ sharedlib main=main.c\n    INSTALL_COMMAND \"\"\n  )\n  add_extra_targets(\"\
    backend model\" ${name} ${ver} ${dir}/${model} ${model} \"yes | clean\")\n  set_as_default_version(\"\
    backend model\" ${name} ${ver} ${model})\nendif()\n\n"
  - "# SARAH-SPheno Inert model\nset(name \"sarah-spheno\")\nset(model \"Inert\")\n\
    set(cleanmodel \"Inert\")\nset(ver \"4.0.3\")\nset(lib \"lib/libSPheno${cleanmodel}.so\"\
    )\nset(dl \"http://www.hepforge.org/archive/spheno/SPheno-${ver}.tar.gz\")\nset(md5\
    \ \"64787d6c8ce03cac38aec53d34ac46ad\")\nset(dir \"${PROJECT_SOURCE_DIR}/Backends/installed/${name}/${ver}/${model}\"\
    )\nset(sarahdir \"${PROJECT_SOURCE_DIR}/Backends/patches/${name}/${ver}/${model}/unpatched/\"\
    )\nfile(GLOB sarahfiles  \"${sarahdir}/[a-zA-Z0-9]*\")\nstring(REGEX REPLACE \"\
    (-cpp)|(-fpp)\" \"\" SPheno_FLAGS \"${BACKEND_Fortran_FLAGS}\") #SPheno hates\
    \ the preprocessor\nset(SPheno_FLAGS \"-c ${SPheno_FLAGS} -${FMODULE} ${dir}/include\
    \ -I${dir}/include\")\nset(patch \"${PROJECT_SOURCE_DIR}/Backends/patches/${name}/${ver}/${model}/patch_${name}_${ver}_${model}.dif\"\
    )\ncheck_ditch_status(${name}_${model} ${ver} ${dir})\nif(NOT ditched_${name}_${model}_${ver})\n\
    \  ExternalProject_Add(${name}_${model}_${ver}\n    DOWNLOAD_COMMAND ${DL_BACKEND}\
    \ ${dl} ${md5} ${dir}\n             COMMAND ${CMAKE_COMMAND} -E make_directory\
    \ \"${dir}/${cleanmodel}\"\n             COMMAND cp -r \"${sarahfiles}\" \"${dir}/${cleanmodel}\"\
    \n    SOURCE_DIR ${dir}\n    BUILD_IN_SOURCE 1\n    PATCH_COMMAND patch -p1 <\
    \ ${patch}\n    CONFIGURE_COMMAND \"\"\n    BUILD_COMMAND ${CMAKE_MAKE_PROGRAM}\
    \ Model=${cleanmodel} F90=${CMAKE_Fortran_COMPILER} FFLAGS=\"${SPheno_FLAGS}\"\
    \ ${lib}\n    INSTALL_COMMAND \"\"\n  )\n  add_extra_targets(\"backend\" ${name}_${model}\
    \ ${ver} ${dir} ${dl} cleanall)\n  set_as_default_version(\"backend\" ${name}_${model}\
    \ ${ver})\nendif()\n\n"
  ../config/backend_locations.yaml.default:
  - "# Added by GUM\nMicrOmegas_Inert:\n  3.6.9.2:     ./Backends/installed/micromegas/3.6.9.2/Inert/libmicromegas.so\n\
    \n"
  - "# Added by GUM\nSARAHSPheno_Inert:\n  4.0.3:       ./Backends/installed/sarah-spheno/4.0.3/Inert/lib/libSPhenoInert.so\n\
    \n"
  ../config/capabilities.dat:
  - "\n#####  Inert model #####\n\nInert_parameters: |\n    Parameters for the model\
    \ Inert (see ./gambit Inert).\n\nSARAHSPheno_Inert_internal: |\n    Exclusively\
    \ used for internal variables and functions for the SARAH-SPheno backend.\n\n\
    SARAHSPheno_Inert_spectrum: |\n    Calculates and returns a Inert spectrum object\
    \ using SARAH-SPheno.\n\nSARAHSPheno_Inert_decays: |\n    Calculates and returns\
    \ all decays for the Inert model using SARAH-SPheno.\n\nSARAHSPheno_Inert_HiggsCouplingsTable:\
    \ |\n    Fills the Higgs couplings table using SARAH-SPheno.\n\nSARAHSPheno_Inert_4_0_3_init:\
    \ |\n    Initialisation of backend SARAH-SPheno v4.0.3 for model Inert.\n\nH_minus_decay_rates:\
    \ |\n    All decay rates for particle H-.\n\nMicrOmegas_Inert_3_6_9_2_init: |\n\
    \    Initialise MicrOmegas Inert backend.\n\nInert_spectrum: |\n    Create spectrum\
    \ object for Inert model.\n\n"
  ../config/models.dat:
  - "\nInert: |\n    Inert model, created by GUM, with parameters: Lam1, Lam2, Lam3,\
    \ Lam4, Lam5\n\n"
capabilities:
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp:
  - DarkMatter_ID|DarkMatter_ID_Inert
  - DarkMatterConj_ID|DarkMatterConj_ID_Inert
  - TH_ProcessCatalog|TH_ProcessCatalog_Inert
  ../DecayBit/include/gambit/DecayBit/DecayBit_rollcall.hpp:
  - h0_2_decay_rates|CH_Inert_h0_2_decays
  - A0_decay_rates|CH_Inert_A0_decays
  - Higgs_decay_rates|CH_Inert_Higgs_decays
  - H_plus_decay_rates|CH_Inert_H_plus_decays
new_dirs:
  hard:
  - ../Backends/patches/sarah-spheno/4.0.3/Inert/unpatched
  soft:
  - ../Backends/patches/calchep/3.6.27/Models/Inert/
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles
  - ../Backends/patches/sarah-spheno/4.0.3/Inert
new_files:
  files:
  - ../Models/include/gambit/Models/models/Inert.hpp
  - ../Models/src/SpectrumContents/Inert.cpp
  - ../Models/include/gambit/Models/SimpleSpectra/InertSimpleSpec.hpp
  - ../SpecBit/src/SpecBit_Inert.cpp
  - ../SpecBit/include/gambit/SpecBit/SpecBit_Inert_rollcall.hpp
  - ../DarkBit/src/Inert.cpp
  - ../Backends/patches/calchep/3.6.27/Models/Inert/func1.mdl
  - ../Backends/patches/calchep/3.6.27/Models/Inert/vars1.mdl
  - ../Backends/patches/calchep/3.6.27/Models/Inert/lgrng1.mdl
  - ../Backends/patches/calchep/3.6.27/Models/Inert/prtcls1.mdl
  - ../Backends/patches/calchep/3.6.27/Models/Inert/extlib1.mdl
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles/func1.mdl
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles/vars1.mdl
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles/lgrng1.mdl
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles/prtcls1.mdl
  - ./../Backends/patches/micromegas/3.6.9.2/Inert/mdlfiles/extlib1.mdl
  - ../Backends/patches/micromegas/3.6.9.2/Inert/patch_micromegas_3.6.9.2_Inert.dif
  - ../Backends/src/frontends/MicrOmegas_Inert_3_6_9_2.cpp
  - ../Backends/include/gambit/Backends/frontends/MicrOmegas_Inert_3_6_9_2.hpp
  - ../Backends/src/frontends/SARAHSPheno_Inert_4_0_3.cpp
  - ../Backends/include/gambit/Backends/frontends/SARAHSPheno_Inert_4_0_3.hpp
  - ../Backends/patches/sarah-spheno/4.0.3/Inert/patch_sarah-spheno_4.0.3_Inert.dif
  - ../Backends/data/SARAHSPheno_Inert_4_0_3_decays_info.dat
  - ../yaml_files/Inert_example.yaml
new_models:
  ? ../ColliderBit/include/gambit/ColliderBit/ColliderBit_Higgs_rollcall.hpp|HB_ModelParameters_neutral|MSSMLikeHiggs_ModelParameters|ALLOW_MODELS
  : - Inert
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp|DD_couplings|DD_couplings_MicrOmegas|ALLOW_MODEL_DEPENDENCE:
  - Inert
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp|DD_couplings|DD_couplings_MicrOmegas|MODEL_GROUP(group2:
  - Inert
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp|RD_eff_annrate|RD_eff_annrate_from_ProcessCatalog|ALLOW_MODELS:
  - Inert
  ../DarkBit/include/gambit/DarkBit/DarkBit_rollcall.hpp|RD_spectrum|RD_spectrum_from_ProcessCatalog|ALLOW_MODELS:
  - Inert
particles: {}
